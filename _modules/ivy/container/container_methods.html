<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ivy.container.container_methods &mdash; Ivy 1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="icon" type="image/png" href="https://github.com/unifyai/unifyai.github.io/blob/master/img/externally_linked/ivy_logo_only.png?raw=true">
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Ivy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../background.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../related_work.html">Related Work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions.html">Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deep_dive.html">Deep Dive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/compilation.html">Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/constants.html">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/creation.html">Creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/data_type.html">Data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/device.html">Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/elementwise.html">Elementwise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/experimental.html">Experimental</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/general.html">General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/gradients.html">Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/linear_algebra.html">Linear algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/losses.html">Losses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/manipulation.html">Manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/meta.html">Meta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/nest.html">Nest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/random.html">Random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/searching.html">Searching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/sorting.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/statistical.html">Statistical</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/utility.html">Utility</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../data_classes/container.html">Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_classes/array.html">Array</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Framework Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/optimizers.html">Optimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/initializers.html">Initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/sequential.html">Sequential</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/module.html">Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/converters.html">Converters</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ivy"">Ivy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mech"">Ivy mech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../vision"">Ivy vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../robot"">Ivy robot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gym"">Ivy gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory"">Ivy memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../builder"">Ivy builder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models"">Ivy models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ecosystem"">Ivy ecosystem</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Ivy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>ivy.container.container_methods</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ivy.container.container_methods</h1><div class="highlight"><pre>
<span></span><span class="c1">#ivy.container.activations</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_relu"><a class="viewcode-back" href="../../../functional/ivy/activations/relu/static_relu_container.html#ivy.container.container_methods.static_relu">[docs]</a><span class="k">def</span> <span class="nf">static_relu</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the rectified linear activation unit function</span>
<span class="sd">        applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, -1.2]), b=ivy.array([0.4, -0.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_relu(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">    a: ivy.array([1., 0.]),</span>
<span class="sd">    b: ivy.array([0.40000001, 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;relu&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="relu"><a class="viewcode-back" href="../../../functional/ivy/activations/relu/relu_container.html#ivy.container.container_methods.relu">[docs]</a><span class="k">def</span> <span class="nf">relu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the rectified linear activation unit function</span>
<span class="sd">        applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, -1.2]), b=ivy.array([0.4, -0.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.relu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">    a: ivy.array([1., 0.]),</span>
<span class="sd">    b: ivy.array([0.40000001, 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_relu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_leaky_relu"><a class="viewcode-back" href="../../../functional/ivy/activations/leaky_relu/static_leaky_relu_container.html#ivy.container.container_methods.static_leaky_relu">[docs]</a><span class="k">def</span> <span class="nf">static_leaky_relu</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.leaky_relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.leaky_relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    alpha</span>
<span class="sd">        array or scalar specifying the negative slope.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">         a container with the leaky relu unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a =ivy.array([0.39, -0.85]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_leaky_relu(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">          a: ivy.array([0.39, -0.17])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;leaky_relu&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="leaky_relu"><a class="viewcode-back" href="../../../functional/ivy/activations/leaky_relu/leaky_relu_container.html#ivy.container.container_methods.leaky_relu">[docs]</a><span class="k">def</span> <span class="nf">leaky_relu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.leaky_relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.leaky_relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    alpha</span>
<span class="sd">        array or scalar specifying the negative slope.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">       a container with the leaky relu unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a =ivy.array([0.39, -0.85]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.leaky_relu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.39, -0.17])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_leaky_relu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_gelu"><a class="viewcode-back" href="../../../functional/ivy/activations/gelu/static_gelu_container.html#ivy.container.container_methods.static_gelu">[docs]</a><span class="k">def</span> <span class="nf">static_gelu</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">approximate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.gelu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.gelu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    approximate</span>
<span class="sd">        whether to use the gelu approximation algorithm or exact formulation.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the gelu unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a =ivy.array([0.3, -0.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_gelu(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.185, -0.046])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;gelu&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">approximate</span><span class="o">=</span><span class="n">approximate</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gelu"><a class="viewcode-back" href="../../../functional/ivy/activations/gelu/gelu_container.html#ivy.container.container_methods.gelu">[docs]</a><span class="k">def</span> <span class="nf">gelu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">approximate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.gelu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.gelu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    approximate</span>
<span class="sd">        whether to use the gelu approximation algorithm or exact formulation.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the gelu unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a =ivy.array([0.3, -0.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.gelu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.185, -0.046])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_gelu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">approximate</span><span class="o">=</span><span class="n">approximate</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_sigmoid"><a class="viewcode-back" href="../../../functional/ivy/activations/sigmoid/static_sigmoid_container.html#ivy.container.container_methods.static_sigmoid">[docs]</a><span class="k">def</span> <span class="nf">static_sigmoid</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sigmoid.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.sigmoid also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the sigmoid unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1., 1., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sigmoid(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.269, 0.731, 0.881])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sigmoid&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sigmoid"><a class="viewcode-back" href="../../../functional/ivy/activations/sigmoid/sigmoid_container.html#ivy.container.container_methods.sigmoid">[docs]</a><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sigmoid.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.sigmoid also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the sigmoid unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1., 1., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sigmoid()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.269, 0.731, 0.881])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sigmoid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_softmax"><a class="viewcode-back" href="../../../functional/ivy/activations/softmax/static_softmax_container.html#ivy.container.container_methods.static_softmax">[docs]</a><span class="k">def</span> <span class="nf">static_softmax</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.softmax.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.softmax also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the softmax should be computed</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the softmax unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 0, 1.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_softmax(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.422, 0.155, 0.422])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;softmax&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="softmax"><a class="viewcode-back" href="../../../functional/ivy/activations/softmax/softmax_container.html#ivy.container.container_methods.softmax">[docs]</a><span class="k">def</span> <span class="nf">softmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.softmax.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.softmax also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the softmax should be computed</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the softmax unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 0, 1.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.softmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.422, 0.155, 0.422])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_softmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_softplus"><a class="viewcode-back" href="../../../functional/ivy/activations/softplus/static_softplus_container.html#ivy.container.container_methods.static_softplus">[docs]</a><span class="k">def</span> <span class="nf">static_softplus</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.softplus.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.softplus also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    beta</span>
<span class="sd">        The beta value for the softplus formation. Default: ``None``.</span>
<span class="sd">    threshold</span>
<span class="sd">        values above this revert to a linear function. Default: ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the softplus unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-0.3461, -0.6491]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_softplus(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.535, 0.42])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_softplus(x, beta=0.5, threshold=2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.948, 2.63, 4.25])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;softplus&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="softplus"><a class="viewcode-back" href="../../../functional/ivy/activations/softplus/softplus_container.html#ivy.container.container_methods.softplus">[docs]</a><span class="k">def</span> <span class="nf">softplus</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.softplus.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.softplus also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    beta</span>
<span class="sd">        The beta value for the softplus formation. Default: ``None``.</span>
<span class="sd">    threshold</span>
<span class="sd">        values above this revert to a linear function. Default: ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the softplus unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-0.3461, -0.6491]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.softplus()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.535, 0.42])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.softplus(beta=0.5, threshold=2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.948, 2.63, 4.25])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_softplus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_log_softmax"><a class="viewcode-back" href="../../../functional/ivy/activations/log_softmax/static_log_softmax_container.html#ivy.container.container_methods.static_log_softmax">[docs]</a><span class="k">def</span> <span class="nf">static_log_softmax</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log_softmax.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.log_softmax also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the log_softmax should be computed</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the log_softmax unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1.0, -0.98, 2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_log_softmax(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-3.37, -3.35, -0.0719])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 2.4]), b=ivy.array([-0.2, -1.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_log_softmax(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.62, -0.22]),</span>
<span class="sd">        b: ivy.array([-0.371, -1.17])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;log_softmax&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log_softmax"><a class="viewcode-back" href="../../../functional/ivy/activations/log_softmax/log_softmax_container.html#ivy.container.container_methods.log_softmax">[docs]</a><span class="k">def</span> <span class="nf">log_softmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log_softmax.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.log_softmax also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the log_softmax should be computed</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the log_softmax unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1.0, -0.98, 2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.log_softmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-3.37, -3.35, -0.0719])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 2.4]), b=ivy.array([-0.2, -1.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.log_softmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.62, -0.22]),</span>
<span class="sd">        b: ivy.array([-0.371, -1.17])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_log_softmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.base</span>
<span class="sd">&quot;&quot;&quot;Base Container Object.&quot;&quot;&quot;</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">termcolor</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">ivy.exceptions</span> <span class="kn">import</span> <span class="n">IvyBackendException</span><span class="p">,</span> <span class="n">IvyException</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># noinspection PyPackageRequirements</span>
    <span class="kn">import</span> <span class="nn">h5py</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">h5py</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">set</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="n">ansi_escape</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\x1B(?:[@-Z</span><span class="se">\\</span><span class="s2">-_]|\[[0-?]*[ -/]*[@-~])&quot;</span><span class="p">)</span>

<span class="c1"># noinspection PyMissingConstructor</span>

<span class="k">def</span> <span class="nf">_is_jsonable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
<span class="k">def</span> <span class="nf">_repr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">pass</span>




<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dict_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">queues</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">queue_load_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">container_combine_method</span><span class="o">=</span><span class="s2">&quot;list_join&quot;</span><span class="p">,</span>
    <span class="n">queue_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">print_limit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">key_length_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">print_indent</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">print_line_spacing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">ivyh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_key_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
    <span class="n">keyword_color_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rebuild_child_containers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">types_to_iteratively_nest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alphabetical_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initialize container object from input dict representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dict_in</span>
<span class="sd">        the dictionary the container should wrap around. Default is ``None``.</span>
<span class="sd">    queues</span>
<span class="sd">        Sequence of multiprocessing queues, each of which returns containers.</span>
<span class="sd">        This enables the current container to be passed around asynchronously while</span>
<span class="sd">        waiting for data. Default is ``None``.</span>
<span class="sd">    queue_load_sizes</span>
<span class="sd">        Size of leading dimension of the containers returned by each queue.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    container_combine_method</span>
<span class="sd">        The method to use for combining containers arriving from different queues.</span>
<span class="sd">        Default is ivy.Container.list_join</span>
<span class="sd">    queue_timeout</span>
<span class="sd">        The timeout when waiting for containers to arrive from the queues.</span>
<span class="sd">        Default is global.</span>
<span class="sd">    print_limit</span>
<span class="sd">        The total array size limit when printing the container. Default is 10.</span>
<span class="sd">    key_length_limit</span>
<span class="sd">        The maximum key length when printing the container. Default is ``None``.</span>
<span class="sd">    print_indent</span>
<span class="sd">        The number of whitespaces to use for indenting when printing the container.</span>
<span class="sd">        Default is 4.</span>
<span class="sd">    print_line_spacing</span>
<span class="sd">        The number of extra newlines to use between keys when printing the</span>
<span class="sd">        container. Default is ``0``.</span>
<span class="sd">    ivyh</span>
<span class="sd">        Handle to ivy module to use for the calculations. Default is ``None``, which</span>
<span class="sd">        results in the global ivy.</span>
<span class="sd">    default_key_color</span>
<span class="sd">        The default key color for printing the container to the terminal.</span>
<span class="sd">        Default is &#39;green&#39;.</span>
<span class="sd">    keyword_color_dict</span>
<span class="sd">        A dict mapping keywords to their termcolor color codes for printing the</span>
<span class="sd">        container. (Default value = None)</span>
<span class="sd">    rebuild_child_containers</span>
<span class="sd">        Whether to rebuild container found in dict_in with these constructor params.</span>
<span class="sd">        Default is ``False``, in which case the original container are kept as are.</span>
<span class="sd">    types_to_iteratively_nest</span>
<span class="sd">        The data types to nest iteratively in the dict structure, each type must be</span>
<span class="sd">        iterable. Default is ``None``.</span>
<span class="sd">    alphabetical_keys</span>
<span class="sd">        Whether to sort the container keys alphabetically, or preserve the dict</span>
<span class="sd">        order. Default is ``True``.</span>
<span class="sd">    kwargs</span>
<span class="sd">        keyword arguments for dict creation. Default is ``None``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span> <span class="o">=</span> <span class="n">queues</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_container_combine_method</span> <span class="o">=</span> <span class="n">container_combine_method</span>
    <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_container_combine_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_container_combine_method</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;list_join&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_join</span><span class="p">,</span>
                <span class="s2">&quot;concat&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">conts</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">conts</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">_container_combine_method</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loaded_containers_from_queues</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue_load_sizes_cum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">queue_load_sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue_timeout</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">queue_timeout</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_queue_timeout</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">dict_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">dict_in</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dict_in</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
            <span class="s2">&quot;dict_in and **kwargs cannot both be specified for ivy.Container &quot;</span>
            <span class="s2">&quot;constructor, please specify one or the other, not both.&quot;</span>
        <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_config_in</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">print_limit</span><span class="o">=</span><span class="n">print_limit</span><span class="p">,</span>
        <span class="n">print_indent</span><span class="o">=</span><span class="n">print_indent</span><span class="p">,</span>
        <span class="n">key_length_limit</span><span class="o">=</span><span class="n">key_length_limit</span><span class="p">,</span>
        <span class="n">print_line_spacing</span><span class="o">=</span><span class="n">print_line_spacing</span><span class="p">,</span>
        <span class="n">ivyh</span><span class="o">=</span><span class="n">ivyh</span><span class="p">,</span>
        <span class="n">default_key_color</span><span class="o">=</span><span class="n">default_key_color</span><span class="p">,</span>
        <span class="n">keyword_color_dict</span><span class="o">=</span><span class="n">keyword_color_dict</span><span class="p">,</span>
        <span class="n">rebuild_child_containers</span><span class="o">=</span><span class="n">rebuild_child_containers</span><span class="p">,</span>
        <span class="n">types_to_iteratively_nest</span><span class="o">=</span><span class="n">types_to_iteratively_nest</span><span class="p">,</span>
        <span class="n">alphabetical_keys</span><span class="o">=</span><span class="n">alphabetical_keys</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cont_inplace_update</span><span class="p">(</span><span class="n">dict_in</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config_in</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">multi_map_in_static_method</span><span class="p">(</span>
    <span class="n">fn_name</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="n">arg_cont_idxs</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nested_argwhere</span><span class="p">(</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_container</span><span class="p">,</span> <span class="n">to_ignore</span><span class="o">=</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span>
    <span class="p">)</span>
    <span class="n">kwarg_cont_idxs</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nested_argwhere</span><span class="p">(</span>
        <span class="n">kwargs</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_container</span><span class="p">,</span> <span class="n">to_ignore</span><span class="o">=</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span>
    <span class="p">)</span>
    <span class="c1"># retrieve all the containers in args and kwargs</span>
    <span class="n">arg_conts</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multi_index_nest</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">arg_cont_idxs</span><span class="p">)</span>
    <span class="n">num_arg_conts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_conts</span><span class="p">)</span>
    <span class="n">kwarg_conts</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">multi_index_nest</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">kwarg_cont_idxs</span><span class="p">)</span>
    <span class="c1"># Combine the retrieved containers from args and kwargs into a single list</span>
    <span class="n">with_out</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">ivy</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">fn_name</span><span class="p">])</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">with_out</span><span class="p">:</span>
        <span class="n">conts</span> <span class="o">=</span> <span class="n">arg_conts</span> <span class="o">+</span> <span class="n">kwarg_conts</span> <span class="o">+</span> <span class="p">[</span><span class="n">out</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conts</span> <span class="o">=</span> <span class="n">arg_conts</span> <span class="o">+</span> <span class="n">kwarg_conts</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_exists</span><span class="p">(</span><span class="n">conts</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;no containers found in arguments&quot;</span><span class="p">)</span>
    <span class="n">cont0</span> <span class="o">=</span> <span class="n">conts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Get the function with the name fn_name, enabling containers to specify</span>
    <span class="c1"># their backends irrespective of global ivy&#39;s backend</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">cont0</span><span class="o">.</span><span class="n">ivy</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">fn_name</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">map_fn</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">with_out</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">arg_vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[:</span><span class="n">num_arg_conts</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">set_nest_at_indices</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">arg_cont_idxs</span><span class="p">,</span> <span class="n">arg_vals</span><span class="p">)</span>
        <span class="n">kwarg_vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">num_arg_conts</span><span class="p">:]</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">set_nest_at_indices</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="n">kwarg_cont_idxs</span><span class="p">,</span> <span class="n">kwarg_vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_out</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="c1"># Replace each container in arg and kwarg with the arrays at the leaf</span>
    <span class="c1"># levels of that container using map_fn and call fn using those arrays</span>
    <span class="c1"># as inputs</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="n">map_fn</span><span class="p">,</span>
        <span class="n">conts</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_nests</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="n">out</span><span class="o">.</span><span class="n">inplace_update</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">out</span>
    <span class="c1"># Multiple containers for functions returning multiple arrays</span>
    <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_array</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">unstack_conts</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">handle_inplace</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an inplace update of out, provided it is not None, by updating with</span>
<span class="sd">    the values in ret.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ret</span>
<span class="sd">        The container with the return values</span>
<span class="sd">    out</span>
<span class="sd">        The optional out container, which is primed for being overwritten if it</span>
<span class="sd">        exists</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The out container, but filled with the values from the ret container</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="n">out</span><span class="o">.</span><span class="n">inplace_update</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">out</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">list_join</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Join containers of lists together along the specified dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to list join</span>
<span class="sd">    config</span>
<span class="sd">        The configuration for the containers. Default is the same as container0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        List joined containers, with each entry being a list of arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">container0</span> <span class="o">=</span> <span class="n">containers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">container0</span><span class="o">.</span><span class="n">config</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">container0</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">new_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">container</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">:</span>
                <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">list_join</span><span class="p">(</span><span class="n">new_list</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">containers</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">list_stack</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;List stack containers together along the specified dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to list stack</span>
<span class="sd">    dim</span>
<span class="sd">        dimension along which to list stack</span>
<span class="sd">    config</span>
<span class="sd">        The configuration for the containers. Default is the same as container0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Stacked containers, with each entry being a list of arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">container0</span> <span class="o">=</span> <span class="n">containers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">container0</span><span class="o">.</span><span class="n">config</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">container0</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">list_stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">container</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">container</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">],</span> <span class="n">dim</span><span class="p">,</span> <span class="n">config</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">containers</span>


<span class="k">def</span> <span class="nf">_concat_unify</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">cont</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_sum_unify</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">cont</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span>
        <span class="n">start</span><span class="o">=</span><span class="n">ivy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([]),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_mean_unify</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">_sum_unify</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">containers</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unify</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unify a list of containers, on arbitrary devices, to a single container on</span>
<span class="sd">    the specified device.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to unify</span>
<span class="sd">    dev</span>
<span class="sd">        The device to unify the containers to.</span>
<span class="sd">    mode</span>
<span class="sd">        The mode by which to unify, must be one of [ concat | mean | sum ]</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to concattenate the container, if concat mode is set.</span>
<span class="sd">        Default is ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Unified container</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;concat&quot;</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">_concat_unify</span><span class="p">,</span>
        <span class="s2">&quot;sum&quot;</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">_sum_unify</span><span class="p">,</span>
        <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">_mean_unify</span><span class="p">,</span>
    <span class="p">}[</span><span class="n">mode</span><span class="p">](</span><span class="n">containers</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="o">*</span><span class="n">containers</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine keys and values in a sequence of containers, with priority given to</span>
<span class="sd">    the right-most container in the case of duplicates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to compare</span>
<span class="sd">    config</span>
<span class="sd">        The configuration for the containers. Default is the same as</span>
<span class="sd">        container_rightmost.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Combined containers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if inputs are not dicts, then simply return the right-most value</span>
    <span class="n">container_rightmost</span> <span class="o">=</span> <span class="n">containers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container_rightmost</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">container_rightmost</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
        <span class="c1"># noinspection PyUnresolvedReferences</span>
        <span class="n">config</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">container_rightmost</span><span class="o">.</span><span class="n">config</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container_rightmost</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">{}</span>
        <span class="p">)</span>
    <span class="c1"># return if len==1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">container_rightmost</span>
    <span class="c1"># otherwise, check that the keys are aligned between each container, and apply</span>
    <span class="c1"># this method recursively</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">item</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">cont</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
        <span class="n">keys_present</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="ow">in</span> <span class="n">cont</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
        <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">cont</span><span class="p">,</span> <span class="n">kp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">keys_present</span><span class="p">)</span> <span class="k">if</span> <span class="n">kp</span><span class="p">],</span>
            <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span>
    <span class="o">*</span><span class="n">containers</span><span class="p">,</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">diff_keys</span><span class="o">=</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span>
    <span class="n">detect_key_diffs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">detect_value_diffs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">detect_shape_diffs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compare keys and values in a sequence of containers, returning the single</span>
<span class="sd">    shared values where they are the same, and new nested sub-dicts with all values</span>
<span class="sd">    where they are different.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to compare</span>
<span class="sd">    mode</span>
<span class="sd">        The mode of the diff operation, returning either all keys and values,</span>
<span class="sd">        only those that are consist across the containers, or only the differences.</span>
<span class="sd">        Default is all.</span>
<span class="sd">    diff_keys</span>
<span class="sd">        The key/keys to add to the returned container when differences are found.</span>
<span class="sd">        Default is ``&quot;diff&quot;``.</span>
<span class="sd">    detect_key_diffs</span>
<span class="sd">        Whether to treat different keys as detected differences. If not, the keys</span>
<span class="sd">        among the input containers are simply combined without flagging differences.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    detect_value_diffs</span>
<span class="sd">        Whether to treat different values as detected differences.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    detect_shape_diffs</span>
<span class="sd">        Whether to treat different array shapes as detected differences.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    config</span>
<span class="sd">        The configuration for the containers. Default is the same as container0.</span>
<span class="sd">    *containers</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Compared containers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_elem_in_list</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;same_only&quot;</span><span class="p">,</span> <span class="s2">&quot;diff_only&quot;</span><span class="p">])</span>
    <span class="c1"># if inputs are not dicts, then compare their values to determine the diff dict</span>
    <span class="n">num_containers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">containers</span><span class="p">)</span>
    <span class="n">container0</span> <span class="o">=</span> <span class="n">containers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">container0</span><span class="o">.</span><span class="n">config</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">equal_mat</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">all_equal</span><span class="p">(</span><span class="o">*</span><span class="n">containers</span><span class="p">,</span> <span class="n">equality_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">detect_value_diffs</span><span class="p">:</span>
            <span class="n">equal_mat</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">equal_mat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">detect_shape_diffs</span><span class="p">:</span>
            <span class="n">shape_equal_mat</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">all_equal</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">],</span>
                <span class="n">equality_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">equal_mat</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">equal_mat</span><span class="p">,</span> <span class="n">shape_equal_mat</span><span class="p">)</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ivy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">equal_mat</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;diff_only&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">container0</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same_only&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cont_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_containers</span><span class="p">)</span>
            <span class="n">diff_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">cont_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cont_range</span><span class="p">,</span> <span class="n">containers</span><span class="p">))</span>
            <span class="n">idxs_added</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cont_range</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">idxs_added</span><span class="p">:</span>
                    <span class="n">idxs_to_add</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">equal_mat</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">idxs_to_add_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                        <span class="n">ivy</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">idxs_to_add</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">diff_keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">diff_keys</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idxs_to_add_list</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">diff_keys</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">diff_keys</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
                            <span class="s2">&quot;diff_keys must be either a string or list of strings,&quot;</span>
                            <span class="s2">&quot;but found </span><span class="si">{}</span><span class="s2"> of type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">diff_keys</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">diff_keys</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">diff_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cont_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">idxs_added</span> <span class="o">+=</span> <span class="n">idxs_to_add_list</span>
            <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">diff_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">)</span>
    <span class="c1"># otherwise, check that the keys are aligned between each container, and apply</span>
    <span class="c1"># this method recursively</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">item</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">cont</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
        <span class="n">keys_present</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="ow">in</span> <span class="n">cont</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
        <span class="n">all_keys_present</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">keys_present</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_containers</span>
        <span class="k">if</span> <span class="n">all_keys_present</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span><span class="n">cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">],</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">diff_keys</span><span class="o">=</span><span class="n">diff_keys</span><span class="p">,</span>
                <span class="n">detect_key_diffs</span><span class="o">=</span><span class="n">detect_key_diffs</span><span class="p">,</span>
                <span class="n">detect_value_diffs</span><span class="o">=</span><span class="n">detect_value_diffs</span><span class="p">,</span>
                <span class="n">detect_shape_diffs</span><span class="o">=</span><span class="n">detect_shape_diffs</span><span class="p">,</span>
                <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="nb">sum</span><span class="p">(</span><span class="n">keys_present</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">detect_key_diffs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">containers</span><span class="p">[</span><span class="n">keys_present</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">)][</span><span class="n">key</span><span class="p">]</span>
            <span class="k">continue</span>
        <span class="n">diff_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">key_present</span><span class="p">,</span> <span class="n">cont</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys_present</span><span class="p">,</span> <span class="n">containers</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">detect_key_diffs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key_present</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;same_only&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">diff_keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">diff_dict</span><span class="p">[</span><span class="n">diff_keys</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">diff_keys</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                        <span class="n">diff_dict</span><span class="p">[</span><span class="n">diff_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
                            <span class="s2">&quot;diff_keys must be either a string or list of strings,&quot;</span>
                            <span class="s2">&quot;but found </span><span class="si">{}</span><span class="s2"> of type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">diff_keys</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">diff_keys</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
        <span class="k">if</span> <span class="n">diff_dict</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff_dict</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">structural_diff</span><span class="p">(</span>
    <span class="o">*</span><span class="n">containers</span><span class="p">,</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">diff_keys</span><span class="o">=</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span>
    <span class="n">detect_key_diffs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">detect_shape_diffs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compare keys and shapes in a sequence of containers, returning the single</span>
<span class="sd">    shared values where they are the same, and new nested sub-dicts with all values</span>
<span class="sd">    where they are different.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to compare</span>
<span class="sd">    mode</span>
<span class="sd">        The mode of the diff operation, returning either all keys and values,</span>
<span class="sd">        only those that are consist across the containers, or only the differences.</span>
<span class="sd">        Default is all.</span>
<span class="sd">    diff_keys</span>
<span class="sd">        The key/keys to add to the returned container when differences are found.</span>
<span class="sd">        Default is &quot;diff&quot;.</span>
<span class="sd">    detect_key_diffs</span>
<span class="sd">        Whether to treat different keys as detected differences.</span>
<span class="sd">        If not, the keys among the input containers are simply combined without</span>
<span class="sd">        flagging differences. Default is ``True``.</span>
<span class="sd">    detect_shape_diffs</span>
<span class="sd">        Whether to treat different array shapes as detected differences.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    config</span>
<span class="sd">        The configuration for the containers. Default is the same as container0.</span>
<span class="sd">    *containers</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Compared containers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span>
        <span class="o">*</span><span class="n">containers</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">diff_keys</span><span class="o">=</span><span class="n">diff_keys</span><span class="p">,</span>
        <span class="n">detect_key_diffs</span><span class="o">=</span><span class="n">detect_key_diffs</span><span class="p">,</span>
        <span class="n">detect_value_diffs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">detect_shape_diffs</span><span class="o">=</span><span class="n">detect_shape_diffs</span><span class="p">,</span>
        <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">multi_map</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span>
    <span class="n">containers</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">map_nests</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">assert_identical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply function to all array values from a collection of identically</span>
<span class="sd">    structured containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func</span>
<span class="sd">        Function to apply to each container entry.</span>
<span class="sd">    containers</span>
<span class="sd">        containers to map.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied,</span>
<span class="sd">        otherwise the leftmost container value is used. Default is ``False``.</span>
<span class="sd">    key_chain</span>
<span class="sd">        Chain of keys for this dict entry (Default value = &#39;&#39;)</span>
<span class="sd">    config</span>
<span class="sd">        The configuration for the containers. Default is the same as container0.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    assert_identical</span>
<span class="sd">        Whether to assert that the input containers are identical or not.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">container0</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">container0</span> <span class="o">=</span> <span class="n">cont</span>
            <span class="k">break</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_exists</span><span class="p">(</span>
        <span class="n">container0</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;No containers found in the inputs to ivy.Container.multi_map&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">container0</span><span class="o">.</span><span class="n">config</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">container0</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cont</span> <span class="k">else</span> <span class="n">cont</span>
            <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span>
        <span class="p">]</span>
        <span class="n">value0</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">this_key_chain</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="n">key_chain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="n">key_chain</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">is_container</span> <span class="o">=</span> <span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_container</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">assert_identical</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_container</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_container</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key_chains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">this_key_chain</span> <span class="ow">in</span> <span class="n">key_chains</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">to_apply</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">this_key_chain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key_chains</span> <span class="ow">and</span> <span class="n">to_apply</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="n">prune_unapplied</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value0</span>
                    <span class="k">continue</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">this_key_chain</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
                    <span class="n">func</span><span class="p">,</span>
                    <span class="n">values</span><span class="p">,</span>
                    <span class="n">key_chains</span><span class="p">,</span>
                    <span class="n">to_apply</span><span class="p">,</span>
                    <span class="n">prune_unapplied</span><span class="p">,</span>
                    <span class="n">this_key_chain</span><span class="p">,</span>
                    <span class="n">config</span><span class="p">,</span>
                    <span class="n">map_nests</span><span class="p">,</span>
                    <span class="n">assert_identical</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_nests</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nested_multi_map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">values</span><span class="p">,</span> <span class="n">to_ivy</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">prune_unapplied</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key_chains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">this_key_chain</span> <span class="ow">in</span> <span class="n">key_chains</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">to_apply</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">this_key_chain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key_chains</span> <span class="ow">and</span> <span class="n">to_apply</span>
                    <span class="p">):</span>
                        <span class="k">if</span> <span class="n">prune_unapplied</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value0</span>
                        <span class="k">continue</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">this_key_chain</span><span class="p">)</span>
        <span class="c1"># noinspection PyProtectedMember</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">common_key_chains</span><span class="p">(</span><span class="n">containers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the key-chains common across all containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        Containers to check.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        list of key-chains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">containers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">all_key_chains</span><span class="p">()</span>
    <span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">cont</span><span class="o">.</span><span class="n">all_key_chains</span><span class="p">())</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>


<span class="k">def</span> <span class="nf">identical</span><span class="p">(</span>
    <span class="n">containers</span><span class="p">,</span>
    <span class="n">check_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">check_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">same_arrays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">arrays_equal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a single boolean as to whether the input containers have identical</span>
<span class="sd">    key-chains and data types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to check.</span>
<span class="sd">    check_types</span>
<span class="sd">        Whether to check if the datatypes of the leaf nodes are the same.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    check_shapes</span>
<span class="sd">        Whether to check if the shapes of the leaf nodes are the same.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    same_arrays</span>
<span class="sd">        Whether to check if the arrays are the exact same instances.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    arrays_equal</span>
<span class="sd">        Whether to check if the arrays have equal values. Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chain</span>
<span class="sd">        Chain of keys for this dict entry (Default value = &#39;&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">partial</span><span class="p">:</span>
        <span class="n">common_key_chains</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">common_key_chains</span><span class="p">(</span><span class="n">containers</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">common_key_chains</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">containers</span> <span class="o">=</span> <span class="p">[</span><span class="n">cont</span><span class="o">.</span><span class="n">at_key_chains</span><span class="p">(</span><span class="n">common_key_chains</span><span class="p">)</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">cont</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">])</span>
    <span class="c1"># noinspection PyProtectedMember</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">min</span><span class="p">([</span><span class="n">key</span> <span class="ow">in</span> <span class="n">cont</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
        <span class="n">value_0</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">type_0</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">value_0</span><span class="p">)</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">min</span><span class="p">([</span><span class="n">type_n</span> <span class="ow">is</span> <span class="n">type_0</span> <span class="k">for</span> <span class="n">type_n</span> <span class="ow">in</span> <span class="n">types</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="ow">or</span> <span class="n">check_types</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">value_0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">check_shapes</span><span class="p">:</span>
                <span class="n">shape_0</span> <span class="o">=</span> <span class="n">value_0</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">min</span><span class="p">([</span><span class="n">shape_n</span> <span class="o">==</span> <span class="n">shape_0</span> <span class="k">for</span> <span class="n">shape_n</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">]):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">same_arrays</span><span class="p">:</span>
                <span class="n">id_0</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">value_0</span><span class="p">)</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">min</span><span class="p">([</span><span class="n">id_n</span> <span class="o">==</span> <span class="n">id_0</span> <span class="k">for</span> <span class="n">id_n</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">]):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">arrays_equal</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">all_equal</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="n">this_key_chain</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="n">key_chain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="n">key_chain</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span>
                <span class="n">check_types</span><span class="p">,</span>
                <span class="n">check_shapes</span><span class="p">,</span>
                <span class="n">same_arrays</span><span class="p">,</span>
                <span class="n">arrays_equal</span><span class="p">,</span>
                <span class="n">key_chains</span><span class="p">,</span>
                <span class="n">to_apply</span><span class="p">,</span>
                <span class="n">partial</span><span class="p">,</span>
                <span class="n">this_key_chain</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">assert_identical</span><span class="p">(</span>
    <span class="n">containers</span><span class="p">,</span>
    <span class="n">check_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">check_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">same_arrays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">arrays_equal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Assert whether the input containers are identical. Otherwise, the diff is</span>
<span class="sd">    shown in an exception.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to check.</span>
<span class="sd">    check_types</span>
<span class="sd">        Whether to check if the datatypes of the leaf nodes are the same.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    check_shapes</span>
<span class="sd">        Whether to check if the shapes of the leaf nodes are the same.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    same_arrays</span>
<span class="sd">        Whether to check if the arrays are the exact same instances.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    arrays_equal</span>
<span class="sd">        Whether to check if the arrays have equal values. Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_true</span><span class="p">(</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span>
            <span class="n">containers</span><span class="p">,</span>
            <span class="n">check_types</span><span class="p">,</span>
            <span class="n">check_shapes</span><span class="p">,</span>
            <span class="n">same_arrays</span><span class="p">,</span>
            <span class="n">arrays_equal</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="p">,</span>
            <span class="n">partial</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="s2">&quot;Containers were not identical:</span><span class="se">\n\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">*</span><span class="n">containers</span><span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">identical_structure</span><span class="p">(</span>
    <span class="n">containers</span><span class="p">,</span>
    <span class="n">check_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">check_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a single boolean as to whether the input containers have identical</span>
<span class="sd">    structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to check.</span>
<span class="sd">    check_types</span>
<span class="sd">        Whether to also check whether the datatypes of the leaf nodes are the same.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    check_shapes</span>
<span class="sd">        Whether to also check whether the shapes of the leaf nodes are the same.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chain</span>
<span class="sd">        Chain of keys for this dict entry (Default value = &#39;&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span>
        <span class="n">containers</span><span class="p">,</span>
        <span class="n">check_types</span><span class="p">,</span>
        <span class="n">check_shapes</span><span class="p">,</span>
        <span class="kc">False</span><span class="p">,</span>
        <span class="kc">False</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">partial</span><span class="p">,</span>
        <span class="n">key_chain</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">assert_identical_structure</span><span class="p">(</span>
    <span class="n">containers</span><span class="p">,</span>
    <span class="n">check_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">check_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Assert whether the input containers have identical structure. Otherwise, the</span>
<span class="sd">    diff is shown in an exception.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to check.</span>
<span class="sd">    check_types</span>
<span class="sd">        Whether to also check whether the datatypes of the leaf nodes are the same.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    check_shapes</span>
<span class="sd">        Whether to also check whether the shapes of the leaf nodes are the same.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_true</span><span class="p">(</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">identical_structure</span><span class="p">(</span>
            <span class="n">containers</span><span class="p">,</span> <span class="n">check_types</span><span class="p">,</span> <span class="n">check_shapes</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">,</span> <span class="n">to_apply</span><span class="p">,</span> <span class="n">partial</span>
        <span class="p">),</span>
        <span class="s2">&quot;Containers did not have identical structure:</span><span class="se">\n\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">structural_diff</span><span class="p">(</span><span class="o">*</span><span class="n">containers</span><span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">identical_configs</span><span class="p">(</span><span class="n">containers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a single boolean as to whether the input containers all have</span>
<span class="sd">    identical configs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to check.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">containers</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">configs</span> <span class="o">=</span> <span class="p">[</span><span class="n">cont</span><span class="o">.</span><span class="n">config</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
    <span class="n">config0</span> <span class="o">=</span> <span class="n">configs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">config0</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">min</span><span class="p">([</span><span class="n">config</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span> <span class="k">for</span> <span class="n">config</span> <span class="ow">in</span> <span class="n">configs</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">identical_array_shapes</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether all of the containers have identical number of arrays and</span>
<span class="sd">    identical array shapes, regardless of their key-chain structures.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to check.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array. (Default value = False)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array_conts</span> <span class="o">=</span> <span class="p">[</span><span class="n">cont</span><span class="o">.</span><span class="n">size_ordered_arrays</span><span class="p">(</span><span class="n">exclusive</span><span class="p">)</span> <span class="k">for</span> <span class="n">cont</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">]</span>
    <span class="n">array_cont0</span> <span class="o">=</span> <span class="n">array_conts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">array_cont0_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_cont0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">array_cont</span> <span class="ow">in</span> <span class="n">array_conts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_cont</span><span class="p">)</span> <span class="o">!=</span> <span class="n">array_cont0_len</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">min</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">a0</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">a0</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">array_cont</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">array_cont0</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">from_disk_as_hdf5</span><span class="p">(</span>
    <span class="n">h5_obj_or_filepath</span><span class="p">,</span> <span class="n">slice_obj</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">alphabetical_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ivyh</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load container object from disk, as an h5py file, at the specified hdf5</span>
<span class="sd">    filepath.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_obj_or_filepath</span>
<span class="sd">        Filepath where the container object is saved to disk, or h5 object.</span>
<span class="sd">    slice_obj</span>
<span class="sd">        slice object to slice all h5 elements. (Default value = slice(None))</span>
<span class="sd">    alphabetical_keys</span>
<span class="sd">        Whether to sort the container keys alphabetically, or preserve the dict</span>
<span class="sd">        order. Default is ``True``.</span>
<span class="sd">    ivyh</span>
<span class="sd">        Handle to ivy module to use for the calculations. Default is ``None``, which</span>
<span class="sd">        results in the global ivy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container loaded from disk</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_exists</span><span class="p">(</span>
        <span class="n">h5py</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;You must install python package h5py in order to load hdf5 </span><span class="se">\</span>
<span class="s2">        files from disk into a container.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">container_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">h5_obj</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h5_obj</span> <span class="o">=</span> <span class="n">h5_obj_or_filepath</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">h5_obj</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">alphabetical_keys</span> <span class="k">else</span> <span class="n">h5_obj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
            <span class="n">container_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">from_disk_as_hdf5</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">slice_obj</span><span class="p">,</span> <span class="n">ivyh</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">container_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">ivyh</span><span class="p">,</span> <span class="n">ivy</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">slice_obj</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
                <span class="s2">&quot;Item found inside h5_obj which was neither a Group nor a Dataset.&quot;</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">container_dict</span><span class="p">,</span> <span class="n">ivyh</span><span class="o">=</span><span class="n">ivyh</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">from_disk_as_pickled</span><span class="p">(</span><span class="n">pickle_filepath</span><span class="p">,</span> <span class="n">ivyh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load container object from disk at the specified pickle filepath.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pickle_filepath</span>
<span class="sd">        Filepath where the container object is saved to disk.</span>
<span class="sd">    ivyh</span>
<span class="sd">        Handle to ivy module to use for the calculations. Default is ``None``, which</span>
<span class="sd">        results in the global ivy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container loaded from disk</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">pickle_filepath</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)),</span>
        <span class="n">rebuild_child_containers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ivyh</span><span class="o">=</span><span class="n">ivyh</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">to_ivy</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">from_disk_as_json</span><span class="p">(</span><span class="n">json_filepath</span><span class="p">,</span> <span class="n">ivyh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load container object from disk at the specified json filepath. If some</span>
<span class="sd">    objects were not json-able during saving, then they will be loaded as strings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    json_filepath</span>
<span class="sd">        Filepath where the container object is saved to disk.</span>
<span class="sd">    ivyh</span>
<span class="sd">        Handle to ivy module to use for the calculations. Default is ``None``, which</span>
<span class="sd">        results in the global ivy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container loaded from disk</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_filepath</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_data_file</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_data_file</span><span class="p">),</span> <span class="n">ivyh</span><span class="o">=</span><span class="n">ivyh</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">h5_file_size</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get file size of h5 file contents.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_obj_or_filepath</span>
<span class="sd">        Filepath where the container object is saved to disk, or h5 object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Size of h5 file contents, and batch size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_exists</span><span class="p">(</span>
        <span class="n">h5py</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;You must install python package h5py in order to determine </span><span class="se">\</span>
<span class="s2">        the size of hdf5 files.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">h5_obj</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h5_obj</span> <span class="o">=</span> <span class="n">h5_obj_or_filepath</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">h5_obj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
            <span class="n">size_to_add</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">h5_file_size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">size_to_add</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">value_shape</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">value_shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="n">value_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
                <span class="s2">&quot;Item found inside h5_obj which was neither a Group nor a Dataset.&quot;</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">size</span><span class="p">,</span> <span class="n">batch_size</span>


<span class="k">def</span> <span class="nf">shuffle_h5_file</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">,</span> <span class="n">seed_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shuffle entries in all datasets of h5 file, such that they are still aligned</span>
<span class="sd">    along axis 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_obj_or_filepath</span>
<span class="sd">        Filepath where the container object is saved to disk, or h5 object.</span>
<span class="sd">    seed_value</span>
<span class="sd">        random seed to use for array shuffling (Default value = 0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_exists</span><span class="p">(</span>
        <span class="n">h5py</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;You must install python package h5py in order to shuffle </span><span class="se">\</span>
<span class="s2">        hdf5 files on disk.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">seed_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seed_value</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">h5_obj</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h5_obj</span> <span class="o">=</span> <span class="n">h5_obj_or_filepath</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">h5_obj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">shuffle_h5_file</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">seed_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed_value</span><span class="p">)</span>
            <span class="c1"># noinspection PyTypeChecker</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
                <span class="s2">&quot;Item found inside h5_obj which was neither a Group nor a Dataset.&quot;</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h5_obj</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">):</span>
        <span class="n">h5_obj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">containers</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reduce containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    containers</span>
<span class="sd">        containers to reduce</span>
<span class="sd">    reduction</span>
<span class="sd">        the reduction function</span>
<span class="sd">    config</span>
<span class="sd">        The configuration for the containers. Default is the same as container0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        reduced containers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">container0</span> <span class="o">=</span> <span class="n">containers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">container0</span><span class="o">.</span><span class="n">config</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container0</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">container0</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                <span class="p">[</span><span class="n">container</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">container</span> <span class="ow">in</span> <span class="n">containers</span><span class="p">],</span> <span class="n">reduction</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># noinspection PyBroadException</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reduction</span><span class="p">(</span><span class="n">containers</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Container reduce operation only valid for containers of arrays&quot;</span>
            <span class="p">)</span>


<span class="k">def</span> <span class="nf">flatten_key_chain</span><span class="p">(</span>
    <span class="n">key_chain</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="s2">&quot;__&quot;</span><span class="p">,</span> <span class="n">above_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">below_depth</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chain</span>
<span class="sd">        param replacement: (Default value = &#39;__&#39;)</span>
<span class="sd">    above_height</span>
<span class="sd">        Default value = None)</span>
<span class="sd">    below_depth</span>
<span class="sd">        Default value = None)</span>
<span class="sd">    replacement</span>
<span class="sd">         (Default value = &#39;__&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># noinspection RegExpSingleCharAlternation</span>
    <span class="n">flat_keys</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/|\.&quot;</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">)</span>  <span class="c1"></span>
    <span class="n">num_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_keys</span><span class="p">)</span>
    <span class="n">pre_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">post_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">above_height</span> <span class="ow">and</span> <span class="n">num_keys</span> <span class="o">&gt;</span> <span class="n">above_height</span><span class="p">:</span>
        <span class="n">post_keys</span> <span class="o">=</span> <span class="n">flat_keys</span><span class="p">[</span><span class="o">-</span><span class="n">above_height</span><span class="p">:]</span>
        <span class="k">del</span> <span class="n">flat_keys</span><span class="p">[</span><span class="o">-</span><span class="n">above_height</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">below_depth</span> <span class="ow">and</span> <span class="n">num_keys</span> <span class="o">&gt;</span> <span class="n">below_depth</span><span class="p">:</span>
        <span class="n">pre_keys</span> <span class="o">=</span> <span class="n">flat_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">below_depth</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">flat_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">below_depth</span><span class="p">]</span>
    <span class="k">return</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">k</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pre_keys</span><span class="p">),</span>
                <span class="n">replacement</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">flat_keys</span><span class="p">),</span>
                <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">post_keys</span><span class="p">),</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span>
        <span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">trim_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">max_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>
<span class="sd">    Returns a trimmed key with a maximum length of max_length.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key</span>
<span class="sd">        key to trim</span>
<span class="sd">    max_length</span>
<span class="sd">        maximum length of key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">max_length</span><span class="p">)</span> <span class="ow">or</span> <span class="n">key_len</span> <span class="o">&lt;=</span> <span class="n">max_length</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
            <span class="p">(</span><span class="n">key_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">max_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_length</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_call_static_method_with_flexible_args</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">static_method</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">kw</span><span class="p">,</span>
    <span class="n">required</span><span class="p">,</span>
    <span class="n">defaults</span><span class="p">,</span>
    <span class="n">self_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">defaults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">defaults</span> <span class="k">else</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">num_args</span>
        <span class="p">}</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self_idx</span> <span class="o">&gt;</span> <span class="n">num_args</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">self_idx</span> <span class="o">-</span> <span class="n">num_args</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">self_idx</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">static_method</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kw</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">self_set</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># set to leftmost non-specified required arg, if present</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">required</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">self_set</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>
    <span class="c1"># go through each key and value of the keyword arguments</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self_set</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
                    <span class="c1"># if self is set and a default value exists, set it</span>
                    <span class="n">kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># otherwise set self to this argument</span>
                <span class="n">kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">self_set</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># call the static method</span>
    <span class="k">return</span> <span class="n">static_method</span><span class="p">(</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue_load_sizes_cum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sub_shapes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">is_native_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">v</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sub_shapes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sub_shapes</span>
    <span class="n">min_num_dims</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub_shape</span> <span class="ow">in</span> <span class="n">sub_shapes</span><span class="p">])</span>
    <span class="n">sub_shapes_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="p">[</span><span class="n">sub_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_num_dims</span><span class="p">]</span> <span class="k">for</span> <span class="n">sub_shape</span> <span class="ow">in</span> <span class="n">sub_shapes</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">sub_shapes_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sub_shapes_array</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sub_shapes_array</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sub_shapes_array</span> <span class="o">/</span> <span class="n">sub_shapes_array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="c1"># noinspection PyTypeChecker</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="kc">None</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">mask</span><span class="p">,</span> <span class="n">sub_shapes_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">min_num_dims</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_dev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_native</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">sub_devs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">dev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_native</span><span class="o">=</span><span class="n">as_native</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">is_native_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">v</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sub_devs</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sub_devs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_at_key_chains_input_as_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">return_cont</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="nb">dict</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">kc</span> <span class="ow">in</span> <span class="n">key_chains</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">at_key_chain</span><span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="n">ignore_key_errors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ignore_key_errors</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">return_cont</span><span class="o">.</span><span class="n">set_at_key_chain</span><span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">return_cont</span>


<span class="k">def</span> <span class="nf">_at_key_chains_input_as_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">,</span> <span class="n">current_chain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">key_chains</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">current_chain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">new_current_chain</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_current_chain</span> <span class="o">=</span> <span class="n">current_chain</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">k</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_key_chains_input_as_dict</span><span class="p">(</span>
                <span class="n">v</span><span class="p">,</span> <span class="n">new_current_chain</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="n">ignore_key_errors</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">at_key_chain</span><span class="p">(</span>
                <span class="n">new_current_chain</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="n">ignore_key_errors</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ignore_key_errors</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prune_key_chains_input_as_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">):</span>
    <span class="n">return_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">kc</span> <span class="ow">in</span> <span class="n">key_chains</span><span class="p">:</span>
        <span class="n">return_cont</span> <span class="o">=</span> <span class="n">return_cont</span><span class="o">.</span><span class="n">prune_key_chain</span><span class="p">(</span><span class="n">kc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">return_cont</span>


<span class="k">def</span> <span class="nf">_prune_key_chains_input_as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">,</span> <span class="n">return_cont</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">return_cont</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">return_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">key_chains</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">ret_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prune_key_chains_input_as_dict</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">return_cont</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_cont</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">return_cont</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">return_cont</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">return_cont</span>


<span class="k">def</span> <span class="nf">duplicate_array_keychains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">duplciates</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">key_chains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_key_chains</span><span class="p">()</span>
    <span class="n">skips</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key_chains</span><span class="p">)):</span>
        <span class="n">temp_duplicates</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">key_chains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">skips</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_chains</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">key_chains</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">skips</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">key_chains</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">[</span><span class="n">key_chains</span><span class="p">[</span><span class="n">j</span><span class="p">]]:</span>
                <span class="k">if</span> <span class="n">key_chains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">temp_duplicates</span><span class="p">:</span>
                    <span class="n">temp_duplicates</span> <span class="o">+=</span> <span class="p">(</span><span class="n">key_chains</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span>
                <span class="k">if</span> <span class="n">key_chains</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">temp_duplicates</span><span class="p">:</span>
                    <span class="n">temp_duplicates</span> <span class="o">+=</span> <span class="p">(</span><span class="n">key_chains</span><span class="p">[</span><span class="n">j</span><span class="p">],)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_duplicates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">duplciates</span> <span class="o">+=</span> <span class="p">(</span><span class="n">temp_duplicates</span><span class="p">,)</span>
        <span class="n">skips</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">duplciates</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">duplciates</span>


<span class="k">def</span> <span class="nf">update_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="p">):</span>
    <span class="n">new_config</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">att_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">k</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config_in</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;types_to_iteratively_nest&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="p">(),</span> <span class="n">catch_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;keyword_color_dict&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;ivyh&quot;</span><span class="p">:</span>
                <span class="n">att_name</span> <span class="o">=</span> <span class="s2">&quot;_local_ivy&quot;</span>
            <span class="n">new_config</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">att_name</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">new_config</span>


<span class="k">def</span> <span class="nf">cont_inplace_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">dict_in</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="o">**</span><span class="n">config</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Update the contents of this container inplace, using either a new dict or</span>
<span class="sd">    container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dict_in</span>
<span class="sd">        New dict or container to update the current container inplace with.</span>
<span class="sd">    **config</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># update config</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_config</span><span class="p">(</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
    <span class="c1"># update container values inplace</span>
    <span class="k">if</span> <span class="n">dict_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">dict_types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">dict</span><span class="p">]</span> <span class="o">+</span> <span class="n">ivy</span><span class="o">.</span><span class="n">container_types</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_in</span><span class="p">,</span> <span class="n">dict_types</span><span class="p">):</span>
        <span class="n">dict_in</span> <span class="o">=</span> <span class="n">dict_in</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_in</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_to_iteratively_nest</span><span class="p">)):</span>
        <span class="n">dict_in</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;it_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dict_in</span><span class="p">)))))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dict_in</span><span class="p">))</span>
                <span class="p">],</span>
                <span class="n">dict_in</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span><span class="s2">&quot;invalid input </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dict_in</span><span class="p">))</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dict_in</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alphabetical_keys</span> <span class="k">else</span> <span class="n">dict_in</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dict_types</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebuild_child_containers</span>
            <span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_to_iteratively_nest</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">cont_inplace_update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">all_true</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">assert_is_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether all the entries in the container boolean evaluate to True.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    assert_is_bool</span>
<span class="sd">        Whether or not to assert each entry is of type Boolean.</span>
<span class="sd">        (Default value = False)</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Boolean, whether all entries are boolean True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_bools</span><span class="p">(</span>
                    <span class="n">assert_is_bool</span><span class="p">,</span>
                    <span class="n">key_chains</span><span class="p">,</span>
                    <span class="n">to_apply</span><span class="p">,</span>
                    <span class="n">prune_unapplied</span><span class="p">,</span>
                    <span class="n">map_sequences</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">all_false</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">assert_is_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether all the entries in the container boolean evaluate to False.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    assert_is_bool</span>
<span class="sd">        Whether or not to assert each entry is of type Boolean.</span>
<span class="sd">        (Default value = False)</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Boolean, whether all entries are boolean False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_bools</span><span class="p">(</span>
                    <span class="n">assert_is_bool</span><span class="p">,</span>
                    <span class="n">key_chains</span><span class="p">,</span>
                    <span class="n">to_apply</span><span class="p">,</span>
                    <span class="n">prune_unapplied</span><span class="p">,</span>
                    <span class="n">map_sequences</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">slice_via_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get slice of container, based on key.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    slice_key</span>
<span class="sd">        key to slice container at.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object sliced at desired key.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">slice_key</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">slice_via_key</span><span class="p">(</span><span class="n">slice_key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">as_bools</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">assert_is_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return boolean evaluation for all nested items in the container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    assert_is_bool</span>
<span class="sd">        Whether or not to assert the entry is of type Boolean.</span>
<span class="sd">        (Default value = False)</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object with all entries boolean evaluated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_ret_bool</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">assert_is_bool</span><span class="p">:</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">_ret_bool</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">unstack_conts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dim_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unstack containers along specified dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    axis</span>
<span class="sd">        Dimensions along which to unstack.</span>
<span class="sd">    keepdims</span>
<span class="sd">        Whether to keep dimension 1 in the unstack dimensions. Default is ``False``.</span>
<span class="sd">    dim_size</span>
<span class="sd">        Size of the dimension to unstack. Determined from inputs by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        List of containers, unstacked along the specified dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dim_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dim_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="p">[</span>
                <span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">else</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="c1"># noinspection PyTypeChecker</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">])]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">split_conts</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">num_or_size_splits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">with_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Splits a container into multiple sub-containers, by splitting their</span>
<span class="sd">    constituent arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_or_size_splits</span>
<span class="sd">        Number of equal arrays to divide the array into along the given axis if an</span>
<span class="sd">        integer. The size of each split element if a sequence of integers. Default</span>
<span class="sd">        is to divide into as many 1-dimensional arrays as the axis dimension.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to split, default is ``0``.</span>
<span class="sd">    with_remainder</span>
<span class="sd">        If the tensor does not split evenly, then store the last remainder entry.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        A list of sub-arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim_size</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">num_or_size_splits</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_or_size_splits</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_or_size_splits</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># noinspection PyTypeChecker</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">num_or_size_splits</span><span class="o">=</span><span class="n">num_or_size_splits</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">with_remainder</span><span class="o">=</span><span class="n">with_remainder</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">is_native_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">unstack_conts</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim_size</span><span class="o">=</span><span class="n">dim_size</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">num_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the number of arrays present at the leaf nodes, including variables</span>
<span class="sd">    by default.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array,</span>
<span class="sd">        rather than a variable or traced array. (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_iterator_values</span><span class="p">()</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">size_ordered_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a container with keychains mapped to flat keys, and arrays given in</span>
<span class="sd">    order of smallest to largest.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array,</span>
<span class="sd">        rather than a variable or traced array. (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">flatten_key_chain</span><span class="p">(</span><span class="n">kc</span><span class="p">):</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">kc</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">array_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="n">alphabetical_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">to_disk_as_hdf5</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">h5_obj_or_filepath</span><span class="p">,</span> <span class="n">starting_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">max_batch_size</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Save container object to disk, as an h5py file, at the specified filepath.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_obj_or_filepath</span>
<span class="sd">        Filepath for where to save the container to disk, or h5 object.</span>
<span class="sd">    starting_index</span>
<span class="sd">        Batch index for which to start writing to file, if it already exists</span>
<span class="sd">        (Default value = 0)</span>
<span class="sd">    mode</span>
<span class="sd">        H5 read/write mode for writing to disk, [&#39;r&#39;, &#39;r+&#39;, &#39;w&#39;, &#39;w-&#39;, &#39;a&#39;],</span>
<span class="sd">        default is &#39;a&#39;.</span>
<span class="sd">    max_batch_size</span>
<span class="sd">        Maximum batch size for the container on disk, this is useful if later</span>
<span class="sd">        appending to file. (Default value = None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_exists</span><span class="p">(</span>
        <span class="n">h5py</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;You must install python package h5py in order to save </span><span class="se">\</span>
<span class="s2">        containers to disk as hdf5 files.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">h5_obj</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_obj_or_filepath</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h5_obj</span> <span class="o">=</span> <span class="n">h5_obj_or_filepath</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">h5_obj</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">h5_group</span> <span class="o">=</span> <span class="n">h5_obj</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h5_group</span> <span class="o">=</span> <span class="n">h5_obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">value</span><span class="o">.</span><span class="n">to_disk_as_hdf5</span><span class="p">(</span><span class="n">h5_group</span><span class="p">,</span> <span class="n">starting_index</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">max_batch_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_as_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">value_shape</span> <span class="o">=</span> <span class="n">value_as_np</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">this_batch_size</span> <span class="o">=</span> <span class="n">value_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">max_batch_size</span><span class="p">:</span>
                <span class="n">max_batch_size</span> <span class="o">=</span> <span class="n">starting_index</span> <span class="o">+</span> <span class="n">this_batch_size</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">h5_obj</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">dataset_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_batch_size</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">value_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">maxshape</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dataset_shape</span><span class="p">]</span>
                <span class="n">h5_obj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                    <span class="n">key</span><span class="p">,</span> <span class="n">dataset_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">value_as_np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">maxshape</span><span class="o">=</span><span class="n">maxshape</span>
                <span class="p">)</span>
            <span class="n">space_left</span> <span class="o">=</span> <span class="n">max_batch_size</span> <span class="o">-</span> <span class="n">starting_index</span>
            <span class="n">amount_to_write</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">this_batch_size</span><span class="p">,</span> <span class="n">space_left</span><span class="p">)</span>
            <span class="n">h5_obj</span><span class="p">[</span><span class="n">key</span><span class="p">][</span>
                <span class="n">starting_index</span> <span class="p">:</span> <span class="n">starting_index</span> <span class="o">+</span> <span class="n">amount_to_write</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">value_as_np</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">amount_to_write</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">to_disk_as_pickled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickle_filepath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Save container object to disk, as an pickled file, at the specified filepath.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pickle_filepath</span>
<span class="sd">        Filepath for where to save the container to disk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_native</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="nb">open</span><span class="p">(</span><span class="n">pickle_filepath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">to_jsonable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    return_dict</span>
<span class="sd">        Default value = None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">return_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">return_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_jsonable</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_jsonable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">return_dict</span>


<span class="k">def</span> <span class="nf">to_disk_as_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_filepath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Save container object to disk, as an json file, at the specified filepath.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    json_filepath</span>
<span class="sd">        Filepath for where to save the container to disk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_filepath</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_data_file</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_jsonable</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">json_data_file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_nested_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">return_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">to_nested_list</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;_f&quot;</span><span class="p">:</span>
            <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">return_list</span>


<span class="k">def</span> <span class="nf">to_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructor to their original form.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">         Container data in its raw form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_item</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">return_item</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_raw</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;it_&quot;</span> <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_types_to_iteratively_nest</span><span class="p">):</span>
            <span class="n">return_item</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">to_raw</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_item</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">return_item</span>


<span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ret Container as nested dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">return_dict</span>


<span class="k">def</span> <span class="nf">to_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">leaf_keys_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chain</span>
<span class="sd">        Default value = &#39;&#39;)</span>
<span class="sd">    leaf_keys_only</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    include_empty</span>
<span class="sd">        Default value = False)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Iterator for the container elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">leaf_keys_only</span><span class="p">:</span>
            <span class="n">kc</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kc</span> <span class="o">=</span> <span class="n">key_chain</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">key</span> <span class="k">if</span> <span class="n">key_chain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">include_empty</span> <span class="ow">or</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="n">value</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="n">leaf_keys_only</span><span class="p">,</span> <span class="n">include_empty</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">kc</span><span class="p">,</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">to_iterator_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    include_empty</span>
<span class="sd">        Default value = False)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Iterator for the container values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">include_empty</span> <span class="ow">or</span> <span class="n">value</span><span class="p">):</span>
            <span class="c1"># noinspection PyCompatibility</span>
            <span class="k">yield from</span> <span class="n">value</span><span class="o">.</span><span class="n">to_iterator_values</span><span class="p">(</span><span class="n">include_empty</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">to_iterator_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">leaf_keys_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chain</span>
<span class="sd">        Default value = &#39;&#39;)</span>
<span class="sd">    leaf_keys_only</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    include_empty</span>
<span class="sd">        Default value = False)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Iterator for the container elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">leaf_keys_only</span><span class="p">:</span>
            <span class="n">kc</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kc</span> <span class="o">=</span> <span class="n">key_chain</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">key</span> <span class="k">if</span> <span class="n">key_chain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">include_empty</span> <span class="ow">or</span> <span class="n">value</span><span class="p">):</span>
            <span class="c1"># noinspection PyCompatibility</span>
            <span class="k">yield from</span> <span class="n">value</span><span class="o">.</span><span class="n">to_iterator_keys</span><span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="n">leaf_keys_only</span><span class="p">,</span> <span class="n">include_empty</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">kc</span>


<span class="k">def</span> <span class="nf">to_flat_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container as flat list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">([</span><span class="n">item</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">()])</span>


<span class="k">def</span> <span class="nf">from_flat_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flat_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return new container object with the same hierarchy, but with values replaced</span>
<span class="sd">    from flat list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flat_list</span>
<span class="sd">        flat list of values to populate container with.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">from_flat_list</span><span class="p">(</span><span class="n">flat_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">flat_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">new_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">has_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether container object has specified key somewhere in the nested</span>
<span class="sd">    structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    query_key</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">has_key</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">map_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x</span>
<span class="sd">            param kc:</span>
<span class="sd">        kc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">nonlocal</span> <span class="n">has_key</span>
        <span class="k">if</span> <span class="n">query_key</span> <span class="ow">in</span> <span class="n">kc</span><span class="p">:</span>
            <span class="n">has_key</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">map_fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">has_key</span>


<span class="k">def</span> <span class="nf">has_key_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether container object has specified key-chain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chain</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[/.]&quot;</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">find_sub_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_cont_to_find</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the sub-container in the current container if it exsits.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_cont_to_find</span>
<span class="sd">        The sub-container to find.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key_chain_found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">_check_sub_cont</span><span class="p">(</span><span class="n">sub_cont</span><span class="p">,</span> <span class="n">kc</span><span class="p">):</span>
        <span class="n">sub_cont_key_chains</span> <span class="o">=</span> <span class="n">sub_cont_to_find</span><span class="o">.</span><span class="n">all_key_chains</span><span class="p">()</span>
        <span class="n">kcs_in_sub_cont</span> <span class="o">=</span> <span class="p">[</span><span class="n">kc</span> <span class="ow">in</span> <span class="n">sub_cont</span> <span class="k">for</span> <span class="n">kc</span> <span class="ow">in</span> <span class="n">sub_cont_key_chains</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">kcs_in_sub_cont</span>
            <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">kcs_in_sub_cont</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span>
                <span class="p">[</span><span class="n">sub_cont</span><span class="p">,</span> <span class="n">sub_cont_to_find</span><span class="p">],</span> <span class="n">partial</span><span class="o">=</span><span class="n">partial</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">key_chain_found</span>
            <span class="n">key_chain_found</span> <span class="o">=</span> <span class="n">kc</span>
        <span class="k">return</span> <span class="n">sub_cont</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_check_sub_cont</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">key_chain_found</span>


<span class="k">def</span> <span class="nf">contains_sub_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_cont</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether the current container contains the sub-container, with</span>
<span class="sd">    matching structure and array values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_cont</span>
<span class="sd">        The sub-container to check.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_sub_container</span><span class="p">(</span><span class="n">sub_cont</span><span class="p">,</span> <span class="n">partial</span><span class="p">),</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span> <span class="kc">False</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">assert_contains_sub_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_cont</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Asserts that the current container contains the sub-container, otherwise</span>
<span class="sd">    exception raised with the diff printed to screen.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_cont</span>
<span class="sd">        The sub-container to check.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contains_sub_container</span><span class="p">(</span><span class="n">sub_cont</span><span class="p">,</span> <span class="n">partial</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">:</span>
        <span class="n">key_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_sub_structure</span><span class="p">(</span>
            <span class="n">sub_cont</span><span class="p">,</span> <span class="n">check_shapes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key_chain</span><span class="p">:</span>
            <span class="n">key_chain</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
            <span class="s2">&quot;Containers did not have identical structure and values:</span><span class="se">\n\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key_chain</span><span class="p">],</span> <span class="n">sub_cont</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">find_sub_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_struc_to_find</span><span class="p">,</span> <span class="n">check_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the sub-container structure in the current container if it exsits.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_struc_to_find</span>
<span class="sd">        The sub-container to find.</span>
<span class="sd">    check_shapes</span>
<span class="sd">        Whether to check array shapes in the sub-structure. Default is ``True``.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key_chain_found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">_check_sub_cont</span><span class="p">(</span><span class="n">sub_cont</span><span class="p">,</span> <span class="n">kc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sub_cont</span>
<span class="sd">            param kc:</span>
<span class="sd">        kc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_struc_key_chains</span> <span class="o">=</span> <span class="n">sub_struc_to_find</span><span class="o">.</span><span class="n">all_key_chains</span><span class="p">()</span>
        <span class="n">kcs_in_sub_cont</span> <span class="o">=</span> <span class="p">[</span><span class="n">kc</span> <span class="ow">in</span> <span class="n">sub_cont</span> <span class="k">for</span> <span class="n">kc</span> <span class="ow">in</span> <span class="n">sub_struc_key_chains</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">kcs_in_sub_cont</span>
            <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">kcs_in_sub_cont</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">identical_structure</span><span class="p">(</span>
                <span class="p">[</span><span class="n">sub_cont</span><span class="p">,</span> <span class="n">sub_struc_to_find</span><span class="p">],</span>
                <span class="n">check_shapes</span><span class="o">=</span><span class="n">check_shapes</span><span class="p">,</span>
                <span class="n">partial</span><span class="o">=</span><span class="n">partial</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">key_chain_found</span>
            <span class="n">key_chain_found</span> <span class="o">=</span> <span class="n">kc</span>
        <span class="k">return</span> <span class="n">sub_cont</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_check_sub_cont</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">key_chain_found</span>


<span class="k">def</span> <span class="nf">contains_sub_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_cont</span><span class="p">,</span> <span class="n">check_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether the current container contains the sub-container structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_cont</span>
<span class="sd">        The sub-container to check.</span>
<span class="sd">    check_shapes</span>
<span class="sd">        Whether to check array shapes in the sub-structure. Default is ``True``.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_sub_structure</span><span class="p">(</span><span class="n">sub_cont</span><span class="p">,</span> <span class="n">check_shapes</span><span class="p">,</span> <span class="n">partial</span><span class="p">),</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span> <span class="kc">False</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">assert_contains_sub_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_cont</span><span class="p">,</span> <span class="n">check_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Asserts that the current container contains the sub-container structure,</span>
<span class="sd">    otherwise exception raised with the diff printed to screen.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_cont</span>
<span class="sd">        The sub-container to check.</span>
<span class="sd">    check_shapes</span>
<span class="sd">        Whether to check array shapes in the sub-structure. Default is ``True``.</span>
<span class="sd">    partial</span>
<span class="sd">        Whether to also check for partially complete sub-containers.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_true</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contains_sub_structure</span><span class="p">(</span><span class="n">sub_cont</span><span class="p">,</span> <span class="n">check_shapes</span><span class="p">,</span> <span class="n">partial</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">:</span>
        <span class="n">key_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_sub_structure</span><span class="p">(</span>
            <span class="n">sub_cont</span><span class="p">,</span> <span class="n">check_shapes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key_chain</span><span class="p">:</span>
            <span class="n">key_chain</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
            <span class="s2">&quot;Containers did not have identical structure:</span><span class="se">\n\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">structural_diff</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">key_chain</span><span class="p">],</span>
                    <span class="n">sub_cont</span><span class="p">,</span>
                    <span class="n">detect_key_diffs</span><span class="o">=</span><span class="ow">not</span> <span class="n">partial</span><span class="p">,</span>
                    <span class="n">detect_shape_diffs</span><span class="o">=</span><span class="n">check_shapes</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;diff_only&quot;</span> <span class="k">if</span> <span class="n">partial</span> <span class="k">else</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">at_keys</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="n">ignore_none</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">containing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Query container object at specified keys, either as list or nested dict.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    queries</span>
<span class="sd">        The keys to query.</span>
<span class="sd">    ignore_none</span>
<span class="sd">        Whether to ignore None input. Default is ``True``.</span>
<span class="sd">    containing</span>
<span class="sd">        Whether to include keys which only contain the query substrings.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    ignore_key_errors</span>
<span class="sd">        Whether to ignore Key-errors when trying to access the dict.</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        sub-container containing only key-chains containing the specified keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">queries</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ignore_none</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">key_chains_to_keep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">queries</span> <span class="o">=</span> <span class="p">[</span><span class="n">queries</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">map_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">key_chains_to_keep</span>
        <span class="n">kc_split</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[/.]&quot;</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">query_key</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query_key</span> <span class="ow">in</span> <span class="n">kc_split</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">containing</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">([</span><span class="n">query_key</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kc_split</span><span class="p">])</span>
            <span class="p">):</span>
                <span class="n">key_chains_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">map_fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">at_key_chains</span><span class="p">(</span>
        <span class="n">key_chains_to_keep</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="n">ignore_key_errors</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">at_key_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Query container object at a specified key-chain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chain</span>
<span class="sd">        param ignore_key_errors: (Default value = False)</span>
<span class="sd">    ignore_key_errors</span>
<span class="sd">         (Default value = False)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        sub-container or value at specified key chain</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[/.]&quot;</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ignore_key_errors</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">at_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">,</span> <span class="n">ignore_none</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Query container object at specified key-chains, either as list or nested</span>
<span class="sd">    dict.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chains</span>
<span class="sd">        param ignore_none: (Default value = True)</span>
<span class="sd">    ignore_key_errors</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    ignore_none</span>
<span class="sd">         (Default value = True)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    type</span>
<span class="sd">        sub-container containing only the specified key chains</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key_chains</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ignore_none</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_chains</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_key_chains_input_as_seq</span><span class="p">(</span>
            <span class="n">key_chains</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="n">ignore_key_errors</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_chains</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_key_chains_input_as_dict</span><span class="p">(</span>
            <span class="n">key_chains</span><span class="p">,</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="n">ignore_key_errors</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_chains</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_key_chains_input_as_seq</span><span class="p">(</span>
            <span class="p">[</span><span class="n">key_chains</span><span class="p">],</span> <span class="n">ignore_key_errors</span><span class="o">=</span><span class="n">ignore_key_errors</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
            <span class="s2">&quot;Invalid type for input key_chains, must either be a list, tuple, dict&quot;</span>
            <span class="s2">&quot; or ivy.Container, but found type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key_chains</span><span class="p">))</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">all_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    include_empty</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">kc</span> <span class="k">for</span> <span class="n">kc</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">(</span><span class="n">include_empty</span><span class="o">=</span><span class="n">include_empty</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">key_chains_containing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_str</span><span class="p">,</span> <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_str</span>
<span class="sd">        param include_empty: (Default value = False)</span>
<span class="sd">    include_empty</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">kc</span>
        <span class="k">for</span> <span class="n">kc</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">(</span><span class="n">include_empty</span><span class="o">=</span><span class="n">include_empty</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub_str</span> <span class="ow">in</span> <span class="n">kc</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">set_at_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set values of container object at specified keys.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_dict</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    type</span>
<span class="sd">        new container with updated value at each key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">target_dict</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">set_at_keys</span><span class="p">(</span><span class="n">target_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">set_at_key_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set value of container object at a specified key-chain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chain</span>
<span class="sd">        param val:</span>
<span class="sd">    inplace</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    val</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        new container with updated value at key chain</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[/.]&quot;</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sub_cont</span> <span class="o">=</span> <span class="n">cont</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sub_cont</span><span class="p">:</span>
            <span class="n">sub_cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
        <span class="n">sub_cont</span> <span class="o">=</span> <span class="n">sub_cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">sub_cont</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">cont</span>


<span class="k">def</span> <span class="nf">overwrite_at_key_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Overwrite value of container object at a specified key-chain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chain</span>
<span class="sd">        param val:</span>
<span class="sd">    inplace</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    val</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        new container with updated value at key chain, provided it existed before.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[/.]&quot;</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sub_cont</span> <span class="o">=</span> <span class="n">cont</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_elem_in_list</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="n">sub_cont</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="s2">&quot;key chain must already exist in container in order to </span><span class="se">\</span>
<span class="s2">            call overwrite_at_key_chain&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sub_cont</span> <span class="o">=</span> <span class="n">sub_cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_elem_in_list</span><span class="p">(</span>
        <span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">sub_cont</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;key chain must already exist in container in order to </span><span class="se">\</span>
<span class="s2">        call overwrite_at_key_chain&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">sub_cont</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">cont</span>


<span class="k">def</span> <span class="nf">set_at_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">,</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set values of container object at specified key-chains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_dict</span>
<span class="sd">        param return_dict: (Default value = None)</span>
<span class="sd">    inplace</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    return_dict</span>
<span class="sd">         (Default value = None)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        new container with updated values at the key chains</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">return_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">return_dict</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">target_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_at_key_chains</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">inplace</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">overwrite_at_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">,</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Overwrite values of container object at specified key-chains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_dict</span>
<span class="sd">        param return_dict: (Default value = None)</span>
<span class="sd">    inplace</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    return_dict</span>
<span class="sd">         (Default value = None)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        new container with updated values at the key chains, provided they</span>
<span class="sd">        existed before.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">return_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">return_dict</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">target_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_elem_in_list</span><span class="p">(</span>
            <span class="n">k</span><span class="p">,</span>
            <span class="n">return_dict</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="s2">&quot;key chain must already exist in container in order to </span><span class="se">\</span>
<span class="s2">            call overwrite_at_key_chain&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overwrite_at_key_chains</span><span class="p">(</span>
                <span class="n">v</span><span class="p">,</span> <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">inplace</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">prune_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_keys</span><span class="p">,</span> <span class="n">ignore_none</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursively prune set of keys.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    query_keys</span>
<span class="sd">        param ignore_none: (Default value = True)</span>
<span class="sd">    ignore_none</span>
<span class="sd">         (Default value = True)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with key-chains containing the specified keys pruned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">query_keys</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ignore_none</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">key_chains_to_prune</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">query_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">query_keys</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">map_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x</span>
<span class="sd">            param kc:</span>
<span class="sd">        kc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">nonlocal</span> <span class="n">key_chains_to_prune</span>
        <span class="k">for</span> <span class="n">query_key</span> <span class="ow">in</span> <span class="n">query_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query_key</span> <span class="ow">in</span> <span class="n">kc</span><span class="p">:</span>
                <span class="n">key_chains_to_prune</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">map_fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_key_chains</span><span class="p">(</span><span class="n">key_chains_to_prune</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">prune_key_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursively prune chain of keys, specified as &#39;key1/key2/key3/...&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chain</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with keys in key chain pruned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys_in_chain</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[/.]&quot;</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">)</span>
    <span class="n">out_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">keys_in_chain</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys_in_chain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_val</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_val</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">prune_key_chain</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">keys_in_chain</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_val</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys_in_chain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">keys_in_chain</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">out_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">prune_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">,</span> <span class="n">ignore_none</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursively prune set of key chains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_chains</span>
<span class="sd">        param ignore_none: (Default value = True)</span>
<span class="sd">    ignore_none</span>
<span class="sd">         (Default value = True)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with keys in the set of key chains pruned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key_chains</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ignore_none</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_chains</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prune_key_chains_input_as_seq</span><span class="p">(</span><span class="n">key_chains</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_chains</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prune_key_chains_input_as_dict</span><span class="p">(</span><span class="n">key_chains</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_chains</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prune_key_chains_input_as_seq</span><span class="p">([</span><span class="n">key_chains</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
            <span class="s2">&quot;Invalid type for input key_chains, must either be a list, tuple, dict &quot;</span>
            <span class="s2">&quot;or ivy.Container, but found type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key_chains</span><span class="p">))</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">format_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_fn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Format all key-chains, using the formatting function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    format_fn</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with the same key-chain structure, but the key strings formatted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">({</span><span class="n">format_fn</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">()})</span>


<span class="k">def</span> <span class="nf">sort_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">new_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">v_back</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">sort_by_key</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v_back</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">new_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_back</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">new_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">prune_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_nones</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursively prunes empty keys from the container dict structure. Returns None</span>
<span class="sd">    if the entire container is empty.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keep_nones</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    base</span>
<span class="sd">        Default value = True)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with empty keys pruned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">prune_empty</span><span class="p">(</span><span class="n">keep_nones</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_value</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">keep_nones</span><span class="p">:</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">out_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
    <span class="k">return</span>


<span class="k">def</span> <span class="nf">prune_key_from_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">containing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursively prune absolute key or key containing a certain substring from all</span>
<span class="sd">    key chains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    absolute</span>
<span class="sd">        The absolute key to detect in the key chains. (Default value = None)</span>
<span class="sd">    containing</span>
<span class="sd">        A substring to check each key for, when deciding which keys to prune.</span>
<span class="sd">        (Default value = None)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container with specified key or substring-containing-key from all key chains</span>
<span class="sd">        removed from the chain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_all_or_any_fn</span><span class="p">(</span>
        <span class="n">absolute</span><span class="p">,</span>
        <span class="n">containing</span><span class="p">,</span>
        <span class="n">fn</span><span class="o">=</span><span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;at least one of absolute or containing must be specified&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">out_cont</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">absolute</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">==</span> <span class="n">absolute</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">containing</span> <span class="ow">and</span> <span class="n">containing</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                <span class="n">out_cont</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">out_cont</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_cont</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">out_cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">prune_key_from_key_chains</span><span class="p">(</span><span class="n">absolute</span><span class="p">,</span> <span class="n">containing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">out_cont</span>


<span class="k">def</span> <span class="nf">prune_keys_from_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">containing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursively prune absolute keys or keys containing certain substrings from</span>
<span class="sd">    all key chains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    absolute</span>
<span class="sd">        The absolute key to detect in the key chains. (Default value = None)</span>
<span class="sd">    containing</span>
<span class="sd">        A substring to check each key for, when deciding which keys to prune.</span>
<span class="sd">        (Default value = None)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container with specified keys or substring-containing-keys from all</span>
<span class="sd">        key chains removed from the chain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_all_or_any_fn</span><span class="p">(</span>
        <span class="n">absolute</span><span class="p">,</span>
        <span class="n">containing</span><span class="p">,</span>
        <span class="n">fn</span><span class="o">=</span><span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;at least one of absolute or containing must be specified&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">out_cont</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">absolute</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">absolute</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">containing</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">([</span><span class="n">con</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">containing</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                <span class="n">out_cont</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">out_cont</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_cont</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">out_cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">prune_key_from_key_chains</span><span class="p">(</span><span class="n">absolute</span><span class="p">,</span> <span class="n">containing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_cont</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">out_cont</span>


<span class="k">def</span> <span class="nf">restructure_key_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keychain_mapping</span><span class="p">,</span> <span class="n">keep_orig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a new container with the same contents, but a new key-chain structure.</span>
<span class="sd">    Given by the mapping with keys as old key-chains and values as new key-chains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keychain_mapping</span>
<span class="sd">        A dict with keys as old key-chains and values as new key-chains.</span>
<span class="sd">    keep_orig</span>
<span class="sd">        Whether to keep the original keys, or start from a new empty container.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    replace</span>
<span class="sd">        Whether to replace the old key-chains by the new ones. Default is ``True``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">keep_orig</span> <span class="k">else</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">old_kc</span><span class="p">,</span> <span class="n">new_kc</span> <span class="ow">in</span> <span class="n">keychain_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">replace</span> <span class="ow">and</span> <span class="n">old_kc</span> <span class="ow">in</span> <span class="n">new_cont</span><span class="p">:</span>
            <span class="n">new_cont</span> <span class="o">=</span> <span class="n">new_cont</span><span class="o">.</span><span class="n">prune_key_chain</span><span class="p">(</span><span class="n">old_kc</span><span class="p">)</span>
        <span class="n">new_cont</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span>
            <span class="n">new_cont</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">({</span><span class="n">new_kc</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">old_kc</span><span class="p">]})</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">new_cont</span>


<span class="k">def</span> <span class="nf">restructure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">keep_orig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a new container with the same contents, but a new key-chain structure,</span>
<span class="sd">    and transposes and/or reshaped arrays. Given by the mapping with keys as old</span>
<span class="sd">    key-chains and values as new key-chains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mapping</span>
<span class="sd">        A dict with keys as old key-chains and values as new key-chains.</span>
<span class="sd">    keep_orig</span>
<span class="sd">        Whether to keep the original keys, are start from a new container.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    replace</span>
<span class="sd">        Whether to replace the old key-chains by the new ones. Default is ``True``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">keep_orig</span> <span class="k">else</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">old_kc</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">replace</span> <span class="ow">and</span> <span class="n">old_kc</span> <span class="ow">in</span> <span class="n">new_cont</span><span class="p">:</span>
            <span class="n">new_cont</span> <span class="o">=</span> <span class="n">new_cont</span><span class="o">.</span><span class="n">prune_key_chain</span><span class="p">(</span><span class="n">old_kc</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">old_kc</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">new_kc</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;key_chain&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;pattern&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;pattern&quot;</span><span class="p">]</span>
                <span class="n">axes_lengths</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;axes_lengths&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;axes_lengths&quot;</span> <span class="ow">in</span> <span class="n">new</span> <span class="k">else</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">einops_rearrange</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="o">**</span><span class="n">axes_lengths</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">einops_rearrange</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="o">**</span><span class="n">axes_lengths</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_kc</span> <span class="o">=</span> <span class="n">new</span>
        <span class="n">new_cont</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">new_cont</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">({</span><span class="n">new_kc</span><span class="p">:</span> <span class="n">val</span><span class="p">}))</span>
    <span class="k">return</span> <span class="n">new_cont</span>


<span class="k">def</span> <span class="nf">flatten_key_chains</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">above_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">below_depth</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    include_empty</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    above_height</span>
<span class="sd">        Default value = None)</span>
<span class="sd">    below_depth</span>
<span class="sd">        Default value = None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">flatten_key_chain</span><span class="p">(</span>
                <span class="n">kc</span><span class="p">,</span> <span class="n">above_height</span><span class="o">=</span><span class="n">above_height</span><span class="p">,</span> <span class="n">below_depth</span><span class="o">=</span><span class="n">below_depth</span>
            <span class="p">):</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">kc</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_iterator</span><span class="p">(</span><span class="n">include_empty</span><span class="o">=</span><span class="n">include_empty</span><span class="p">)</span>
        <span class="p">},</span>
        <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a copy of this container.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        A copy of the container</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">deep_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a deep copy (copying all internal tensors) of this container.</span>
<span class="sd">    return: A deep copy of the container</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply function to all array values of container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func</span>
<span class="sd">        Function to apply to each container entry</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    inplace</span>
<span class="sd">        Whether to apply the mapping inplace, or return a new container.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map to sequences (lists and tuples). Default is ``False``.</span>
<span class="sd">    key_chain</span>
<span class="sd">        Chain of keys for this dict entry (Default value = &#39;&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        New container following the function mapped to each sub-array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">this_key_chain</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="n">key_chain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="n">key_chain</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span>
                <span class="n">key_chains</span><span class="p">,</span>
                <span class="n">to_apply</span><span class="p">,</span>
                <span class="n">prune_unapplied</span><span class="p">,</span>
                <span class="n">map_sequences</span><span class="p">,</span>
                <span class="n">inplace</span><span class="p">,</span>
                <span class="n">this_key_chain</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">prune_unapplied</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">map_sequences</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">nested_map</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prune_unapplied</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key_chains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">this_key_chain</span> <span class="ow">in</span> <span class="n">key_chains</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">to_apply</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">this_key_chain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key_chains</span> <span class="ow">and</span> <span class="n">to_apply</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="n">prune_unapplied</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">continue</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">this_key_chain</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">map_conts</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply function to all sub-contains in the container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func</span>
<span class="sd">        Function to apply to each sub-container</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    inplace</span>
<span class="sd">        Whether to apply the mapping inplace, or return a new container.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chain</span>
<span class="sd">        Chain of keys for this dict entry (Default value = &#39;&#39;)</span>
<span class="sd">    include_self</span>
<span class="sd">        Whether to also apply the (possiby in-place) function to this container.</span>
<span class="sd">        Default is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        New container following the function mapped to each sub-container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">this_key_chain</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="n">key_chain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="n">key_chain</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">,</span> <span class="n">to_apply</span><span class="p">,</span> <span class="n">prune_unapplied</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">this_key_chain</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">prune_unapplied</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">key_chains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">this_key_chain</span> <span class="ow">in</span> <span class="n">key_chains</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">to_apply</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">this_key_chain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key_chains</span> <span class="ow">and</span> <span class="n">to_apply</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="ow">and</span> <span class="n">prune_unapplied</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">return_dict</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">key_chain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">include_self</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">key_chain</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">with_entries_as_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">IvyBackendException</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">to_list</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">reshape_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">,</span> <span class="n">leading_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_cont</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set shapes of container entries to shapes specified by new container with the</span>
<span class="sd">    same key structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_dict</span>
<span class="sd">        param leading_shape: (Default value = None)</span>
<span class="sd">    return_cont</span>
<span class="sd">        Default value = None)</span>
<span class="sd">    leading_shape</span>
<span class="sd">         (Default value = None)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        new container with values of updated shapes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">leading_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">leading_shape</span><span class="p">,</span> <span class="nb">list</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">return_cont</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">return_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">v_shape</span><span class="p">),</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">return_cont</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v_shape</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">return_cont</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_like</span><span class="p">(</span>
                <span class="n">v_shape</span><span class="p">,</span> <span class="n">leading_shape</span><span class="p">,</span> <span class="n">return_cont</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_cont</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">leading_shape</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">v_shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_cont</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">create_if_absent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a key to the container with corresponding value, if it is not already</span>
<span class="sd">    present. otherwise, do nothing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key</span>
<span class="sd">        param value:</span>
<span class="sd">    inplace</span>
<span class="sd">        Default value = True)</span>
<span class="sd">    value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_at_key_chain</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">if_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the sub-container at the following key if it exists, otherwise None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span>


<span class="k">def</span> <span class="nf">try_kc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tries the following key or key chain, returning self if not present.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="n">IvyException</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">cutoff_at_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth_cutoff</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    depth_cutoff</span>
<span class="sd">        param inplace: (Default value = False)</span>
<span class="sd">    inplace</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_maybe_cutoff</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">kc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">total_depth</span> <span class="o">-</span> <span class="n">copy</span><span class="p">[</span><span class="n">kc</span><span class="p">]</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">&lt;</span> <span class="n">depth_cutoff</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cont</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">cont</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">()</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_maybe_cutoff</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">cutoff_at_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height_cutoff</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    height_cutoff</span>
<span class="sd">        param inplace: (Default value = False)</span>
<span class="sd">    inplace</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_maybe_cutoff</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">kc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">[</span><span class="n">kc</span><span class="p">]</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">&gt;</span> <span class="n">height_cutoff</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cont</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">cont</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">()</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_maybe_cutoff</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">_slice_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_slice</span><span class="p">):</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_slice</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_true</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key_slice</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">key_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">assertions</span><span class="o">.</span><span class="n">check_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_alphabetical_keys</span><span class="p">)</span>
        <span class="n">start_char</span> <span class="o">=</span> <span class="n">key_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end_char</span> <span class="o">=</span> <span class="n">key_slice</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">start_char</span><span class="p">])</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">end_char</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">key_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">desired_keys</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">key_slice</span><span class="p">]</span>
    <span class="c1"># noinspection PyUnresolvedReferences</span>
    <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">at_key_chains</span><span class="p">(</span><span class="n">desired_keys</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">slice_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_slice</span><span class="p">,</span> <span class="n">all_depths</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_slice</span>
<span class="sd">        param all_depths: (Default value = False)</span>
<span class="sd">    all_depths</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">top_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span>
    <span class="k">if</span> <span class="n">all_depths</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_slice</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">first_slice</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key_slice</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">top_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key_slice</span><span class="p">:</span>
                    <span class="n">key_slice</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_slice</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_slice</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="n">key_slice</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">top_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_slice</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_fn</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">kc</span><span class="p">):</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">kc</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">kc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="ow">in</span> <span class="n">key_slice</span><span class="p">:</span>
                <span class="c1"># noinspection PyProtectedMember</span>
                <span class="k">return</span> <span class="n">cont</span><span class="o">.</span><span class="n">_slice_keys</span><span class="p">(</span><span class="n">key_slice</span><span class="p">[</span><span class="n">depth</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">cont</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_keys</span><span class="p">(</span><span class="n">key_slice</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">with_print_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    print_limit</span>
<span class="sd">        param inplace: (Default value = False)</span>
<span class="sd">    inplace</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_update_print_limit</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="n">cont</span><span class="o">.</span><span class="n">_print_limit</span> <span class="o">=</span> <span class="n">print_limit</span>
        <span class="k">return</span> <span class="n">cont</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_update_print_limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">remove_print_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inplace</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_print_limit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">with_key_length_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_length_limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key_length_limit</span>
<span class="sd">        param inplace: (Default value = False)</span>
<span class="sd">    inplace</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_update_key_length_limit</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="n">cont</span><span class="o">.</span><span class="n">_key_length_limit</span> <span class="o">=</span> <span class="n">key_length_limit</span>
        <span class="k">return</span> <span class="n">cont</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_update_key_length_limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">remove_key_length_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inplace</span>
<span class="sd">        Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_key_length_limit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">with_print_indent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_indent</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    print_indent</span>
<span class="sd">        param inplace: (Default value = False)</span>
<span class="sd">    inplace</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_update_print_indent</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="n">cont</span><span class="o">.</span><span class="n">_print_indent</span> <span class="o">=</span> <span class="n">print_indent</span>
        <span class="k">return</span> <span class="n">cont</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_update_print_indent</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">with_print_line_spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_line_spacing</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    print_line_spacing</span>
<span class="sd">        param inplace: (Default value = False)</span>
<span class="sd">    inplace</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_update_print_line_spacing</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="n">cont</span><span class="o">.</span><span class="n">_print_line_spacing</span> <span class="o">=</span> <span class="n">print_line_spacing</span>
        <span class="k">return</span> <span class="n">cont</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_update_print_line_spacing</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">with_default_key_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_key_color</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    default_key_color</span>
<span class="sd">        param inplace: (Default value = False)</span>
<span class="sd">    inplace</span>
<span class="sd">         (Default value = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_update_default_key_color</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="n">cont</span><span class="o">.</span><span class="n">_default_key_color</span> <span class="o">=</span> <span class="n">default_key_color</span>
        <span class="k">return</span> <span class="n">cont</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_conts</span><span class="p">(</span><span class="n">_update_default_key_color</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">with_ivy_backend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ivy_backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input Container</span>
<span class="sd">    ivy_backend</span>
<span class="sd">        backend to use</span>
<span class="sd">    inplace</span>
<span class="sd">        whether to modify the container or return a copy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span> <span class="o">=</span> <span class="n">ivy_backend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy_backend</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ivyh</span><span class="o">=</span><span class="n">ivy_backend</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">show_sub_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_cont_or_keychain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_cont_or_keychain</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># copy this container</span>
    <span class="n">this_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># get the sub-container</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_cont_or_keychain</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">sub_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">at_key_chain</span><span class="p">(</span><span class="n">sub_cont_or_keychain</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sub_cont</span> <span class="o">=</span> <span class="n">sub_cont_or_keychain</span>
    <span class="c1"># find the key chain of the sub-container</span>
    <span class="n">sub_cont_kc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_sub_container</span><span class="p">(</span><span class="n">sub_cont</span><span class="p">)</span>
    <span class="c1"># show this container if key-chain not found, and return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sub_cont_kc</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="c1"># otherwise, replace sub-container in this container with known key</span>
    <span class="n">this_cont</span><span class="p">[</span><span class="n">sub_cont_kc</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">({</span><span class="s2">&quot;SUB_CONT&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
    <span class="c1"># get the formatted reprs</span>
    <span class="n">this_repr</span> <span class="o">=</span> <span class="n">this_cont</span><span class="o">.</span><span class="n">with_default_key_color</span><span class="p">(</span><span class="s2">&quot;green&quot;</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="n">this_repr_red</span> <span class="o">=</span> <span class="n">this_cont</span><span class="o">.</span><span class="n">with_default_key_color</span><span class="p">(</span><span class="s2">&quot;red&quot;</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="n">this_repr_stripped</span> <span class="o">=</span> <span class="n">ansi_escape</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">this_repr</span><span class="p">)</span>
    <span class="n">sub_repr</span> <span class="o">=</span> <span class="n">sub_cont</span><span class="o">.</span><span class="n">with_default_key_color</span><span class="p">(</span><span class="s2">&quot;red&quot;</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="c1"># remove the outer brackets from the sub repr</span>
    <span class="n">sub_repr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sub_repr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="c1"># find the sub-container placeholder</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">this_repr_stripped</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;SUB_CONT: null&quot;</span><span class="p">)</span>
    <span class="c1"># count the lines above and below the sub-container</span>
    <span class="n">num_lines_above</span> <span class="o">=</span> <span class="n">this_repr_stripped</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">num_lines_below</span> <span class="o">=</span> <span class="n">this_repr_stripped</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># get the str reprs above and below</span>
    <span class="n">this_repr_split</span> <span class="o">=</span> <span class="n">this_repr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">this_repr_red_split</span> <span class="o">=</span> <span class="n">this_repr_red</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">this_repr_above</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">this_repr_split</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">num_lines_above</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span><span class="n">this_repr_red_split</span><span class="p">[</span><span class="n">num_lines_above</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="p">)</span>
    <span class="n">this_repr_below</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">this_repr_split</span><span class="p">[</span><span class="o">-</span><span class="n">num_lines_below</span><span class="p">:])</span>
    <span class="c1"># count the number of lines needed to be prepended to the sub-container repr</span>
    <span class="n">cur_num_spaces</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sub_repr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s2">&quot; &quot;</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">cur_num_spaces</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">exp_num_spaces</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">this_repr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="n">num_lines_above</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s2">&quot; &quot;</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">exp_num_spaces</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">num_spaces_to_add</span> <span class="o">=</span> <span class="n">exp_num_spaces</span> <span class="o">-</span> <span class="n">cur_num_spaces</span>
    <span class="c1"># prepend these lines to the sub-container</span>
    <span class="n">sub_repr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">num_spaces_to_add</span> <span class="o">+</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sub_repr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="c1"># show</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">this_repr_above</span> <span class="o">+</span> <span class="n">sub_repr</span> <span class="o">+</span> <span class="n">this_repr_below</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_repr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">indent_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_indent</span>
    <span class="k">def</span> <span class="nf">_align_array</span><span class="p">(</span><span class="n">array_str_in</span><span class="p">):</span>
        <span class="n">array_str_in_split</span> <span class="o">=</span> <span class="n">array_str_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;([&quot;</span><span class="p">)</span>
        <span class="n">leading_str_to_keep</span> <span class="o">=</span> <span class="n">array_str_in_split</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">indented_key_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leading_str_to_keep</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;: &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">indented_key_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indented_key_size</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">padded</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">def</span> <span class="nf">_pre_pad_alpha_line</span><span class="p">(</span><span class="n">str_in</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">padded</span>
            <span class="n">padded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span> <span class="o">+</span> <span class="n">indent_str</span> <span class="o">+</span> <span class="n">indented_key_str</span> <span class="o">+</span> <span class="n">str_in</span>
        <span class="n">leading_str_to_keep</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">_pre_pad_alpha_line</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">s</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">leading_str_to_keep</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">local_indent_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">padded</span> <span class="k">else</span> <span class="n">indent_str</span>
        <span class="n">leading_str</span> <span class="o">=</span> <span class="n">leading_str_to_keep</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">remaining_str</span> <span class="o">=</span> <span class="n">array_str_in_split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">num_extra_dims</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">remaining_str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char</span> <span class="o">!=</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
                <span class="n">num_extra_dims</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
        <span class="n">extra_indent</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leading_str</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">num_extra_dims</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
        <span class="n">array_str_in</span> <span class="o">=</span> <span class="s2">&quot;([&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">leading_str_to_keep</span><span class="p">,</span> <span class="n">remaining_str</span><span class="p">])</span>
        <span class="n">uniform_indent_wo_overflow</span> <span class="o">=</span> <span class="n">array_str_in</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n[&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">local_indent_str</span> <span class="o">+</span> <span class="n">extra_indent</span> <span class="o">+</span> <span class="s2">&quot;[&quot;</span>
        <span class="p">)</span>
        <span class="n">uniform_indent_wo_overflow_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">uniform_indent_wo_overflow</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">uniform_indent</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">local_indent_str</span> <span class="o">+</span> <span class="n">extra_indent</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">s</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span>
                    <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span>
                    <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;...&quot;</span>
                    <span class="ow">or</span> <span class="nb">max</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;nan, &quot;</span><span class="p">,</span> <span class="s2">&quot;inf, &quot;</span><span class="p">]])</span>
                <span class="p">)</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="n">indent_str</span> <span class="o">+</span> <span class="n">indented_key_str</span> <span class="o">+</span> <span class="n">s</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">s</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">uniform_indent_wo_overflow_list</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">indented</span> <span class="o">=</span> <span class="n">uniform_indent</span>
        <span class="c1"># 10 dimensions is a sensible upper bound for the number in a single array</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
            <span class="n">indented</span> <span class="o">=</span> <span class="n">indented</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;[&quot;</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">indented</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">indented</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">isspace</span><span class="p">()]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">indented</span>
    <span class="k">def</span> <span class="nf">_align_arrays</span><span class="p">(</span><span class="n">str_in</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">str_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">indent_str</span><span class="p">)</span>
        <span class="n">aligned_array_chunks</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">_align_array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span> <span class="ow">in</span> <span class="n">c</span>
        <span class="p">}</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">aligned_array_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">aligned_array_chunks</span> <span class="k">else</span> <span class="n">c_orig</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c_orig</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">indent_str</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="n">new_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="c1"># noinspection PyArgumentList</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="n">as_repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">is_native_array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">))</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_print_limit</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_limit</span>
            <span class="p">):</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;shape=&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">v</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span><span class="o">.</span><span class="n">is_native_array</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;_asdict&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;_fields&quot;</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_limit</span><span class="p">:</span>
                        <span class="n">rep</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_limit</span>
                                <span class="k">else</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> = </span><span class="si">{}</span><span class="s2">, shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                                <span class="p">)</span>
                                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span>
                            <span class="p">],</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rep</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;NamedTuple(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span>
                            <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                            <span class="s2">&quot;shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span>
                        <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">rep</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;tuple(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                        <span class="s2">&quot;shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rep</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;list[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                        <span class="s2">&quot;shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">new_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rep</span>
    <span class="k">if</span> <span class="n">as_repr</span><span class="p">:</span>
        <span class="n">json_dumped_str</span> <span class="o">=</span> <span class="n">_align_arrays</span><span class="p">(</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span>
                <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">new_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
                <span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span>
                    <span class="k">if</span> <span class="n">_is_jsonable</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">_repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                <span class="n">indent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_print_indent</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">def</span> <span class="nf">_add_newline</span><span class="p">(</span><span class="n">str_in</span><span class="p">):</span>
            <span class="n">str_in_split</span> <span class="o">=</span> <span class="n">str_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">str_split_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">str_in_split</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_line_spacing</span> <span class="o">+</span> <span class="n">ss</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">str_split_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">ss</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ss</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">str_in_split</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="n">json_dumped_str</span> <span class="o">=</span> <span class="s1">&#39;&quot;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_add_newline</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">json_dumped_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&quot;:&#39;</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="c1"># improve tf formatting</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">backend_stack</span> <span class="ow">and</span> <span class="n">ivy</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;tensorflow&quot;</span><span class="p">:</span>
            <span class="n">json_dumped_str_split</span> <span class="o">=</span> <span class="n">json_dumped_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;Variable:&quot;</span><span class="p">)</span>
            <span class="n">json_dumped_str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">json_dumped_str_split</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="s2">&quot;&#39;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
                        <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">json_dumped_str_split</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">json_dumped_str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">json_dumped_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:shape&quot;</span><span class="p">,</span> <span class="s2">&quot;, shape&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;)dtype=&quot;</span><span class="p">,</span> <span class="s2">&quot;), dtype=&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;, ),&quot;</span><span class="p">,</span> <span class="s2">&quot;,),&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">json_dumped_str</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;}, $&quot;</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="n">json_dumped_str</span><span class="p">)</span>
        <span class="c1"># color keys</span>
        <span class="n">json_dumped_str_split</span> <span class="o">=</span> <span class="n">json_dumped_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&quot;:&#39;</span><span class="p">)</span>
        <span class="n">split_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_dumped_str_split</span><span class="p">)</span>
        <span class="n">json_dumped_str</span> <span class="o">=</span> <span class="s1">&#39;&quot;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s1">&#39; &quot;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">sub_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &quot;&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">[</span>
                        <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span>
                            <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">trim_key</span><span class="p">(</span>
                                <span class="n">sub_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &quot;&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_length_limit</span>
                            <span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_default_key_color</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">split_size</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="n">sub_str</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sub_str</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">json_dumped_str_split</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># remove quotation marks, shape tuple, and color other elements of the dict</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">json_dumped_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;, &#39;shape=&#39;, [&quot;</span><span class="p">,</span> <span class="s2">&quot; shape=[&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;magenta&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span><span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;shape=&quot;</span><span class="p">,</span> <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span><span class="s2">&quot;shape=&quot;</span><span class="p">,</span> <span class="s2">&quot;magenta&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;device=&quot;</span><span class="p">,</span> <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span><span class="s2">&quot;device=&quot;</span><span class="p">,</span> <span class="s2">&quot;magenta&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;class&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;class &#39;&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;class&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span><span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># ToDo: make the solution below more elegant</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="s2">&quot;diff_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span><span class="s2">&quot;diff_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_color_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">termcolor</span><span class="o">.</span><span class="n">colored</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">color</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">return</span> <span class="n">new_dict</span>


<span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>


<span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># noinspection PyUnresolvedReferences</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># raise error</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">item</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">attr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="k">else</span> <span class="n">attr</span>
            <span class="n">ret</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;_&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">super</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_queue_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">queue_queries</span> <span class="o">=</span> <span class="p">[</span><span class="n">query</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="n">queue_queries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">queue_queries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">IvyException</span><span class="p">(</span>
            <span class="s2">&quot;Invalid slice type, must be one of integer, slice &quot;</span>
            <span class="s2">&quot;or sequences of slices.&quot;</span>
        <span class="p">)</span>
    <span class="n">queue_idxs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queue_load_sizes_cum</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue_queries</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">conts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">queue_idxs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaded_containers_from_queues</span><span class="p">:</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue_timeout</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span>
            <span class="p">)</span><span class="o">.</span><span class="n">to_ivy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loaded_containers_from_queues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cont</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaded_containers_from_queues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">conts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span>
    <span class="n">combined_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container_combine_method</span><span class="p">(</span><span class="n">conts</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">queue_idxs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queue_load_sizes_cum</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">shifted_query</span> <span class="o">=</span> <span class="n">query</span> <span class="o">-</span> <span class="n">offset</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="n">shifted_query</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">shifted_query</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="nb">slice</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">slc</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">slc</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">query</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="c1"># noinspection PyUnboundLocalVariable</span>
    <span class="k">return</span> <span class="n">combined_cont</span><span class="p">[</span><span class="n">shifted_query</span><span class="p">]</span>


<span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get slice, key or key chain of container object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    query slice or str</span>
<span class="sd">        slice object, key or key chain to query all container elements.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object at desired query.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">query</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="s2">&quot;/&quot;</span> <span class="ow">in</span> <span class="n">query</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">query</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">at_key_chain</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">elif</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_queue_item</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">query</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># noinspection PyBroadException</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">query</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">query</span><span class="p">]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">return_dict</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set key or key chain of container object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    query slice or str</span>
<span class="sd">        slice object, key or key chain at which to set all container elements.</span>
<span class="sd">    val ivy.Container, array, or other</span>
<span class="sd">        The value to set at the desired query.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        New container after updating.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;/&quot;</span> <span class="ow">in</span> <span class="n">query</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">query</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_at_key_chain</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;/&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_key_chain</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_sub_container</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">state_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
    <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">try_else_none</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">config_in</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config_in&quot;</span><span class="p">])</span>
    <span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">try_else_none</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config_in&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_in</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">])</span>
    <span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">try_else_none</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">())</span>
    <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span>
    <span class="k">return</span> <span class="n">state_dict</span>


<span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;_local_ivy&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]):</span>
            <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="s2">&quot;_config_in&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
        <span class="n">config_in</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config_in&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;ivyh&quot;</span> <span class="ow">in</span> <span class="n">config_in</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]):</span>
                <span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">])</span>
        <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config_in&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_in</span>
    <span class="k">if</span> <span class="s2">&quot;_config&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;ivyh&quot;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]):</span>
                <span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">])</span>
        <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ivy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local_ivy</span><span class="p">,</span> <span class="n">ivy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ivy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">local_ivy</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_local_ivy</span> <span class="o">=</span> <span class="n">local_ivy</span>


<span class="k">def</span> <span class="nf">shared_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The shape of the arrays in the container, with None placed in indices which</span>
<span class="sd">    are not consistent across arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_shape</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The shapes of each array in the container, with None placed in leaf entries</span>
<span class="sd">    without a shape attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_shapes</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">dev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The device to which the arrays in the container belong, with None returned if</span>
<span class="sd">    the devices are not consistent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dev</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">dev_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The device to which the arrays in the container belong, with None returned if</span>
<span class="sd">    the devices are not consistent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dev</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">ivy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ivy</span>


<span class="k">def</span> <span class="nf">config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span>


<span class="k">def</span> <span class="nf">max_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">kcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">kc</span> <span class="k">for</span> <span class="n">kc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_iterator_keys</span><span class="p">(</span><span class="n">include_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">kcs</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">kc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">kc</span> <span class="ow">in</span> <span class="n">kcs</span><span class="p">])</span>


<span class="c1">#ivy.container.container</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">.activations</span> <span class="kn">import</span> <span class="n">ContainerWithActivations</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">.conversions</span> <span class="kn">import</span> <span class="n">ContainerWithConversions</span>
<span class="kn">from</span> <span class="nn">.creation</span> <span class="kn">import</span> <span class="n">ContainerWithCreation</span>
<span class="kn">from</span> <span class="nn">.data_type</span> <span class="kn">import</span> <span class="n">ContainerWithDataTypes</span>
<span class="kn">from</span> <span class="nn">.device</span> <span class="kn">import</span> <span class="n">ContainerWithDevice</span>
<span class="kn">from</span> <span class="nn">.elementwise</span> <span class="kn">import</span> <span class="n">ContainerWithElementwise</span>
<span class="kn">from</span> <span class="nn">.general</span> <span class="kn">import</span> <span class="n">ContainerWithGeneral</span>
<span class="kn">from</span> <span class="nn">.gradients</span> <span class="kn">import</span> <span class="n">ContainerWithGradients</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">ContainerWithImage</span>
<span class="kn">from</span> <span class="nn">.layers</span> <span class="kn">import</span> <span class="n">ContainerWithLayers</span>
<span class="kn">from</span> <span class="nn">.linear_algebra</span> <span class="kn">import</span> <span class="n">ContainerWithLinearAlgebra</span>
<span class="kn">from</span> <span class="nn">.losses</span> <span class="kn">import</span> <span class="n">ContainerWithLosses</span>
<span class="kn">from</span> <span class="nn">.manipulation</span> <span class="kn">import</span> <span class="n">ContainerWithManipulation</span>
<span class="kn">from</span> <span class="nn">.norms</span> <span class="kn">import</span> <span class="n">ContainerWithNorms</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">ContainerWithRandom</span>
<span class="kn">from</span> <span class="nn">.searching</span> <span class="kn">import</span> <span class="n">ContainerWithSearching</span>
<span class="kn">from</span> <span class="nn">.set</span> <span class="kn">import</span> <span class="n">ContainerWithSet</span>
<span class="kn">from</span> <span class="nn">.sorting</span> <span class="kn">import</span> <span class="n">ContainerWithSorting</span>
<span class="kn">from</span> <span class="nn">.statistical</span> <span class="kn">import</span> <span class="n">ContainerWithStatistical</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="kn">import</span> <span class="n">ContainerWithUtility</span>
<span class="kn">from</span> <span class="nn">ivy.container.experimental</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ContainerWithActivationExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithConversionExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithCreationExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithData_typeExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithDeviceExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithElementWiseExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithGeneralExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithGradientsExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithImageExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithLayersExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithLinearAlgebraExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithLossesExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithManipulationExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithNormsExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithRandomExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithSearchingExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithSetExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithSortingExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithStatisticalExperimental</span><span class="p">,</span>
    <span class="n">ContainerWithUtilityExperimental</span><span class="p">,</span>
<span class="p">)</span>




<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dict_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">queues</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">queue_load_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">container_combine_method</span><span class="o">=</span><span class="s2">&quot;list_join&quot;</span><span class="p">,</span>
    <span class="n">queue_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">print_limit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">key_length_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">print_indent</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">print_line_spacing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">ivyh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_key_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
    <span class="n">keyword_color_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rebuild_child_containers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">types_to_iteratively_nest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alphabetical_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="n">ContainerBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dict_in</span><span class="p">,</span>
        <span class="n">queues</span><span class="p">,</span>
        <span class="n">queue_load_sizes</span><span class="p">,</span>
        <span class="n">container_combine_method</span><span class="p">,</span>
        <span class="n">queue_timeout</span><span class="p">,</span>
        <span class="n">print_limit</span><span class="p">,</span>
        <span class="n">key_length_limit</span><span class="p">,</span>
        <span class="n">print_indent</span><span class="p">,</span>
        <span class="n">print_line_spacing</span><span class="p">,</span>
        <span class="n">ivyh</span><span class="p">,</span>
        <span class="n">default_key_color</span><span class="p">,</span>
        <span class="n">keyword_color_dict</span><span class="p">,</span>
        <span class="n">rebuild_child_containers</span><span class="p">,</span>
        <span class="n">types_to_iteratively_nest</span><span class="p">,</span>
        <span class="n">alphabetical_keys</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="n">power</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">power</span><span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container special method for the add operator, calling :code:`operator.add`</span>
<span class="sd">    for each of the corresponding leaves of the two containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`Number` instances at the leaves:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=1, b=2)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=3, b=4)</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: 4,</span>
<span class="sd">        b: 6</span>
<span class="sd">    }</span>
<span class="sd">    With :class:`ivy.Array` instances at the leaves:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 9]),</span>
<span class="sd">        b: ivy.array([7, 9, 11])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Container` and :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[4.], [5.], [6.]]),</span>
<span class="sd">    ...                   b=ivy.array([[5.], [6.], [7.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([[1.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[5.1, 6.3, 0.4],</span>
<span class="sd">                      [6.1, 7.3, 1.4],</span>
<span class="sd">                      [7.1, 8.3, 2.4]]),</span>
<span class="sd">        b: ivy.array([[6.1, 7.3, 1.4],</span>
<span class="sd">                      [7.1, 8.3, 2.4],</span>
<span class="sd">                      [8.1, 9.3, 3.4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container reverse special method for the add operator, calling</span>
<span class="sd">    :code:`operator.add` for each of the corresponding leaves of the two containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = 1</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=3, b=4)</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: 4,</span>
<span class="sd">        b: 5</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container special method for the subtract operator, calling</span>
<span class="sd">    :code:`operator.sub` for each of the corresponding leaves of the two containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise differences. The returned array must</span>
<span class="sd">        have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`Number` instances at the leaves:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=1, b=2)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=3, b=4)</span>
<span class="sd">    &gt;&gt;&gt; z = x - y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: -2,</span>
<span class="sd">        b: -2</span>
<span class="sd">    }</span>
<span class="sd">    With :class:`ivy.Array` instances at the leaves:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([4, 3, 2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([6, 5, 4]))</span>
<span class="sd">    &gt;&gt;&gt; z = x - y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-3, -3, -3]),</span>
<span class="sd">        b: ivy.array([-2, -2, -2])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Container` and :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[4.], [5.], [6.]]),</span>
<span class="sd">    ...                   b=ivy.array([[5.], [6.], [7.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([[1.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; z = x - y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[2.9, 1.7, 7.6],</span>
<span class="sd">                      [3.9, 2.7, 8.6],</span>
<span class="sd">                      [4.9, 3.7, 9.6]]),</span>
<span class="sd">        b: ivy.array([[3.9, 2.7, 8.6],</span>
<span class="sd">                      [4.9, 3.7, 9.6],</span>
<span class="sd">                      [5.9, 4.7, 10.6]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container reverse special method for the subtract operator, calling</span>
<span class="sd">    :code:`operator.sub` for each of the corresponding leaves of the two containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise differences. The returned array must</span>
<span class="sd">        have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = 1</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=3, b=4)</span>
<span class="sd">    &gt;&gt;&gt; z = x - y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: -2,</span>
<span class="sd">        b: -3</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span>
            <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="o">//</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">other</span> <span class="o">//</span> <span class="n">x</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">other</span> <span class="ow">and</span> <span class="n">x</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">other</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">other</span> <span class="ow">or</span> <span class="n">x</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">not_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">other</span> <span class="o">!=</span> <span class="n">x</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container special method for the right shift operator, calling</span>
<span class="sd">    :code:`operator.rshift` for each of the corresponding leaves of the</span>
<span class="sd">    two containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have an integer data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have an integer data type.</span>
<span class="sd">        Each element must be greater than or equal to ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`Number` instances at the leaves:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=128, b=43)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=5, b=3)</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt;&gt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: 4,</span>
<span class="sd">        b: 5</span>
<span class="sd">    }</span>
<span class="sd">    With :class:`ivy.Array` instances at the leaves:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([16, 40, 120]),</span>
<span class="sd">    ...                   b=ivy.array([15, 45, 143]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([0, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt;&gt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8, 10, 15]),</span>
<span class="sd">        b: ivy.array([15, 5, 8])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Container` and :class:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([16, 40, 120]),</span>
<span class="sd">    ...                   b=ivy.array([15, 45, 143]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt;&gt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8, 10, 15]),</span>
<span class="sd">        b: ivy.array([7, 11, 17])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="o">.</span><span class="n">multi_map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">rshift</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span>
            <span class="n">map_nests</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">rshift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container reverse special method for the right shift operator, calling</span>
<span class="sd">    :code:`operator.rshift` for each of the corresponding leaves of the two</span>
<span class="sd">    containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have an integer data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have an integer data type. Each element</span>
<span class="sd">        must be greater than or equal to ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = 64</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(a = ivy.array([0, 1, 2]),</span>
<span class="sd">    ...                   b = ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = a &gt;&gt; b</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([64, 32, 16]),</span>
<span class="sd">        b: ivy.array([8, 4, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">kc</span><span class="p">:</span> <span class="n">other</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">map_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">state_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
    <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="kc">None</span>
    <span class="p">)</span>
    <span class="n">config_in</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config_in&quot;</span><span class="p">])</span>
    <span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="kc">None</span>
    <span class="p">)</span>
    <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config_in&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_in</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">])</span>
    <span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">current_backend_str</span><span class="p">()</span> <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="p">)</span>
    <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span>
    <span class="k">return</span> <span class="n">state_dict</span>


<span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;_local_ivy&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_local_ivy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span>
    <span class="k">if</span> <span class="s2">&quot;_config_in&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
        <span class="n">config_in</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config_in&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;ivyh&quot;</span> <span class="ow">in</span> <span class="n">config_in</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">config_in</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span>
        <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config_in&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_in</span>
    <span class="k">if</span> <span class="s2">&quot;_config&quot;</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="p">:</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;ivyh&quot;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">config</span><span class="p">[</span><span class="s2">&quot;ivyh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivy</span>
        <span class="n">state_dict</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span>


<span class="c1">#ivy.container.conversions</span>
<span class="sd">&quot;&quot;&quot;Collection of Ivy functions for wrapping functions to accept and return</span>
<span class="sd">ivy.Container instances.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>




<span class="k">def</span> <span class="nf">static_to_native</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_derived</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_native. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_native also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to be converted.</span>
<span class="sd">    nested</span>
<span class="sd">        Whether to apply the conversion on arguments in a nested manner. If so, all</span>
<span class="sd">        dicts, lists and tuples will be traversed to their lowest leaves in search</span>
<span class="sd">        of ivy.Array instances. Default is ``False``.</span>
<span class="sd">    include_derived</span>
<span class="sd">        Whether to also recursive for classes derived from tuple, list and dict.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container object with all sub-arrays converted to their native format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;to_native&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span>
        <span class="n">include_derived</span><span class="o">=</span><span class="n">include_derived</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">to_native</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_derived</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_native. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_native also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to be converted.</span>
<span class="sd">    nested</span>
<span class="sd">        Whether to apply the conversion on arguments in a nested manner. If so, all</span>
<span class="sd">        dicts, lists and tuples will be traversed to their lowest leaves in search</span>
<span class="sd">        of ivy.Array instances. Default is ``False``.</span>
<span class="sd">    include_derived</span>
<span class="sd">        Whether to also recursive for classes derived from tuple, list and dict.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container object with all sub-arrays converted to their native format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_to_native</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nested</span><span class="p">,</span>
        <span class="n">include_derived</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">static_to_ivy</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_derived</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_ivy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_ivy also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to be converted.</span>
<span class="sd">    nested</span>
<span class="sd">        Whether to apply the conversion on arguments in a nested manner. If so, all</span>
<span class="sd">        dicts, lists and tuples will be traversed to their lowest leaves in search</span>
<span class="sd">        of ivy.Array instances. Default is ``False``.</span>
<span class="sd">    include_derived</span>
<span class="sd">        Whether to also recursive for classes derived from tuple, list and dict.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container object with all native sub-arrays converted to their ivy.Array</span>
<span class="sd">        instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;to_ivy&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span>
        <span class="n">include_derived</span><span class="o">=</span><span class="n">include_derived</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">to_ivy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_derived</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_ivy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_ivy also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to be converted.</span>
<span class="sd">    nested</span>
<span class="sd">        Whether to apply the conversion on arguments in a nested manner. If so,</span>
<span class="sd">        all dicts, lists and tuples will be traversed to their lowest leaves in</span>
<span class="sd">        search of ivy.Array instances. Default is ``False``.</span>
<span class="sd">    include_derived</span>
<span class="sd">        Whether to also recursive for classes derived from tuple, list and dict.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container object with all native sub-arrays converted to their ivy.Array</span>
<span class="sd">        instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_to_ivy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nested</span><span class="p">,</span>
        <span class="n">include_derived</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="c1">#ivy.container.creation</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>




<div class="viewcode-block" id="static_arange"><a class="viewcode-back" href="../../../functional/ivy/creation/arange/static_arange_container.html#ivy.container.container_methods.static_arange">[docs]</a><span class="k">def</span> <span class="nf">static_arange</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Number</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">step</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;arange&quot;</span><span class="p">,</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">,</span>
        <span class="n">step</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_asarray"><a class="viewcode-back" href="../../../functional/ivy/creation/asarray/static_asarray_container.html#ivy.container.container_methods.static_asarray">[docs]</a><span class="k">def</span> <span class="nf">static_asarray</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;asarray&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_zeros"><a class="viewcode-back" href="../../../functional/ivy/creation/zeros/static_zeros_container.html#ivy.container.container_methods.static_zeros">[docs]</a><span class="k">def</span> <span class="nf">static_zeros</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;zeros&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_ones"><a class="viewcode-back" href="../../../functional/ivy/creation/ones/static_ones_container.html#ivy.container.container_methods.static_ones">[docs]</a><span class="k">def</span> <span class="nf">static_ones</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;ones&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_full_like"><a class="viewcode-back" href="../../../functional/ivy/creation/full_like/static_full_like_container.html#ivy.container.container_methods.static_full_like">[docs]</a><span class="k">def</span> <span class="nf">static_full_like</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.full_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.full_like also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    fill_value</span>
<span class="sd">        Scalar fill value</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is `None`, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``x`` and whose elements,</span>
<span class="sd">        relative to ``x``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([1,2,3]) ,b = ivy.array([4,5,6]))</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 10</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_full_like(fill_value)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10, 10, 10]),</span>
<span class="sd">        b: ivy.array([10, 10, 10])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.2, 2.2324, 3.234]),</span>
<span class="sd">    ...                   b=ivy.array([4.123, 5.23, 6.23]))</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 15.0</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_full_like(fill_value)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([15., 15., 15.]),</span>
<span class="sd">        b: ivy.array([15., 15., 15.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;full_like&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="full_like"><a class="viewcode-back" href="../../../functional/ivy/creation/full_like/full_like_container.html#ivy.container.container_methods.full_like">[docs]</a><span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.full_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.full_like also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    fill_value</span>
<span class="sd">        Scalar fill value</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is `None`, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``x`` and whose elements,</span>
<span class="sd">        relative to ``x``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([1,2,3]) ,b = ivy.array([4,5,6]))</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 10</span>
<span class="sd">    &gt;&gt;&gt; y = x.full_like(fill_value)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10, 10, 10]),</span>
<span class="sd">        b: ivy.array([10, 10, 10])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.2,2.2324,3.234]),</span>
<span class="sd">    ...                   b=ivy.array([4.123,5.23,6.23]))</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 15.0</span>
<span class="sd">    &gt;&gt;&gt; y = x.full_like(fill_value)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([15., 15., 15.]),</span>
<span class="sd">        b: ivy.array([15., 15., 15.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_full_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_ones_like"><a class="viewcode-back" href="../../../functional/ivy/creation/ones_like/static_ones_like_container.html#ivy.container.container_methods.static_ones_like">[docs]</a><span class="k">def</span> <span class="nf">static_ones_like</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.ones_like. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.ones_like also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container having the same shape as ``self`` and filled with ones.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;ones_like&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="ones_like"><a class="viewcode-back" href="../../../functional/ivy/creation/ones_like/ones_like_container.html#ivy.container.container_methods.ones_like">[docs]</a><span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.ones_like. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.ones_like also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container having the same shape as ``self`` and filled with ones.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_ones_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_zeros_like"><a class="viewcode-back" href="../../../functional/ivy/creation/zeros_like/static_zeros_like_container.html#ivy.container.container_methods.static_zeros_like">[docs]</a><span class="k">def</span> <span class="nf">static_zeros_like</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.zeros_like. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zeros_like also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container from which to derive the output container shape.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output container</span>
<span class="sd">        data type must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output container device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container having the same shape as ``x`` and filled with ``zeros``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;zeros_like&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="zeros_like"><a class="viewcode-back" href="../../../functional/ivy/creation/zeros_like/zeros_like_container.html#ivy.container.container_methods.zeros_like">[docs]</a><span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.zeros_like. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zeros_like also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container from which to derive the output container shape.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output container</span>
<span class="sd">        data type must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output container device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container having the same shape as ``x`` and filled with ``zeros``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_zeros_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_tril"><a class="viewcode-back" href="../../../functional/ivy/creation/tril/static_tril_container.html#ivy.container.container_methods.static_tril">[docs]</a><span class="k">def</span> <span class="nf">static_tril</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;tril&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="tril"><a class="viewcode-back" href="../../../functional/ivy/creation/tril/tril_container.html#ivy.container.container_methods.tril">[docs]</a><span class="k">def</span> <span class="nf">tril</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_tril</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_triu"><a class="viewcode-back" href="../../../functional/ivy/creation/triu/static_triu_container.html#ivy.container.container_methods.static_triu">[docs]</a><span class="k">def</span> <span class="nf">static_triu</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;triu&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="triu"><a class="viewcode-back" href="../../../functional/ivy/creation/triu/triu_container.html#ivy.container.container_methods.triu">[docs]</a><span class="k">def</span> <span class="nf">triu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_triu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_empty_like"><a class="viewcode-back" href="../../../functional/ivy/creation/empty_like/static_empty_like_container.html#ivy.container.container_methods.static_empty_like">[docs]</a><span class="k">def</span> <span class="nf">static_empty_like</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;empty_like&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="empty_like"><a class="viewcode-back" href="../../../functional/ivy/creation/empty_like/empty_like_container.html#ivy.container.container_methods.empty_like">[docs]</a><span class="k">def</span> <span class="nf">empty_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_empty_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_eye"><a class="viewcode-back" href="../../../functional/ivy/creation/eye/static_eye_container.html#ivy.container.container_methods.static_eye">[docs]</a><span class="k">def</span> <span class="nf">static_eye</span><span class="p">(</span>
    <span class="n">n_rows</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;eye&quot;</span><span class="p">,</span>
        <span class="n">n_rows</span><span class="p">,</span>
        <span class="n">n_cols</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_linspace"><a class="viewcode-back" href="../../../functional/ivy/creation/linspace/static_linspace_container.html#ivy.container.container_methods.static_linspace">[docs]</a><span class="k">def</span> <span class="nf">static_linspace</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;linspace&quot;</span><span class="p">,</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">,</span>
        <span class="n">num</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">,</span>
        <span class="n">endpoint</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_meshgrid"><a class="viewcode-back" href="../../../functional/ivy/creation/meshgrid/static_meshgrid_container.html#ivy.container.container_methods.static_meshgrid">[docs]</a><span class="k">def</span> <span class="nf">static_meshgrid</span><span class="p">(</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span>
    <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">indexing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;meshgrid&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arrays</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">,</span>
        <span class="n">indexing</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="meshgrid"><a class="viewcode-back" href="../../../functional/ivy/creation/meshgrid/meshgrid_container.html#ivy.container.container_methods.meshgrid">[docs]</a><span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span>
    <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">indexing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">x_</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">sparse</span><span class="p">,</span>
            <span class="n">indexing</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_from_dlpack"><a class="viewcode-back" href="../../../functional/ivy/creation/from_dlpack/static_from_dlpack_container.html#ivy.container.container_methods.static_from_dlpack">[docs]</a><span class="k">def</span> <span class="nf">static_from_dlpack</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;from_dlpack&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="from_dlpack"><a class="viewcode-back" href="../../../functional/ivy/creation/from_dlpack/from_dlpack_container.html#ivy.container.container_methods.from_dlpack">[docs]</a><span class="k">def</span> <span class="nf">from_dlpack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_from_dlpack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_native_array"><a class="viewcode-back" href="../../../functional/ivy/creation/native_array/static_native_array_container.html#ivy.container.container_methods.static_native_array">[docs]</a><span class="k">def</span> <span class="nf">static_native_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;native_array&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="native_array"><a class="viewcode-back" href="../../../functional/ivy/creation/native_array/native_array_container.html#ivy.container.container_methods.native_array">[docs]</a><span class="k">def</span> <span class="nf">native_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_native_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_logspace"><a class="viewcode-back" href="../../../functional/ivy/creation/logspace/static_logspace_container.html#ivy.container.container_methods.static_logspace">[docs]</a><span class="k">def</span> <span class="nf">static_logspace</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;logspace&quot;</span><span class="p">,</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">,</span>
        <span class="n">num</span><span class="p">,</span>
        <span class="n">base</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">,</span>
        <span class="n">endpoint</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_one_hot"><a class="viewcode-back" href="../../../functional/ivy/creation/one_hot/static_one_hot_container.html#ivy.container.container_methods.static_one_hot">[docs]</a><span class="k">def</span> <span class="nf">static_one_hot</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">on_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">off_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.one_hot. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.one_hot</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices</span>
<span class="sd">        Indices for where the ones should be scattered *[batch_shape, dim]*</span>
<span class="sd">    depth</span>
<span class="sd">        Scalar defining the depth of the one-hot dimension.</span>
<span class="sd">    on_value</span>
<span class="sd">        Value to fill in output when indices[j] = i. If None, defaults to 1.</span>
<span class="sd">    off_value</span>
<span class="sd">        Value to fill in output when indices[j] != i. If None, defaults to 0.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis to scatter on. The default is ``-1``, a new inner-most axis is created.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type of the output tensor. If None, defaults to the on_value dtype</span>
<span class="sd">        or the off_value dtype. If both are None, defaults to float32.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container with tensors of zeros with the same shape and type as the inputs,</span>
<span class="sd">        unless dtype provided which overrides.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;one_hot&quot;</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">depth</span><span class="p">,</span>
        <span class="n">on_value</span><span class="o">=</span><span class="n">on_value</span><span class="p">,</span>
        <span class="n">off_value</span><span class="o">=</span><span class="n">off_value</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="one_hot"><a class="viewcode-back" href="../../../functional/ivy/creation/one_hot/one_hot_container.html#ivy.container.container_methods.one_hot">[docs]</a><span class="k">def</span> <span class="nf">one_hot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">on_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">off_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.one_hot. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.one_hot</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Indices for where the ones should be scattered *[batch_shape, dim]*</span>
<span class="sd">    depth</span>
<span class="sd">        Scalar defining the depth of the one-hot dimension.</span>
<span class="sd">    on_value</span>
<span class="sd">        Value to fill in output when indices[j] == i. If None, defaults to 1.</span>
<span class="sd">    off_value</span>
<span class="sd">        Value to fill in output when indices[j] != i. If None, defaults to 0.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis to scatter on. The default is ``-1``, a new inner-most axis is created.</span>
<span class="sd">    dtype</span>
<span class="sd">        The dtype of the returned tensor. If None, defaults to the on_value dtype</span>
<span class="sd">        or the off_value dtype. If both are None, defaults to float32.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container with tensors of zeros with the same shape and type as the inputs,</span>
<span class="sd">        unless dtype provided which overrides.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_one_hot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">depth</span><span class="p">,</span>
        <span class="n">on_value</span><span class="o">=</span><span class="n">on_value</span><span class="p">,</span>
        <span class="n">off_value</span><span class="o">=</span><span class="n">off_value</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.data_type</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_astype"><a class="viewcode-back" href="../../../functional/ivy/data_type/astype/static_astype_container.html#ivy.container.container_methods.static_astype">[docs]</a><span class="k">def</span> <span class="nf">static_astype</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Copies an array to a specified data type irrespective of</span>
<span class="sd">    :ref:`type-promotion` rules.</span>
<span class="sd">    .. note::</span>
<span class="sd">    Casting floating-point ``NaN`` and ``infinity`` values to integral data types</span>
<span class="sd">    is not specified and is implementation-dependent.</span>
<span class="sd">    .. note::</span>
<span class="sd">    When casting a boolean input array to a numeric data type, a value of ``True``</span>
<span class="sd">    must cast to a numeric value equal to ``1``, and a value of ``False`` must cast</span>
<span class="sd">    to a numeric value equal to ``0``.</span>
<span class="sd">    When casting a numeric input array to ``bool``, a value of ``0`` must cast to</span>
<span class="sd">    ``False``, and a non-zero value must cast to ``True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        array to cast.</span>
<span class="sd">    dtype</span>
<span class="sd">        desired data type.</span>
<span class="sd">    copy</span>
<span class="sd">        specifies whether to copy an array when the specified ``dtype`` matches</span>
<span class="sd">        the data type of the input array ``x``. If ``True``, a newly allocated</span>
<span class="sd">        array must always be returned. If ``False`` and the specified ``dtype``</span>
<span class="sd">        matches the data type of the input array, the input array must be returned;</span>
<span class="sd">        otherwise, a newly allocated must be returned. Default: ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the specified data type. The returned array must have</span>
<span class="sd">        the same shape as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; c = ivy.Container(a=ivy.array([False,True,True]),</span>
<span class="sd">    ...                   b=ivy.array([3.14, 2.718, 1.618]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_astype(c, ivy.int32)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 1]),</span>
<span class="sd">        b: ivy.array([3, 2, 1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;astype&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="astype"><a class="viewcode-back" href="../../../functional/ivy/data_type/astype/astype_container.html#ivy.container.container_methods.astype">[docs]</a><span class="k">def</span> <span class="nf">astype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Copies an array to a specified data type irrespective of</span>
<span class="sd">    :ref:`type-promotion` rules.</span>
<span class="sd">    .. note::</span>
<span class="sd">    Casting floating-point ``NaN`` and ``infinity`` values to integral data types</span>
<span class="sd">    is not specified and is implementation-dependent.</span>
<span class="sd">    .. note::</span>
<span class="sd">    When casting a boolean input array to a numeric data type, a value of ``True``</span>
<span class="sd">    must cast to a numeric value equal to ``1``, and a value of ``False`` must cast</span>
<span class="sd">    to a numeric value equal to ``0``.</span>
<span class="sd">    When casting a numeric input array to ``bool``, a value of ``0`` must cast to</span>
<span class="sd">    ``False``, and a non-zero value must cast to ``True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        array to cast.</span>
<span class="sd">    dtype</span>
<span class="sd">        desired data type.</span>
<span class="sd">    copy</span>
<span class="sd">        specifies whether to copy an array when the specified ``dtype`` matches</span>
<span class="sd">        the data type of the input array ``x``. If ``True``, a newly allocated</span>
<span class="sd">        array must always be returned. If ``False`` and the specified ``dtype``</span>
<span class="sd">        matches the data type of the input array, the input array must be returned;</span>
<span class="sd">        otherwise, a newly allocated must be returned. Default: ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">         that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the specified data type. The returned array must have</span>
<span class="sd">        the same shape as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([False,True,True]),</span>
<span class="sd">    ...                   b=ivy.array([3.14, 2.718, 1.618]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.astype(ivy.int32))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 1]),</span>
<span class="sd">        b: ivy.array([3, 2, 1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_astype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_broadcast_arrays"><a class="viewcode-back" href="../../../functional/ivy/data_type/broadcast_arrays/static_broadcast_arrays_container.html#ivy.container.container_methods.static_broadcast_arrays">[docs]</a><span class="k">def</span> <span class="nf">static_broadcast_arrays</span><span class="p">(</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `ivy.broadcast_arrays`.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for `ivy.broadcast_arrays`</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays</span>
<span class="sd">        an arbitrary number of arrays to-be broadcasted.</span>
<span class="sd">        Each array must have the same shape.</span>
<span class="sd">        And Each array must have the same dtype as its</span>
<span class="sd">        corresponding input array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list of containers containing broadcasted arrays</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2]), b=ivy.array([3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([-1.2, 0.4]), b=ivy.array([0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_broadcast_arrays(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([1, 2]),</span>
<span class="sd">        b: ivy.array([3, 4])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([-1.2, 0.4]),</span>
<span class="sd">        b: ivy.array([0, 1])</span>
<span class="sd">    }]</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4, 5]), b=ivy.array([2, -1]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0.2, 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_broadcast_arrays(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([4, 5]),</span>
<span class="sd">        b: ivy.array([2, -1])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0.2, 3.]),</span>
<span class="sd">        b: ivy.array([0.2, 3.])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;broadcast_arrays&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arrays</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="broadcast_arrays"><a class="viewcode-back" href="../../../functional/ivy/data_type/broadcast_arrays/broadcast_arrays_container.html#ivy.container.container_methods.broadcast_arrays">[docs]</a><span class="k">def</span> <span class="nf">broadcast_arrays</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.broadcast_arrays`.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for `ivy.broadcast_arrays`</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        A container to be broadcatsed against other input arrays.</span>
<span class="sd">    arrays</span>
<span class="sd">        an arbitrary number of containers having arrays to-be broadcasted.</span>
<span class="sd">        Each array must have the same shape.</span>
<span class="sd">        Each array must have the same dtype as its corresponding input array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2]), b=ivy.array([3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([-1.2, 0.4]), b=ivy.array([0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.broadcast_arrays(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([1, 2]),</span>
<span class="sd">        b: ivy.array([3, 4])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([-1.2, 0.4]),</span>
<span class="sd">        b: ivy.array([0, 1])</span>
<span class="sd">    }]</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4, 5]), b=ivy.array([2, -1]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.zeros(2)</span>
<span class="sd">    &gt;&gt;&gt; y = x1.broadcast_arrays(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([4, 5]),</span>
<span class="sd">        b: ivy.array([2, -1])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0., 0.]),</span>
<span class="sd">        b: ivy.array([0., 0.])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_broadcast_arrays</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arrays</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_broadcast_to"><a class="viewcode-back" href="../../../functional/ivy/data_type/broadcast_to/static_broadcast_to_container.html#ivy.container.container_methods.static_broadcast_to">[docs]</a><span class="k">def</span> <span class="nf">static_broadcast_to</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `ivy.broadcast_to`.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for `ivy.broadcast_to` also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array to be broadcasted.</span>
<span class="sd">    shape</span>
<span class="sd">        desired shape to be broadcasted to.</span>
<span class="sd">    out</span>
<span class="sd">        Optional array to store the broadcasted array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns the broadcasted array of shape &#39;shape&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` static method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1]),</span>
<span class="sd">    ...                   b=ivy.array([2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_broadcast_to(x,(3, 1))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1],</span>
<span class="sd">                     [1],</span>
<span class="sd">                     [1]),</span>
<span class="sd">        b: ivy.array([2],</span>
<span class="sd">                     [2],</span>
<span class="sd">                     [2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;broadcast_to&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="broadcast_to"><a class="viewcode-back" href="../../../functional/ivy/data_type/broadcast_to/broadcast_to_container.html#ivy.container.container_methods.broadcast_to">[docs]</a><span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.broadcast_to`.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for `ivy.broadcast_to` also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to be broadcasted.</span>
<span class="sd">    shape</span>
<span class="sd">        desired shape to be broadcasted to.</span>
<span class="sd">    out</span>
<span class="sd">        Optional array to store the broadcasted array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns the broadcasted array of shape &#39;shape&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 0.5]),</span>
<span class="sd">    ...                   b=ivy.array([4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.broadcast_to((3,2))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0., 0.5],</span>
<span class="sd">                      [0., 0.5],</span>
<span class="sd">                      [0., 0.5]]),</span>
<span class="sd">        b: ivy.array([[4, 5],</span>
<span class="sd">                      [4, 5],</span>
<span class="sd">                      [4, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_broadcast_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_can_cast"><a class="viewcode-back" href="../../../functional/ivy/data_type/can_cast/static_can_cast_container.html#ivy.container.container_methods.static_can_cast">[docs]</a><span class="k">def</span> <span class="nf">static_can_cast</span><span class="p">(</span>
    <span class="n">from_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">to</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `ivy.can_cast`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.can_cast` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    from_</span>
<span class="sd">        input container from which to cast.</span>
<span class="sd">    to</span>
<span class="sd">        desired data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        ``True`` if the cast can occur according to :ref:`type-promotion` rules;</span>
<span class="sd">        otherwise, ``False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    float32 int32</span>

<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_can_cast(x, &#39;int64&#39;))</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;can_cast&quot;</span><span class="p">,</span>
        <span class="n">from_</span><span class="p">,</span>
        <span class="n">to</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="can_cast"><a class="viewcode-back" href="../../../functional/ivy/data_type/can_cast/can_cast_container.html#ivy.container.container_methods.can_cast">[docs]</a><span class="k">def</span> <span class="nf">can_cast</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">to</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.can_cast`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.can_cast` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container from which to cast.</span>
<span class="sd">    to</span>
<span class="sd">        desired data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        ``True`` if the cast can occur according to :ref:`type-promotion` rules;</span>
<span class="sd">        otherwise, ``False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    float32 int32</span>

<span class="sd">    &gt;&gt;&gt; print(x.can_cast(&#39;int64&#39;))</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_can_cast</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">key_chains</span><span class="p">,</span> <span class="n">to_apply</span><span class="p">,</span> <span class="n">prune_unapplied</span><span class="p">,</span> <span class="n">map_sequences</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/dtype/static_dtype_container.html#ivy.container.container_methods.static_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_dtype</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;dtype&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">as_native</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/dtype/dtype_container.html#ivy.container.container_methods.dtype">[docs]</a><span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.dtype()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: int32,</span>
<span class="sd">        b: int32</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_dtype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">as_native</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_default_float_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/default_float_dtype/static_default_float_dtype_container.html#ivy.container.container_methods.static_default_float_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_default_float_dtype</span><span class="p">(</span>
    <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">float_dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">FloatDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">as_native</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;default_float_dtype&quot;</span><span class="p">,</span>
        <span class="nb">input</span><span class="p">,</span>
        <span class="n">float_dtype</span><span class="p">,</span>
        <span class="n">as_native</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_function_supported_dtypes"><a class="viewcode-back" href="../../../functional/ivy/data_type/function_supported_dtypes/static_function_supported_dtypes_container.html#ivy.container.container_methods.static_function_supported_dtypes">[docs]</a><span class="k">def</span> <span class="nf">static_function_supported_dtypes</span><span class="p">(</span>
    <span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;function_supported_dtypes&quot;</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_function_unsupported_dtypes"><a class="viewcode-back" href="../../../functional/ivy/data_type/function_unsupported_dtypes/static_function_unsupported_dtypes_container.html#ivy.container.container_methods.static_function_unsupported_dtypes">[docs]</a><span class="k">def</span> <span class="nf">static_function_unsupported_dtypes</span><span class="p">(</span>
    <span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;function_unsupported_dtypes&quot;</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_finfo"><a class="viewcode-back" href="../../../functional/ivy/data_type/finfo/static_finfo_container.html#ivy.container.container_methods.static_finfo">[docs]</a><span class="k">def</span> <span class="nf">static_finfo</span><span class="p">(</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;finfo&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="finfo"><a class="viewcode-back" href="../../../functional/ivy/data_type/finfo/finfo_container.html#ivy.container.container_methods.finfo">[docs]</a><span class="k">def</span> <span class="nf">finfo</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_finfo</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_iinfo"><a class="viewcode-back" href="../../../functional/ivy/data_type/iinfo/static_iinfo_container.html#ivy.container.container_methods.static_iinfo">[docs]</a><span class="k">def</span> <span class="nf">static_iinfo</span><span class="p">(</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;iinfo&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="iinfo"><a class="viewcode-back" href="../../../functional/ivy/data_type/iinfo/iinfo_container.html#ivy.container.container_methods.iinfo">[docs]</a><span class="k">def</span> <span class="nf">iinfo</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; c = ivy.Container(x=ivy.array([-9,1800,89], dtype=ivy.int16),</span>
<span class="sd">    ...                   y=ivy.array([76,-81,16], dtype=ivy.int32))</span>
<span class="sd">    &gt;&gt;&gt; c.iinfo()</span>
<span class="sd">    {</span>
<span class="sd">        x: iinfo(min=-32768, max=32767, dtype=int16),</span>
<span class="sd">        y: iinfo(min=-2147483648, max=2147483647, dtype=int32)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_iinfo</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_is_bool_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_bool_dtype/static_is_bool_dtype_container.html#ivy.container.container_methods.static_is_bool_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_is_bool_dtype</span><span class="p">(</span>
    <span class="n">dtype_in</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;is_bool_dtype&quot;</span><span class="p">,</span>
        <span class="n">dtype_in</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_bool_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_bool_dtype/is_bool_dtype_container.html#ivy.container.container_methods.is_bool_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_bool_dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_is_bool_dtype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_is_float_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_float_dtype/static_is_float_dtype_container.html#ivy.container.container_methods.static_is_float_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_is_float_dtype</span><span class="p">(</span>
    <span class="n">dtype_in</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `is_float_dtype`. This method</span>
<span class="sd">    simply wraps this function, so the docstring of `is_float_dtype`</span>
<span class="sd">    roughly applies to this method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype_in : ivy.Container</span>
<span class="sd">        The input to check for float dtype.</span>
<span class="sd">    key_chains : Optional[Union[List[str], Dict[str, str]]]</span>
<span class="sd">        The key chains to use when mapping over the input.</span>
<span class="sd">    to_apply : bool</span>
<span class="sd">        Whether to apply the mapping over the input.</span>
<span class="sd">    prune_unapplied : bool</span>
<span class="sd">        Whether to prune the keys that were not applied.</span>
<span class="sd">    map_sequences : bool</span>
<span class="sd">        Boolean indicating whether to map method</span>
<span class="sd">        to sequences (list, tuple). Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : bool</span>
<span class="sd">        Boolean indicating whether the input has float dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.static_is_float_dtype(ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.static_is_float_dtype(ivy.int64)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.static_is_float_dtype(ivy.int32)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.static_is_float_dtype(ivy.bool)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; arr = ivy.array([1.2, 3.2, 4.3], dtype=ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(arr.is_float_dtype())</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    float32 int32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;is_float_dtype&quot;</span><span class="p">,</span>
        <span class="n">dtype_in</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_float_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_float_dtype/is_float_dtype_container.html#ivy.container.container_methods.is_float_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_float_dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.is_float_dtype`.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for `ivy.is_float_dtype`</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self : ivy.Container</span>
<span class="sd">        The `ivy.Container` instance to call `ivy.is_float_dtype` on.</span>
<span class="sd">    key_chains : Union[List[str], Dict[str, str]]</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    to_apply : bool</span>
<span class="sd">        Boolean indicating whether to apply the</span>
<span class="sd">        method to the key-chains. Default is ``False``.</span>
<span class="sd">    prune_unapplied : bool</span>
<span class="sd">        Boolean indicating whether to prune the</span>
<span class="sd">        key-chains that were not applied. Default is ``False``.</span>
<span class="sd">    map_sequences : bool</span>
<span class="sd">        Boolean indicating whether to map method</span>
<span class="sd">        to sequences (list, tuple). Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : bool</span>
<span class="sd">        Boolean of whether the input is of a float dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.is_float_dtype(ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.is_float_dtype(ivy.int64)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.is_float_dtype(ivy.int32)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.is_float_dtype(ivy.bool)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; arr = ivy.array([1.2, 3.2, 4.3], dtype=ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(arr.is_float_dtype())</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    float32 int32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_is_float_dtype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_is_int_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_int_dtype/static_is_int_dtype_container.html#ivy.container.container_methods.static_is_int_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_is_int_dtype</span><span class="p">(</span>
    <span class="n">dtype_in</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;is_int_dtype&quot;</span><span class="p">,</span>
        <span class="n">dtype_in</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_int_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_int_dtype/is_int_dtype_container.html#ivy.container.container_methods.is_int_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_int_dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_is_int_dtype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_is_uint_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_uint_dtype/static_is_uint_dtype_container.html#ivy.container.container_methods.static_is_uint_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_is_uint_dtype</span><span class="p">(</span>
    <span class="n">dtype_in</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;is_uint_dtype&quot;</span><span class="p">,</span>
        <span class="n">dtype_in</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_uint_dtype"><a class="viewcode-back" href="../../../functional/ivy/data_type/is_uint_dtype/is_uint_dtype_container.html#ivy.container.container_methods.is_uint_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_uint_dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_is_uint_dtype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_result_type"><a class="viewcode-back" href="../../../functional/ivy/data_type/result_type/static_result_type_container.html#ivy.container.container_methods.static_result_type">[docs]</a><span class="k">def</span> <span class="nf">static_result_type</span><span class="p">(</span>
    <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `ivy.result_type`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.result_type` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container from which to cast.</span>
<span class="sd">    arrays_and_dtypes</span>
<span class="sd">        an arbitrary number of input arrays and/or dtypes.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the dtype resulting from an operation involving the input arrays and dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([0, 1, 2]),</span>
<span class="sd">    ...                   b = ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    int32 float32</span>

<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_result_type(x, ivy.float64))</span>
<span class="sd">    {</span>
<span class="sd">        a: float64,</span>
<span class="sd">        b: float32</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;result_type&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="result_type"><a class="viewcode-back" href="../../../functional/ivy/data_type/result_type/result_type_container.html#ivy.container.container_methods.result_type">[docs]</a><span class="k">def</span> <span class="nf">result_type</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.result_type`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.result_type` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container from which to cast.</span>
<span class="sd">    arrays_and_dtypes</span>
<span class="sd">        an arbitrary number of input arrays and/or dtypes.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the dtype resulting from an operation involving the input arrays and dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([3, 3, 3]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype)</span>
<span class="sd">    int32</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(b = ivy.float64)</span>
<span class="sd">    &gt;&gt;&gt; print(x.result_type(y))</span>
<span class="sd">    {</span>
<span class="sd">        a: {</span>
<span class="sd">            b: float64</span>
<span class="sd">        }</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_result_type</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.device</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>




<div class="viewcode-block" id="static_dev"><a class="viewcode-back" href="../../../functional/ivy/device/dev/static_dev_container.html#ivy.container.container_methods.static_dev">[docs]</a><span class="k">def</span> <span class="nf">static_dev</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.dev. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.dev also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[2, 3], [3, 5]]),</span>
<span class="sd">    ...                   b=ivy.native_array([1, 2, 4, 5, 7]))</span>
<span class="sd">    &gt;&gt;&gt; as_native = ivy.Container(a=True, b=False)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_dev(x, as_native=as_native)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: device(type=cpu),</span>
<span class="sd">        b: cpu</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span><span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">as_native</span><span class="o">=</span><span class="n">as_native</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">dev</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.dev. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.dev also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[2, 3, 1], [3, 5, 3]]),</span>
<span class="sd">    ...                   b=ivy.native_array([[1, 2], [4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; as_native = ivy.Container(a=False, b=True)</span>
<span class="sd">    &gt;&gt;&gt; y = x.dev(as_native=as_native)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: cpu,</span>
<span class="sd">        b: device(type=cpu)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_dev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_native</span><span class="o">=</span><span class="n">as_native</span><span class="p">)</span>


<div class="viewcode-block" id="static_to_device"><a class="viewcode-back" href="../../../functional/ivy/device/to_device/static_to_device_container.html#ivy.container.container_methods.static_to_device">[docs]</a><span class="k">def</span> <span class="nf">static_to_device</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stream</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_device. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.to_device also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">       input array to be moved to the desired device</span>
<span class="sd">    device</span>
<span class="sd">        device to move the input array `x` to</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    stream</span>
<span class="sd">        stream object to use during copy. In addition to the types supported</span>
<span class="sd">        in array.__dlpack__(), implementations may choose to support any</span>
<span class="sd">        library-specific stream object with the caveat that any code using</span>
<span class="sd">        such an object would not be portable.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        input array x placed on the desired device</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;to_device&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">device</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="to_device"><a class="viewcode-back" href="../../../functional/ivy/device/to_device/to_device_container.html#ivy.container.container_methods.to_device">[docs]</a><span class="k">def</span> <span class="nf">to_device</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stream</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_device. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.to_device also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">       input array to be moved to the desired device</span>
<span class="sd">    device</span>
<span class="sd">        device to move the input array `x` to</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    stream</span>
<span class="sd">        stream object to use during copy. In addition to the types supported</span>
<span class="sd">        in array.__dlpack__(), implementations may choose to support any</span>
<span class="sd">        library-specific stream object with the caveat that any code using</span>
<span class="sd">        such an object would not be portable.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        input array x placed on the desired device</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_to_device</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">device</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.elementwise</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>




<div class="viewcode-block" id="static_abs"><a class="viewcode-back" href="../../../functional/ivy/elementwise/abs/static_abs_container.html#ivy.container.container_methods.static_abs">[docs]</a><span class="k">def</span> <span class="nf">static_abs</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.abs. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.abs also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the absolute value of each element in ``x``. The</span>
<span class="sd">        returned container must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),</span>
<span class="sd">    ...                   b=ivy.array([4.5, -5.3, -0, -2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_abs(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 2.6, 3.5]),</span>
<span class="sd">        b: ivy.array([4.5, 5.3, 0, 2.3])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;abs&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="abs"><a class="viewcode-back" href="../../../functional/ivy/elementwise/abs/abs_container.html#ivy.container.container_methods.abs">[docs]</a><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.abs. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.abs also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the absolute value of each element in ``self``. The</span>
<span class="sd">        returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1.6, 2.6, -3.5]),</span>
<span class="sd">    ...                   b=ivy.array([4.5, -5.3, -2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.abs()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.6, 2.6, 3.5]),</span>
<span class="sd">        b: ivy.array([4.5, 5.3, 2.3])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_abs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_acosh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/acosh/static_acosh_container.html#ivy.container.container_methods.static_acosh">[docs]</a><span class="k">def</span> <span class="nf">static_acosh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cosh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cosh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic cosine of each element</span>
<span class="sd">        in ``x``. The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 2., 3, 4]),</span>
<span class="sd">    ...                   b=ivy.array([1., 3., 10.0, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_acosh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.32, 1.76, 2.06]),</span>
<span class="sd">        b: ivy.array([0., 1.76, 2.99, 2.48])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;acosh&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="acosh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/acosh/acosh_container.html#ivy.container.container_methods.acosh">[docs]</a><span class="k">def</span> <span class="nf">acosh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.acosh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.acosh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic cosine of each element in</span>
<span class="sd">        ``self``. The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 2., 3, 4]),</span>
<span class="sd">    ...                   b=ivy.array([1., 3., 10.0, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.acosh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.32, 1.76, 2.06]),</span>
<span class="sd">        b: ivy.array([0., 1.76, 2.99, 2.48])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_acosh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_acos"><a class="viewcode-back" href="../../../functional/ivy/elementwise/acos/static_acos_container.html#ivy.container.container_methods.static_acos">[docs]</a><span class="k">def</span> <span class="nf">static_acos</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.acos.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.acos also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse cosine of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_acos(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.57, 3.14, 0.]),</span>
<span class="sd">        b: ivy.array([0., 1.57, 3.14])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;acos&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_add"><a class="viewcode-back" href="../../../functional/ivy/elementwise/add/static_add_container.html#ivy.container.container_methods.static_add">[docs]</a><span class="k">def</span> <span class="nf">static_add</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.add.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.add also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    alpha</span>
<span class="sd">        scalar multiplier for ``x2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[4.], [5.], [6.]]),</span>
<span class="sd">    ...                   b=ivy.array([[5.], [6.], [7.]]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_add(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[5.1, 6.3, 0.4],</span>
<span class="sd">                      [6.1, 7.3, 1.4],</span>
<span class="sd">                      [7.1, 8.3, 2.4]]),</span>
<span class="sd">        b: ivy.array([[6.1, 7.3, 1.4],</span>
<span class="sd">                      [7.1, 8.3, 2.4],</span>
<span class="sd">                      [8.1, 9.3, 3.4]])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_add(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 9]),</span>
<span class="sd">        b: ivy.array([7, 9, 11])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_add(x, y, alpha=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9, 12, 15]),</span>
<span class="sd">        b: ivy.array([12, 15, 18])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;add&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="acos"><a class="viewcode-back" href="../../../functional/ivy/elementwise/acos/acos_container.html#ivy.container.container_methods.acos">[docs]</a><span class="k">def</span> <span class="nf">acos</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.acos.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.acos also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse cosine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.acos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.57, 3.14, 0.]),</span>
<span class="sd">        b: ivy.array([0., 1.57, 3.14])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_acos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../../functional/ivy/elementwise/add/add_container.html#ivy.container.container_methods.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.add.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.add also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    alpha</span>
<span class="sd">        scalar multiplier for ``x2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.add(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 9]),</span>
<span class="sd">        b: ivy.array([7, 9, 11])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = x.add(y, alpha=3)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([13, 17, 21]),</span>
<span class="sd">        b: ivy.array([17, 21, 25])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_add</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_asin"><a class="viewcode-back" href="../../../functional/ivy/elementwise/asin/static_asin_container.html#ivy.container.container_methods.static_asin">[docs]</a><span class="k">def</span> <span class="nf">static_asin</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.asin.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.asin also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse sine of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -0.5, -1.]),</span>
<span class="sd">    ...                   b=ivy.array([0.1, 0.8, 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_asin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., -0.524, -1.57]),</span>
<span class="sd">        b: ivy.array([0.1, 0.927, nan])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.4, 0.9, -0.9]),</span>
<span class="sd">    ...                   b=ivy.array([[4, -3, -0.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(3), b=ivy.zeros(3))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_asin(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.412, 1.12, -1.12]),</span>
<span class="sd">        b: ivy.array([nan, nan, -0.201])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;asin&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="asin"><a class="viewcode-back" href="../../../functional/ivy/elementwise/asin/asin_container.html#ivy.container.container_methods.asin">[docs]</a><span class="k">def</span> <span class="nf">asin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.asin.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.asin also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse sine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 0.5, 1.]),</span>
<span class="sd">    ...                   b=ivy.array([-4., 0.8, 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.asin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.524, 1.57]),</span>
<span class="sd">        b: ivy.array([nan, 0.927, nan])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([12., 1.5, 0.]),</span>
<span class="sd">    ...                   b=ivy.array([-0.85, 0.6, 0.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(3), b=ivy.zeros(3))</span>
<span class="sd">    &gt;&gt;&gt; x.asin(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([nan, nan, 0.]),</span>
<span class="sd">        b: ivy.array([-1.02, 0.644, 0.305])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_asin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_asinh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/asinh/static_asinh_container.html#ivy.container.container_methods.static_asinh">[docs]</a><span class="k">def</span> <span class="nf">static_asinh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.asinh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.asinh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic sine of each element</span>
<span class="sd">        in ``x``. The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.5, 0., -3.5]),</span>
<span class="sd">    ...                   b=ivy.array([3.4, -5.3, -0, -2.8]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_asinh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.19, 0., -1.97]),</span>
<span class="sd">        b: ivy.array([1.94, -2.37, 0., -1.75])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;asinh&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="asinh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/asinh/asinh_container.html#ivy.container.container_methods.asinh">[docs]</a><span class="k">def</span> <span class="nf">asinh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.asinh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.asinh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic sine of each element in</span>
<span class="sd">        ``self``. The returned container must have a floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 3.7, -5.1]),</span>
<span class="sd">    ...                   b=ivy.array([4.5, -2.4, -1.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.asinh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0.881, 2.02, -2.33]),</span>
<span class="sd">        b: ivy.array([2.21, -1.61, -1.19])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_asinh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_atan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atan/static_atan_container.html#ivy.container.container_methods.static_atan">[docs]</a><span class="k">def</span> <span class="nf">static_atan</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.atan. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.atan also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse tangent of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_atan(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., -0.785, 0.785]),</span>
<span class="sd">        b: ivy.array([0.785, 0., -1.41])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;atan&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="atan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atan/atan_container.html#ivy.container.container_methods.atan">[docs]</a><span class="k">def</span> <span class="nf">atan</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.atan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.atan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse tangent of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.atan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., -0.785, 0.785]),</span>
<span class="sd">        b: ivy.array([0.785, 0., -1.41])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_atan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_atan2"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atan2/static_atan2_container.html#ivy.container.container_methods.static_atan2">[docs]</a><span class="k">def</span> <span class="nf">static_atan2</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.atan2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.atan2 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container corresponding to the y-coordinates.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container corresponding to the x-coordinates.</span>
<span class="sd">        Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a real-valued</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse tangent of the quotient ``x1/x2``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),</span>
<span class="sd">    ...                   b=ivy.array([4.5, -5.3, -0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3.0, 2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_atan2(x, y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.915, -1.29]),</span>
<span class="sd">        b: ivy.array([0.983, -1.21, 0.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),</span>
<span class="sd">    ...                   b=ivy.array([4.5, -5.3, -0, -2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([-2.5, 1.75, 3.5]),</span>
<span class="sd">    ...                   b=ivy.array([2.45, 6.35, 0, 1.5]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_atan2(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3.14, 0.978, -0.785]),</span>
<span class="sd">        b: ivy.array([1.07, -0.696, 0., -0.993])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;atan2&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="atan2"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atan2/atan2_container.html#ivy.container.container_methods.atan2">[docs]</a><span class="k">def</span> <span class="nf">atan2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.atan2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.atan2</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container corresponding to the y-coordinates.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container corresponding to the x-coordinates.</span>
<span class="sd">        Must be compatible with ``self`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse tangent of the quotient ``self/x2``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),</span>
<span class="sd">    ...                   b=ivy.array([4.5, -5.3, -0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3.0, 2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x.atan2(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.915, -1.29]),</span>
<span class="sd">        b: ivy.array([0.983, -1.21, 0.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),</span>
<span class="sd">    ...                   b=ivy.array([4.5, -5.3, -0, -2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([-2.5, 1.75, 3.5]),</span>
<span class="sd">    ...                   b=ivy.array([2.45, 6.35, 0, 1.5]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.atan2(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3.14, 0.978, -0.785]),</span>
<span class="sd">        b: ivy.array([1.07, -0.696, 0., -0.993])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_atan2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_atanh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atanh/static_atanh_container.html#ivy.container.container_methods.static_atanh">[docs]</a><span class="k">def</span> <span class="nf">static_atanh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.atanh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.atanh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic tangent of each</span>
<span class="sd">        element in ``x``. The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 0.5, -0.5]), b=ivy.array([0., 0.2, 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_atanh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.549, -0.549]),</span>
<span class="sd">        b: ivy.array([0., 0.203, 1.47])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;atanh&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="atanh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/atanh/atanh_container.html#ivy.container.container_methods.atanh">[docs]</a><span class="k">def</span> <span class="nf">atanh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.atanh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.atanh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent the area of a</span>
<span class="sd">        hyperbolic sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic tangent of each element</span>
<span class="sd">        in ``self``. The returned container must have a floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 0.5, -0.5]), b=ivy.array([0., 0.2, 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.atanh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.549, -0.549]),</span>
<span class="sd">        b: ivy.array([0., 0.203, 1.47])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_atanh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_bitwise_and"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_and/static_bitwise_and_container.html#ivy.container.container_methods.static_bitwise_and">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_and</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;bitwise_and&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_and"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_and/bitwise_and_container.html#ivy.container.container_methods.bitwise_and">[docs]</a><span class="k">def</span> <span class="nf">bitwise_and</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([True, True]), b=ivy.array([False, True]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([False, True]), b=ivy.array([False, True]))</span>
<span class="sd">    &gt;&gt;&gt; x.bitwise_and(y, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True]),</span>
<span class="sd">        b: ivy.array([False, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_bitwise_and</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_bitwise_left_shift"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_left_shift/static_bitwise_left_shift_container.html#ivy.container.container_methods.static_bitwise_left_shift">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_left_shift</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_left_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_left_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;bitwise_left_shift&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_left_shift"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_left_shift/bitwise_left_shift_container.html#ivy.container.container_methods.bitwise_left_shift">[docs]</a><span class="k">def</span> <span class="nf">bitwise_left_shift</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_left_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_left_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_bitwise_left_shift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_bitwise_invert"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_invert/static_bitwise_invert_container.html#ivy.container.container_methods.static_bitwise_invert">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_invert</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_invert.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_invert also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;bitwise_invert&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_invert"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_invert/bitwise_invert_container.html#ivy.container.container_methods.bitwise_invert">[docs]</a><span class="k">def</span> <span class="nf">bitwise_invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_invert.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_invert also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_bitwise_invert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_cos"><a class="viewcode-back" href="../../../functional/ivy/elementwise/cos/static_cos_container.html#ivy.container.container_methods.static_cos">[docs]</a><span class="k">def</span> <span class="nf">static_cos</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cos.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.cos also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the cosine of each element in ``x``. The returned</span>
<span class="sd">        container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cos(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 0.54, 0.54]),</span>
<span class="sd">        b: ivy.array([0.54, 1., 0.96])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;cos&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cos"><a class="viewcode-back" href="../../../functional/ivy/elementwise/cos/cos_container.html#ivy.container.container_methods.cos">[docs]</a><span class="k">def</span> <span class="nf">cos</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cos.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.cos also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the cosine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 0.54, 0.54]),</span>
<span class="sd">        b: ivy.array([0.54, 1., 0.96])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_cos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_bitwise_or"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_or/static_bitwise_or_container.html#ivy.container.container_methods.static_bitwise_or">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_or</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_or. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.bitwise_or also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_bitwise_or(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 7]),</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_bitwise_or(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 7]),</span>
<span class="sd">        b: ivy.array([7, 7, 7])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;bitwise_or&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_or"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_or/bitwise_or_container.html#ivy.container.container_methods.bitwise_or">[docs]</a><span class="k">def</span> <span class="nf">bitwise_or</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_or. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.bitwise_or also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.bitwise_or(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 7]),</span>
<span class="sd">        b: ivy.array([7, 7, 7])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_bitwise_or</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_bitwise_right_shift"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_right_shift/static_bitwise_right_shift_container.html#ivy.container.container_methods.static_bitwise_right_shift">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_right_shift</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_right_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_right_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(a = ivy.array([2, 3, 4]), b = ivy.array([5, 10, 64]))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_bitwise_right_shift(a, b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 1, 1]),</span>
<span class="sd">        b: ivy.array([5, 5, 16])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.Container(a = ivy.array([2, 3, 4]), b = ivy.array([5, 10, 64]))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(a = ivy.array([0, 1, 2]), b = ivy.array([2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_bitwise_right_shift(a, b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 1, 1]),</span>
<span class="sd">        b: ivy.array([1, 2, 16])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;bitwise_right_shift&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_right_shift"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_right_shift/bitwise_right_shift_container.html#ivy.container.container_methods.bitwise_right_shift">[docs]</a><span class="k">def</span> <span class="nf">bitwise_right_shift</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_right_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_right_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(a = ivy.array([2, 3, 4]), b = ivy.array([5, 10, 64]))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(a = ivy.array([0, 1, 2]), b = ivy.array([2]))</span>
<span class="sd">    &gt;&gt;&gt; y = a.bitwise_right_shift(b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 1, 1]),</span>
<span class="sd">        b: ivy.array([1, 2, 16])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_bitwise_right_shift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_bitwise_xor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_xor/static_bitwise_xor_container.html#ivy.container.container_methods.static_bitwise_xor">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_xor</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;bitwise_xor&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_xor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/bitwise_xor/bitwise_xor_container.html#ivy.container.container_methods.bitwise_xor">[docs]</a><span class="k">def</span> <span class="nf">bitwise_xor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.bitwise_xor</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have an integer or</span>
<span class="sd">        boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([89]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.array([12]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.bitwise_xor(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {a:ivy.array([85])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_bitwise_xor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_ceil"><a class="viewcode-back" href="../../../functional/ivy/elementwise/ceil/static_ceil_container.html#ivy.container.container_methods.static_ceil">[docs]</a><span class="k">def</span> <span class="nf">static_ceil</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.ceil.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.ceil</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the rounded result for each element in ``x``.</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;ceil&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="ceil"><a class="viewcode-back" href="../../../functional/ivy/elementwise/ceil/ceil_container.html#ivy.container.container_methods.ceil">[docs]</a><span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.ceil.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ceil also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2.5, 0.5, -1.4]),</span>
<span class="sd">    ...                   b=ivy.array([5.4, -3.2, 5.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.ceil()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3., 1., -1.]),</span>
<span class="sd">        b: ivy.array([6., -3., 6.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_ceil</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_cosh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/cosh/static_cosh_container.html#ivy.container.container_methods.static_cosh">[docs]</a><span class="k">def</span> <span class="nf">static_cosh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cosh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cosh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle. Should</span>
<span class="sd">        have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the hyperbolic cosine of each element in ``x``. The</span>
<span class="sd">        returned container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0.23, 1.12]), b=ivy.array([1, -2, 0.76]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cosh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.54, 1.03, 1.7]),</span>
<span class="sd">        b: ivy.array([1.54, 3.76, 1.3])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-3, 0.34, 2.]),</span>
<span class="sd">    ...                   b=ivy.array([0.67, -0.98, -3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(1), b=ivy.zeros(1))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_cosh(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10.1, 1.06, 3.76]),</span>
<span class="sd">        b: ivy.array([1.23, 1.52, 10.1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;cosh&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cosh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/cosh/cosh_container.html#ivy.container.container_methods.cosh">[docs]</a><span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cosh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cosh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle. Should</span>
<span class="sd">        have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the hyperbolic cosine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0.23, 1.12]), b=ivy.array([1, -2, 0.76]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cosh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.54, 1.03, 1.7]),</span>
<span class="sd">        b: ivy.array([1.54, 3.76, 1.3])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-3, 0.34, 2.]),</span>
<span class="sd">    ...                   b=ivy.array([0.67, -0.98, -3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(3), b=ivy.zeros(3))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.cosh(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10.1, 1.06, 3.76]),</span>
<span class="sd">        b: ivy.array([1.23, 1.52, 10.1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_cosh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/divide/static_divide_container.html#ivy.container.container_methods.static_divide">[docs]</a><span class="k">def</span> <span class="nf">static_divide</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.divide. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.divide also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        dividend input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2.3, 3]), b=ivy.array([2.4, 3., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_divide(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12., 1.52, 2.1]),</span>
<span class="sd">        b: ivy.array([1.25, 0.333, 0.45])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;divide&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/divide/divide_container.html#ivy.container.container_methods.divide">[docs]</a><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.divide also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array or container. Should have a real-valued</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2.3, 3]), b=ivy.array([2.4, 3., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12., 1.52, 2.1]),</span>
<span class="sd">        b: ivy.array([1.25, 0.333, 0.45])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_divide</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/equal/static_equal_container.html#ivy.container.container_methods.static_equal">[docs]</a><span class="k">def</span> <span class="nf">static_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;equal&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/equal/equal_container.html#ivy.container.container_methods.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12, 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12, 2.3, 3]), b=ivy.array([2.4, 3., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, False]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 1., 0.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_equal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_exp"><a class="viewcode-back" href="../../../functional/ivy/elementwise/exp/static_exp_container.html#ivy.container.container_methods.static_exp">[docs]</a><span class="k">def</span> <span class="nf">static_exp</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.exp. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.exp also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;exp&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="exp"><a class="viewcode-back" href="../../../functional/ivy/elementwise/exp/exp_container.html#ivy.container.container_methods.exp">[docs]</a><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.exp.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.exp also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_exp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_expm1"><a class="viewcode-back" href="../../../functional/ivy/elementwise/expm1/static_expm1_container.html#ivy.container.container_methods.static_expm1">[docs]</a><span class="k">def</span> <span class="nf">static_expm1</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.expm1.</span>
<span class="sd">    This method simply wraps thefunction, and so the docstring</span>
<span class="sd">    for ivy.expm1 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned array must have areal-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;expm1&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="expm1"><a class="viewcode-back" href="../../../functional/ivy/elementwise/expm1/expm1_container.html#ivy.container.container_methods.expm1">[docs]</a><span class="k">def</span> <span class="nf">expm1</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.expm1.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.expm1 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2.5, 0.5]),</span>
<span class="sd">    ...                   b=ivy.array([5.4, -3.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.expm1()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([11.2, 0.649]),</span>
<span class="sd">        b: ivy.array([220., -0.959])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4., -2.]))</span>
<span class="sd">    &gt;&gt;&gt; _ = x.expm1(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([53.6, -0.865])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_expm1</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_floor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/floor/static_floor_container.html#ivy.container.container_methods.static_floor">[docs]</a><span class="k">def</span> <span class="nf">static_floor</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.floor.</span>
<span class="sd">    This method simply wraps thefunction, and so the docstring for</span>
<span class="sd">    ivy.floor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``x``. The</span>
<span class="sd">        returned array must have the same data type as ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;floor&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="floor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/floor/floor_container.html#ivy.container.container_methods.floor">[docs]</a><span class="k">def</span> <span class="nf">floor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.floor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.floor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2.5, 0.5, -1.4]),</span>
<span class="sd">    ...                   b=ivy.array([5.4, -3.2, 5.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.floor()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0., -2.]),</span>
<span class="sd">        b: ivy.array([5., -4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_floor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_floor_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/floor_divide/static_floor_divide_container.html#ivy.container.container_methods.static_floor_divide">[docs]</a><span class="k">def</span> <span class="nf">static_floor_divide</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.floor_divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.floor_divide also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        dividend input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4., 5., 6.]), b=ivy.array([7., 8., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([5., 4., 2.5]), b=ivy.array([2.3, 3.7, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_floor_divide(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 2., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4., 5., 6.]), b=ivy.array([7., 8., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_floor_divide(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 1., 1.]),</span>
<span class="sd">        b: ivy.array([3., 2., 2.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;floor_divide&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="floor_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/floor_divide/floor_divide_container.html#ivy.container.container_methods.floor_divide">[docs]</a><span class="k">def</span> <span class="nf">floor_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.floor_divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.floor_divide also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array or container. Should have a real-valued</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4., 5., 6.]), b=ivy.array([7., 8., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([5., 4., 2.5]), b=ivy.array([2.3, 3.7, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.floor_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 2., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4., 5., 6.]), b=ivy.array([7., 8., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.floor_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 1., 1.]),</span>
<span class="sd">        b: ivy.array([3., 2., 2.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_floor_divide</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_greater"><a class="viewcode-back" href="../../../functional/ivy/elementwise/greater/static_greater_container.html#ivy.container.container_methods.static_greater">[docs]</a><span class="k">def</span> <span class="nf">static_greater</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.greater.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.greater also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned array must</span>
<span class="sd">        have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_greater(y,x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;greater&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../../functional/ivy/elementwise/greater/greater_container.html#ivy.container.container_methods.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.greater.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned array must</span>
<span class="sd">        have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.greater(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_greater</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_greater_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/greater_equal/static_greater_equal_container.html#ivy.container.container_methods.static_greater_equal">[docs]</a><span class="k">def</span> <span class="nf">static_greater_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;greater_equal&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="greater_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/greater_equal/greater_equal_container.html#ivy.container.container_methods.greater_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this metho with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_greater_equal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_isfinite"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isfinite/static_isfinite_container.html#ivy.container.container_methods.static_isfinite">[docs]</a><span class="k">def</span> <span class="nf">static_isfinite</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isfinite.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isfinite also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``x_i`` is finite and ``False`` otherwise.</span>
<span class="sd">        The returned array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 999999999999]),</span>
<span class="sd">    ...                   b=ivy.array([float(&#39;-0&#39;), ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_isfinite(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True]),</span>
<span class="sd">        b: ivy.array([True, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;isfinite&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isfinite"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isfinite/isfinite_container.html#ivy.container.container_methods.isfinite">[docs]</a><span class="k">def</span> <span class="nf">isfinite</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isfinite.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isfinite also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is finite and ``False`` otherwise.</span>
<span class="sd">        The returned array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 999999999999]),</span>
<span class="sd">    ...                   b=ivy.array([float(&#39;-0&#39;), ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.isfinite()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True]),</span>
<span class="sd">        b: ivy.array([True, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_isfinite</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_isinf"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isinf/static_isinf_container.html#ivy.container.container_methods.static_isinf">[docs]</a><span class="k">def</span> <span class="nf">static_isinf</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isinf.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isinf also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``x_i`` is either positive or negative infinity and ``False``</span>
<span class="sd">        otherwise. The returned array must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;isinf&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isinf"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isinf/isinf_container.html#ivy.container.container_methods.isinf">[docs]</a><span class="k">def</span> <span class="nf">isinf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isinf.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isinf also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is either positive or negative infinity and ``False``</span>
<span class="sd">        otherwise. The returned array must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_isinf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_isnan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isnan/static_isnan_container.html#ivy.container.container_methods.static_isnan">[docs]</a><span class="k">def</span> <span class="nf">static_isnan</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isnan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isnan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``x_i`` is ``NaN`` and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;isnan&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isnan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isnan/isnan_container.html#ivy.container.container_methods.isnan">[docs]</a><span class="k">def</span> <span class="nf">isnan</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isnan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.isnan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is ``NaN`` and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_isnan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_less"><a class="viewcode-back" href="../../../functional/ivy/elementwise/less/static_less_container.html#ivy.container.container_methods.static_less">[docs]</a><span class="k">def</span> <span class="nf">static_less</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.less.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">     ivy.less also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_less(y,x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;less&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="less"><a class="viewcode-back" href="../../../functional/ivy/elementwise/less/less_container.html#ivy.container.container_methods.less">[docs]</a><span class="k">def</span> <span class="nf">less</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.less.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.less also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.less(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_less</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_less_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/less_equal/static_less_equal_container.html#ivy.container.container_methods.static_less_equal">[docs]</a><span class="k">def</span> <span class="nf">static_less_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.less_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.less_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;less_equal&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="less_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/less_equal/less_equal_container.html#ivy.container.container_methods.less_equal">[docs]</a><span class="k">def</span> <span class="nf">less_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.less_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.less_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    With :code:&#39;ivy.Container&#39; inputs:</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12, 3.5, 9.2]), b=ivy.array([2., 1.1, 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12, 2.2, 4.1]), b=ivy.array([1, 0.7, 3.8]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, False]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :code:&#39;ivy.Container&#39; and :code:&#39;ivy.Array&#39; inputs:</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 9.2]), b=ivy.array([2., 1., 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2., 1.1, 5.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_less_equal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_log"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log/static_log_container.html#ivy.container.container_methods.static_log">[docs]</a><span class="k">def</span> <span class="nf">static_log</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the log for each element in ``x``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, float(&#39;nan&#39;)]),</span>
<span class="sd">    ...                   b=ivy.array([-0., -3.9, float(&#39;+inf&#39;)]),</span>
<span class="sd">    ...                   c=ivy.array([7.9, 1.1, 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_log(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-inf, nan]),</span>
<span class="sd">        b: ivy.array([-inf, nan, inf]),</span>
<span class="sd">        c: ivy.array([2.07, 0.0953, 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;log&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log/log_container.html#ivy.container.container_methods.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the log for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, float(&#39;nan&#39;)]),</span>
<span class="sd">    ...                   b=ivy.array([-0., -3.9, float(&#39;+inf&#39;)]),</span>
<span class="sd">    ...                   c=ivy.array([7.9, 1.1, 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.log()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-inf, nan]),</span>
<span class="sd">        b: ivy.array([-inf, nan, inf]),</span>
<span class="sd">        c: ivy.array([2.07, 0.0953, 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_log</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_log1p"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log1p/static_log1p_container.html#ivy.container.container_methods.static_log1p">[docs]</a><span class="k">def</span> <span class="nf">static_log1p</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log1p.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log1p also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_log1p(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.693, 1.1]),</span>
<span class="sd">        b: ivy.array([1.39, 1.61, 1.81])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.]), b=ivy.array([ 4., 5.1]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_log1p(x , out = x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.693, 1.1]),</span>
<span class="sd">        b: ivy.array([1.39, 1.61, 1.81])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;log1p&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log1p"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log1p/log1p_container.html#ivy.container.container_methods.log1p">[docs]</a><span class="k">def</span> <span class="nf">log1p</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log1p.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log1p also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.6, 2.6, 3.5]),</span>
<span class="sd">    ...                   b=ivy.array([4.5, 5.3, 2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.log1p()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.956, 1.28, 1.5]),</span>
<span class="sd">        b: ivy.array([1.7, 1.84, 1.19])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_log1p</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_log2"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log2/static_log2_container.html#ivy.container.container_methods.static_log2">[docs]</a><span class="k">def</span> <span class="nf">static_log2</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log2 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated base ``2`` logarithm for</span>
<span class="sd">        each element in ``x``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;log2&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log2"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log2/log2_container.html#ivy.container.container_methods.log2">[docs]</a><span class="k">def</span> <span class="nf">log2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log2 also applies to this metho with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated base ``2`` logarithm for each</span>
<span class="sd">        element in ``self``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_log2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_log10"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log10/static_log10_container.html#ivy.container.container_methods.static_log10">[docs]</a><span class="k">def</span> <span class="nf">static_log10</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log10.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log10 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated base ``10`` logarithm for each</span>
<span class="sd">        element in ``x``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, float(&#39;nan&#39;)]),</span>
<span class="sd">    ...                   b=ivy.array([-0., -3.9, float(&#39;+inf&#39;)]),</span>
<span class="sd">    ...                   c=ivy.array([7.9, 1.1, 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_log10(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-inf, nan]),</span>
<span class="sd">        b: ivy.array([-inf, nan, inf]),</span>
<span class="sd">        c: ivy.array([0.898, 0.0414, 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;log10&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log10"><a class="viewcode-back" href="../../../functional/ivy/elementwise/log10/log10_container.html#ivy.container.container_methods.log10">[docs]</a><span class="k">def</span> <span class="nf">log10</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log10.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log10 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated base ``10`` logarithm for</span>
<span class="sd">        each element in ``self``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, float(&#39;nan&#39;)]),</span>
<span class="sd">    ...                   b=ivy.array([-0., -3.9, float(&#39;+inf&#39;)]),</span>
<span class="sd">    ...                   c=ivy.array([7.9, 1.1, 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.log10()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-inf, nan]),</span>
<span class="sd">        b: ivy.array([-inf, nan, inf]),</span>
<span class="sd">        c: ivy.array([0.898, 0.0414, 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_log10</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_logaddexp"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logaddexp/static_logaddexp_container.html#ivy.container.container_methods.static_logaddexp">[docs]</a><span class="k">def</span> <span class="nf">static_logaddexp</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a real-valued floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4., 5., .]),</span>
<span class="sd">    ...                   b=ivy.array([2., 3., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1., 2., 3.]),</span>
<span class="sd">    ...                   b=ivy.array([5., 6., 7.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logaddexp(y,x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4.05, 5.05, 6.05]),</span>
<span class="sd">        b: ivy.array([5.05, 6.05, 7.05])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;logaddexp&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logaddexp"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logaddexp/logaddexp_container.html#ivy.container.container_methods.logaddexp">[docs]</a><span class="k">def</span> <span class="nf">logaddexp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a real-valued floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4., 5., 6.]),</span>
<span class="sd">    ...                   b=ivy.array([2., 3., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1., 2., 3.]),</span>
<span class="sd">    ...                   b=ivy.array([5., 6., 7.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.logaddexp(y,x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4.05, 5.05, 6.05]),</span>
<span class="sd">        b: ivy.array([5.05, 6.05, 7.05])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_logaddexp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_logical_and"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_and/static_logical_and_container.html#ivy.container.container_methods.static_logical_and">[docs]</a><span class="k">def</span> <span class="nf">static_logical_and</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logical_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using &#39;ivy.Container&#39; instance</span>
<span class="sd">    &gt;&gt;&gt; i = ivy.Container(a=ivy.array([True, False, True, False]))</span>
<span class="sd">    &gt;&gt;&gt; j = ivy.Container(a=ivy.array([True, True, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; k = ivy.Container(a=ivy.array([True, False, True]),</span>
<span class="sd">    ...                   b=ivy.array([True, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; l = ivy.Container(a=ivy.array([True, True, True]),</span>
<span class="sd">    ...                   b=ivy.array([False, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.array([False, True, False, True])</span>
<span class="sd">    &gt;&gt;&gt; n = ivy.array([True, False, True, False])</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container.static_logical_and(i, j)</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container.static_logical_and(j, m)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_logical_and(m, n)</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logical_and(k, l)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">        ivy.array([False, False, False, False])</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;logical_and&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logical_and"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_and/logical_and_container.html#ivy.container.container_methods.logical_and">[docs]</a><span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.logical_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using &#39;ivy.Container&#39; instance</span>
<span class="sd">    &gt;&gt;&gt; i = ivy.Container(a=ivy.array([True, False, True, False]))</span>
<span class="sd">    &gt;&gt;&gt; j = ivy.Container(a=ivy.array([True, True, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; k = ivy.Container(a=ivy.array([True, False, True]),</span>
<span class="sd">    ...                   b=ivy.array([True, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; l = ivy.Container(a=ivy.array([True, True, True]),</span>
<span class="sd">    ...                   b=ivy.array([False, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.array([False, True, False, True])</span>
<span class="sd">    &gt;&gt;&gt; n = ivy.array([True, False, True, False])</span>
<span class="sd">    &gt;&gt;&gt; w = i.logical_and(j)</span>
<span class="sd">    &gt;&gt;&gt; x = j.logical_and(m)</span>
<span class="sd">    &gt;&gt;&gt; y = m.logical_and(n)</span>
<span class="sd">    &gt;&gt;&gt; z = k.logical_and(l)</span>
<span class="sd">    &gt;&gt;&gt; print(w)</span>
<span class="sd">    {a:ivy.array([True,False,False,False])}</span>

<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {a:ivy.array([False,True,False,False])}</span>

<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">        ivy.array([False, False, False, False])</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {a:ivy.array([True,False,True]),b:ivy.array([False,False,False])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_logical_and</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_logical_not"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_not/static_logical_not_container.html#ivy.container.container_methods.static_logical_not">[docs]</a><span class="k">def</span> <span class="nf">static_logical_not</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logical_not.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_not also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned container must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;logical_not&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logical_not"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_not/logical_not_container.html#ivy.container.container_methods.logical_not">[docs]</a><span class="k">def</span> <span class="nf">logical_not</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.logical_not.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_not also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned container must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_logical_not</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_logical_or"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_or/static_logical_or_container.html#ivy.container.container_methods.static_logical_or">[docs]</a><span class="k">def</span> <span class="nf">static_logical_or</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logical_or.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_or also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([False, False, True]),</span>
<span class="sd">    ...                   b=ivy.array([True, False, True]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([False, True, False]),</span>
<span class="sd">    ...                   b=ivy.array([True, True, False]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logical_or(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, True]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;logical_or&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logical_or"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_or/logical_or_container.html#ivy.container.container_methods.logical_or">[docs]</a><span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.logical_or.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_or also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    This function conforms to the `Array API Standard</span>
<span class="sd">    &lt;https://data-apis.org/array-api/latest/&gt;`_. This docstring is an extension of the</span>
<span class="sd">    `docstring &lt;https://data-apis.org/array-api/latest/API_specification/generated/signatures.elementwise_functions.logical_or.html&gt;`_ </span>
<span class="sd">    in the standard.</span>
<span class="sd">    Both the description and the type hints above assumes an array input for simplicity,</span>
<span class="sd">    but this function is *nestable*, and therefore also accepts :class:`ivy.Container`</span>
<span class="sd">    instances in place of any of the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([False,True,True]), b=ivy.array([3.14, 2.718, 1.618]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0, 5.2, 0.8]), b=ivy.array([0.2, 0, 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_or(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, True]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_logical_or</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_logical_xor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_xor/static_logical_xor_container.html#ivy.container.container_methods.static_logical_xor">[docs]</a><span class="k">def</span> <span class="nf">static_logical_xor</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logical_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([0,0,1,1,0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1,0,0,1,0]), b=ivy.array([1,0,1,0,0]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logical_xor(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, True, False, False]),</span>
<span class="sd">        b: ivy.array([True, False, False, True, False])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1,0,0,1,0]), b=ivy.array([1,0,1,0,0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0,0,1,1,0]), b=ivy.array([1,0,1,1,0]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logical_xor(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, True, False, False]),</span>
<span class="sd">        b: ivy.array([False, False, False, True, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;logical_xor&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logical_xor"><a class="viewcode-back" href="../../../functional/ivy/elementwise/logical_xor/logical_xor_container.html#ivy.container.container_methods.logical_xor">[docs]</a><span class="k">def</span> <span class="nf">logical_xor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.logical_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1,0,0,1,0]), b=ivy.array([1,0,1,0,0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0,0,1,1,0]), b=ivy.array([1,0,1,1,0]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_xor(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, True, False, False]),</span>
<span class="sd">        b: ivy.array([False, False, False, True, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_logical_xor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_multiply"><a class="viewcode-back" href="../../../functional/ivy/elementwise/multiply/static_multiply_container.html#ivy.container.container_methods.static_multiply">[docs]</a><span class="k">def</span> <span class="nf">static_multiply</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.multiply.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.multiply also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;multiply&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="multiply"><a class="viewcode-back" href="../../../functional/ivy/elementwise/multiply/multiply_container.html#ivy.container.container_methods.multiply">[docs]</a><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.multiply.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.multiply also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self (Container)</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2 (Union[Container, Array, NativeArray])</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains (Optional[Union[List[str], Dict[str, str]]])</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply (bool)</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied (bool)</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences (bool)</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out (Optional[Container])</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>
<span class="sd">    Return type: Container</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise products.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([15., 4.5, 6.5]),\</span>
<span class="sd">                           b=ivy.array([3.2, 5., 7.5]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1.7, 2.8, 3.]),\</span>
<span class="sd">                           b=ivy.array([5.6, 1.2, 4.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.multiply(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([25.5, 12.6, 19.5]),</span>
<span class="sd">        b: ivy.array([17.9, 6., 31.5])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([6.2, 4.8, 2.3]),\</span>
<span class="sd">                           b=ivy.array([5., 1.7, 0.1]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([8.3, 3.2, 6.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.multiply(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([51.5, 15.4, 14.9]),</span>
<span class="sd">        b: ivy.array([41.5, 5.44, 0.65])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_multiply</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_negative"><a class="viewcode-back" href="../../../functional/ivy/elementwise/negative/static_negative_container.html#ivy.container.container_methods.static_negative">[docs]</a><span class="k">def</span> <span class="nf">static_negative</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.negative.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.negative also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;negative&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="negative"><a class="viewcode-back" href="../../../functional/ivy/elementwise/negative/negative_container.html#ivy.container.container_methods.negative">[docs]</a><span class="k">def</span> <span class="nf">negative</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.negative.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.negative also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_negative</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_not_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/not_equal/static_not_equal_container.html#ivy.container.container_methods.static_not_equal">[docs]</a><span class="k">def</span> <span class="nf">static_not_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.not_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.not_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;not_equal&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="not_equal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/not_equal/not_equal_container.html#ivy.container.container_methods.not_equal">[docs]</a><span class="k">def</span> <span class="nf">not_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.not_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.not_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12, 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12, 2.3, 3]), b=ivy.array([2.4, 3., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, True]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and :class:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 1., 0.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.not_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_not_equal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_positive"><a class="viewcode-back" href="../../../functional/ivy/elementwise/positive/static_positive_container.html#ivy.container.container_methods.static_positive">[docs]</a><span class="k">def</span> <span class="nf">static_positive</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.positive.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.positive also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;positive&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="positive"><a class="viewcode-back" href="../../../functional/ivy/elementwise/positive/positive_container.html#ivy.container.container_methods.positive">[docs]</a><span class="k">def</span> <span class="nf">positive</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.positive.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.positive also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4., -5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.positive(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">    a: ivy.array([0., 1., 2.]),</span>
<span class="sd">    b: ivy.array([3., 4., -5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_positive</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_pow"><a class="viewcode-back" href="../../../functional/ivy/elementwise/pow/static_pow_container.html#ivy.container.container_methods.static_pow">[docs]</a><span class="k">def</span> <span class="nf">static_pow</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.pow. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.pow also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;pow&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="pow"><a class="viewcode-back" href="../../../functional/ivy/elementwise/pow/pow_container.html#ivy.container.container_methods.pow">[docs]</a><span class="k">def</span> <span class="nf">pow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.pow. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.pow also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_pow</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_remainder"><a class="viewcode-back" href="../../../functional/ivy/elementwise/remainder/static_remainder_container.html#ivy.container.container_methods.static_remainder">[docs]</a><span class="k">def</span> <span class="nf">static_remainder</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">modulus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.remainder.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.remainder also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    modulus</span>
<span class="sd">        whether to compute the modulus instead of the remainder.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have the same sign as the respective element ``x2_i``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 3., 4.]), b=ivy.array([1., 3., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_remainder(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 1.]),</span>
<span class="sd">        b: ivy.array([0., 2., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and `ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_remainder(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([0., 0., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and `ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_remainder(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([0., 0., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;remainder&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="remainder"><a class="viewcode-back" href="../../../functional/ivy/elementwise/remainder/remainder_container.html#ivy.container.container_methods.remainder">[docs]</a><span class="k">def</span> <span class="nf">remainder</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">modulus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.remainder.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.remainder also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    modulus</span>
<span class="sd">        whether to compute the modulus instead of the remainder.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have the same sign as the respective element ``x2_i``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 3., 4.]), b=ivy.array([1., 3., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 1.]),</span>
<span class="sd">        b: ivy.array([0., 2., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and `ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([0., 0., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    With mixed :class:`ivy.Container` and `ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([0., 0., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_remainder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_round"><a class="viewcode-back" href="../../../functional/ivy/elementwise/round/static_round_container.html#ivy.container.container_methods.static_round">[docs]</a><span class="k">def</span> <span class="nf">static_round</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.round. This method simply</span>
<span class="sd">    wraps thevfunction, and so the docstring for ivy.round also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4.20, 8.6, 6.90, 0.0]),</span>
<span class="sd">    ...                   b=ivy.array([-300.9, -527.3, 4.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_round(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4., 9., 7., 0.]),</span>
<span class="sd">        b: ivy.array([-301., -527., 4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;round&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="round"><a class="viewcode-back" href="../../../functional/ivy/elementwise/round/round_container.html#ivy.container.container_methods.round">[docs]</a><span class="k">def</span> <span class="nf">round</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.round. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.round also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4.20, 8.6, 6.90, 0.0]),</span>
<span class="sd">    ...                   b=ivy.array([-300.9, -527.3, 4.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.round()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4., 9., 7., 0.]),</span>
<span class="sd">        b: ivy.array([-301., -527., 4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_round</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_sign"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sign/static_sign_container.html#ivy.container.container_methods.static_sign">[docs]</a><span class="k">def</span> <span class="nf">static_sign</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sign. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sign also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, -1., 6.6]),</span>
<span class="sd">    ...                   b=ivy.array([-14.2, 8.3, 0.1, -0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sign(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., -1., 1.]),</span>
<span class="sd">        b: ivy.array([-1., 1., 1., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sign&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sign"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sign/sign_container.html#ivy.container.container_methods.sign">[docs]</a><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sign. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sign also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-6.7, 2.4, -8.5]),</span>
<span class="sd">    ...                   b=ivy.array([1.5, -0.3, 0]),</span>
<span class="sd">    ...                   c=ivy.array([-4.7, -5.4, 7.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sign()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1., 1., -1.]),</span>
<span class="sd">        b: ivy.array([1., -1., 0.]),</span>
<span class="sd">        c: ivy.array([-1., -1., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sign</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_sin"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sin/static_sin_container.html#ivy.container.container_methods.static_sin">[docs]</a><span class="k">def</span> <span class="nf">static_sin</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sin also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the sine of each element in ``x``. The returned</span>
<span class="sd">        container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1., -2., -3.]),</span>
<span class="sd">    ...                   b=ivy.array([4., 5., 6.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sin(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0.841, -0.909, -0.141]),</span>
<span class="sd">        b: ivy.array([-0.757, -0.959, -0.279])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sin&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sin"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sin/sin_container.html#ivy.container.container_methods.sin">[docs]</a><span class="k">def</span> <span class="nf">sin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sin also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the sine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 2., 3.]),</span>
<span class="sd">    ...                   b=ivy.array([-4., -5., -6.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.841, 0.909, 0.141]),</span>
<span class="sd">        b: ivy.array([0.757, 0.959, 0.279])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_sinh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sinh/static_sinh_container.html#ivy.container.container_methods.static_sinh">[docs]</a><span class="k">def</span> <span class="nf">static_sinh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sinh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.sinh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the hyperbolic sine of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0.23, 1.12]), b=ivy.array([1, -2, 0.76]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sinh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.18, 0.232, 1.37]),</span>
<span class="sd">        b: ivy.array([1.18, -3.63, 0.835])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-3, 0.34, 2.]),</span>
<span class="sd">    ...                   b=ivy.array([0.67, -0.98, -3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(1), b=ivy.zeros(1))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_sinh(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-10., 0.347, 3.63]),</span>
<span class="sd">        b: ivy.array([0.721, -1.14, -10.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sinh&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sinh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sinh/sinh_container.html#ivy.container.container_methods.sinh">[docs]</a><span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sinh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.sinh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the hyperbolic sine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0.23, 1.12]), b=ivy.array([1, -2, 0.76]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sinh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.18, 0.232, 1.37]),</span>
<span class="sd">        b: ivy.array([1.18, -3.63, 0.835])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-3, 0.34, 2.]),</span>
<span class="sd">    ...                   b=ivy.array([0.67, -0.98, -3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(3), b=ivy.zeros(3))</span>
<span class="sd">    &gt;&gt;&gt; x.sinh(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-10., 0.347, 3.63]),</span>
<span class="sd">        b: ivy.array([0.721, -1.14, -10.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sinh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_square"><a class="viewcode-back" href="../../../functional/ivy/elementwise/square/static_square_container.html#ivy.container.container_methods.static_square">[docs]</a><span class="k">def</span> <span class="nf">static_square</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.square.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.square also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the square of each element in ``x``.</span>
<span class="sd">        The returned container must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;square&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="square"><a class="viewcode-back" href="../../../functional/ivy/elementwise/square/square_container.html#ivy.container.container_methods.square">[docs]</a><span class="k">def</span> <span class="nf">square</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.square.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.square also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the square of each element in ``self``.</span>
<span class="sd">        The returned container must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_square</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_sqrt"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sqrt/static_sqrt_container.html#ivy.container.container_methods.static_sqrt">[docs]</a><span class="k">def</span> <span class="nf">static_sqrt</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sqrt.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.sqrt also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the square root of each element in ``x``.</span>
<span class="sd">        The returned container must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sqrt&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sqrt"><a class="viewcode-back" href="../../../functional/ivy/elementwise/sqrt/sqrt_container.html#ivy.container.container_methods.sqrt">[docs]</a><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sqrt.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.sqrt also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the square root of each element in</span>
<span class="sd">        ``self``. The returned container must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sqrt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_subtract"><a class="viewcode-back" href="../../../functional/ivy/elementwise/subtract/static_subtract_container.html#ivy.container.container_methods.static_subtract">[docs]</a><span class="k">def</span> <span class="nf">static_subtract</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.subtract.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.subtract also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    alpha</span>
<span class="sd">        optional scalar multiplier for ``x2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 1, 3]),</span>
<span class="sd">    ...                   b=ivy.array([1, -1, 0]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_subtract(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-3, 1, 0]),</span>
<span class="sd">        b: ivy.array([1, 4, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_subtract(x, y, alpha=3)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-11, -1, -6]),</span>
<span class="sd">        b: ivy.array([-1, 6, 4])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;subtract&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../../functional/ivy/elementwise/subtract/subtract_container.html#ivy.container.container_methods.subtract">[docs]</a><span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.subtract.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.subtract also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    alpha</span>
<span class="sd">        optional scalar multiplier for ``x2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 1, 3]),</span>
<span class="sd">    ...                   b=ivy.array([1, -1, 0]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.subtract(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-3, 1, 0]),</span>
<span class="sd">        b: ivy.array([1, 4, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = x.subtract(y, alpha=3)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-11, -1, -6]),</span>
<span class="sd">        b: ivy.array([-1, 6, 4])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_subtract</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_tan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/tan/static_tan_container.html#ivy.container.container_methods.static_tan">[docs]</a><span class="k">def</span> <span class="nf">static_tan</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.tan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.tan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array whose elements are expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the tangent of each element in ``x``.</span>
<span class="sd">        The return must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_tan(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.56, -2.19]),</span>
<span class="sd">        b: ivy.array([-0.143, 1.16, -3.38])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;tan&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="tan"><a class="viewcode-back" href="../../../functional/ivy/elementwise/tan/tan_container.html#ivy.container.container_methods.tan">[docs]</a><span class="k">def</span> <span class="nf">tan</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.tan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.tan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the tangent of each element in ``self``.</span>
<span class="sd">        The return must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.tan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array([0., 1.56, -2.19]),</span>
<span class="sd">        b:ivy.array([-0.143, 1.16, -3.38])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_tan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_tanh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/tanh/static_tanh_container.html#ivy.container.container_methods.static_tanh">[docs]</a><span class="k">def</span> <span class="nf">static_tanh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.tanh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.tanh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the hyperbolic tangent of each element in ``x``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_tanh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.76, 0.96]),</span>
<span class="sd">        b: ivy.array([0.995, 0.999, 0.9999])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;tanh&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="tanh"><a class="viewcode-back" href="../../../functional/ivy/elementwise/tanh/tanh_container.html#ivy.container.container_methods.tanh">[docs]</a><span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.tanh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.tanh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the hyperbolic tangent of each element in</span>
<span class="sd">        ``self``. The returned container must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.tanh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array([0., 0.762, 0.964]),</span>
<span class="sd">        b:ivy.array([0.995, 0.999, 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_tanh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_trunc"><a class="viewcode-back" href="../../../functional/ivy/elementwise/trunc/static_trunc_container.html#ivy.container.container_methods.static_trunc">[docs]</a><span class="k">def</span> <span class="nf">static_trunc</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.trunc.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.trunc also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-0.25, 4, 1.3]),</span>
<span class="sd">    ...                   b=ivy.array([12, -3.5, 1.234]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_trunc(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0., 4., 1.]),</span>
<span class="sd">        b: ivy.array([12., -3., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;trunc&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="trunc"><a class="viewcode-back" href="../../../functional/ivy/elementwise/trunc/trunc_container.html#ivy.container.container_methods.trunc">[docs]</a><span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.trunc.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.trunc also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-0.25, 4, 1.3]),</span>
<span class="sd">    ...                   b=ivy.array([12, -3.5, 1.234]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.trunc()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0., 4., 1.]),</span>
<span class="sd">        b: ivy.array([12., -3., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_trunc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_erf"><a class="viewcode-back" href="../../../functional/ivy/elementwise/erf/static_erf_container.html#ivy.container.container_methods.static_erf">[docs]</a><span class="k">def</span> <span class="nf">static_erf</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.erf.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.erf also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to compute exponential for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the Gauss error of ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;erf&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="erf"><a class="viewcode-back" href="../../../functional/ivy/elementwise/erf/erf_container.html#ivy.container.container_methods.erf">[docs]</a><span class="k">def</span> <span class="nf">erf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.erf.</span>
<span class="sd">    This method simply wraps thefunction, and so the docstring for</span>
<span class="sd">    ivy.erf also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container to compute exponential for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the Gauss error of ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_erf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_minimum"><a class="viewcode-back" href="../../../functional/ivy/elementwise/minimum/static_minimum_container.html#ivy.container.container_methods.static_minimum">[docs]</a><span class="k">def</span> <span class="nf">static_minimum</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_where</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.minimum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.minimum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        Input array containing elements to minimum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        The other container or number to compute the minimum against.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    use_where</span>
<span class="sd">        Whether to use :func:`where` to calculate the minimum. If ``False``, the</span>
<span class="sd">        minimum is calculated using the ``(x + y - |x - y|)/2`` formula. Default is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object with all sub-arrays having the minimum values computed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;minimum&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">use_where</span><span class="o">=</span><span class="n">use_where</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="minimum"><a class="viewcode-back" href="../../../functional/ivy/elementwise/minimum/minimum_container.html#ivy.container.container_methods.minimum">[docs]</a><span class="k">def</span> <span class="nf">minimum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_where</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.minimum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.minimum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to minimum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        The other container or number to compute the minimum against.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    use_where</span>
<span class="sd">        Whether to use :func:`where` to calculate the minimum. If ``False``, the</span>
<span class="sd">        minimum is calculated using the ``(x + y - |x - y|)/2`` formula. Default is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object with all sub-arrays having the minimum values computed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_minimum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">use_where</span><span class="o">=</span><span class="n">use_where</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_maximum"><a class="viewcode-back" href="../../../functional/ivy/elementwise/maximum/static_maximum_container.html#ivy.container.container_methods.static_maximum">[docs]</a><span class="k">def</span> <span class="nf">static_maximum</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_where</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.maximum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.maximum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        Input array containing elements to maximum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        Tensor containing maximum values, must be broadcastable to x1.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    use_where</span>
<span class="sd">        Whether to use :func:`where` to calculate the maximum. If ``False``, the</span>
<span class="sd">        maximum is calculated using the ``(x + y + |x - y|)/2`` formula. Default is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of x1, but clipped to not be lower than the x2</span>
<span class="sd">        values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;maximum&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">use_where</span><span class="o">=</span><span class="n">use_where</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="maximum"><a class="viewcode-back" href="../../../functional/ivy/elementwise/maximum/maximum_container.html#ivy.container.container_methods.maximum">[docs]</a><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_where</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.maximum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.maximum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to maximum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        Tensor containing maximum values, must be broadcastable to x1.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    use_where</span>
<span class="sd">        Whether to use :func:`where` to calculate the maximum. If ``False``, the</span>
<span class="sd">        maximum is calculated using the ``(x + y + |x - y|)/2`` formula. Default is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of x1, but clipped to not be lower than the x2</span>
<span class="sd">        values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_maximum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">use_where</span><span class="o">=</span><span class="n">use_where</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_reciprocal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/reciprocal/static_reciprocal_container.html#ivy.container.container_methods.static_reciprocal">[docs]</a><span class="k">def</span> <span class="nf">static_reciprocal</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.reciprocal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.reciprocal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the element-wise recirpocal of ``x``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;reciprocal&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="reciprocal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/reciprocal/reciprocal_container.html#ivy.container.container_methods.reciprocal">[docs]</a><span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.reciprocal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.reciprocal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container to compute the element-wise reciprocal for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the element-wise recirpocal of ``x``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_reciprocal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_deg2rad"><a class="viewcode-back" href="../../../functional/ivy/elementwise/deg2rad/static_deg2rad_container.html#ivy.container.container_methods.static_deg2rad">[docs]</a><span class="k">def</span> <span class="nf">static_deg2rad</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.deg2rad.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.deg2rad also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. to be converted from degrees to radians.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with each element in ``x`` converted from degrees to radians.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x=ivy.Container(a=ivy.array([0,90,180,270,360]),</span>
<span class="sd">    ...                 b=ivy.native_array([0,-1.5,-50,ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y=ivy.Container.static_deg2rad(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.57, 3.14, 4.71, 6.28]),</span>
<span class="sd">        b: ivy.array([0., -0.0262, -0.873, nan])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;deg2rad&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="deg2rad"><a class="viewcode-back" href="../../../functional/ivy/elementwise/deg2rad/deg2rad_container.html#ivy.container.container_methods.deg2rad">[docs]</a><span class="k">def</span> <span class="nf">deg2rad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.deg2rad.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.deg2rad also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. to be converted from degrees to radians.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with each element in ``x`` converted from degrees to radians.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x=ivy.Container(a=ivy.array([0., 0.351, -0.881, ivy.nan]),</span>
<span class="sd">    ...                 b=ivy.native_array([0,-1.5,-50,ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y=x.deg2rad()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.00613, -0.0154, nan]),</span>
<span class="sd">        b: ivy.array([0., -0.0262, -0.873, nan])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_deg2rad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_rad2deg"><a class="viewcode-back" href="../../../functional/ivy/elementwise/rad2deg/static_rad2deg_container.html#ivy.container.container_methods.static_rad2deg">[docs]</a><span class="k">def</span> <span class="nf">static_rad2deg</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.rad2deg.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.rad2deg also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. to be converted from radians to degrees.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with each element in ``x`` converted from radians to degrees.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x=ivy.Container(a=ivy.array([0,90,180,270,360]),</span>
<span class="sd">    ...                 b=ivy.native_array([0,-1.5,-50,ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y=ivy.Container.static_rad2deg(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 5160., 10300., 15500., 20600.]),</span>
<span class="sd">        b: ivy.array([0., -85.9, -2860., nan])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;rad2deg&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="rad2deg"><a class="viewcode-back" href="../../../functional/ivy/elementwise/rad2deg/rad2deg_container.html#ivy.container.container_methods.rad2deg">[docs]</a><span class="k">def</span> <span class="nf">rad2deg</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.rad2deg.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.rad2deg also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. to be converted from radians to degrees.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with each element in ``x`` converted from radians to degrees.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x=ivy.Container(a=ivy.array([0., 0.351, -0.881, ivy.nan]),</span>
<span class="sd">    ...                 b=ivy.native_array([0,-1.5,-50,7.2]))</span>
<span class="sd">    &gt;&gt;&gt; y=x.rad2deg()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 20.1, -50.5, nan]),</span>
<span class="sd">        b: ivy.array([0., -85.9, -2860., 413.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_rad2deg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_trunc_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/trunc_divide/static_trunc_divide_container.html#ivy.container.container_methods.static_trunc_divide">[docs]</a><span class="k">def</span> <span class="nf">static_trunc_divide</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.trunc_divide. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.trunc_divide also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        dividend input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2.3, -3]), b=ivy.array([2.4, 3., -2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_divide(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12., 1., -2.]),</span>
<span class="sd">        b: ivy.array([1., 0., -4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;trunc_divide&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="trunc_divide"><a class="viewcode-back" href="../../../functional/ivy/elementwise/trunc_divide/trunc_divide_container.html#ivy.container.container_methods.trunc_divide">[docs]</a><span class="k">def</span> <span class="nf">trunc_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.trunc_divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.trunc_divide also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array or container. Should have a real-valued</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2.3, -3]), b=ivy.array([2.4, 3., -2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.trunc_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12., 1., -2.]),</span>
<span class="sd">        b: ivy.array([1., 0., -4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_trunc_divide</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_isreal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isreal/static_isreal_container.html#ivy.container.container_methods.static_isreal">[docs]</a><span class="k">def</span> <span class="nf">static_isreal</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isreal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isreal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``x_i`` is real number and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1+5j, 0-0j, 1.23j]),</span>
<span class="sd">    ...                   b=ivy.array([7.9, 3.3j, -4.2-5.9j]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_isreal(x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False]),</span>
<span class="sd">        b: ivy.array([True, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;isreal&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isreal"><a class="viewcode-back" href="../../../functional/ivy/elementwise/isreal/isreal_container.html#ivy.container.container_methods.isreal">[docs]</a><span class="k">def</span> <span class="nf">isreal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isreal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.isreal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is real number and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1j, -np.inf, 1.23+7j]),\</span>
<span class="sd">                      b=ivy.array([0.0, 3.3j, 1+0j]))</span>
<span class="sd">    &gt;&gt;&gt; x.isreal()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False]),</span>
<span class="sd">        b: ivy.array([True, False, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_isreal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">static_trapz</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="n">dx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.trapz. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.trapz also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y</span>
<span class="sd">        The container whose arrays should be integrated.</span>
<span class="sd">    x</span>
<span class="sd">        The sample points corresponding to the input array values.</span>
<span class="sd">        If x is None, the sample points are assumed to be evenly spaced</span>
<span class="sd">        dx apart. The default is None.</span>
<span class="sd">    dx</span>
<span class="sd">        The spacing between sample points when x is None. The default is 1.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to integrate.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including definite integrals of n-dimensional arrays</span>
<span class="sd">        as approximated along a single axis by the trapezoidal rule.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array((1, 2, 3)), b=ivy.array((1, 5, 10)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_trapz(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: 4.0</span>
<span class="sd">        b: 10.5</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;trapz&quot;</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="n">dx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.trapz. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.trapz also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The container whose arrays should be integrated.</span>
<span class="sd">    x</span>
<span class="sd">        The sample points corresponding to the input array values.</span>
<span class="sd">        If x is None, the sample points are assumed to be evenly spaced</span>
<span class="sd">        dx apart. The default is None.</span>
<span class="sd">    dx</span>
<span class="sd">        The spacing between sample points when x is None. The default is 1.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to integrate.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including definite integrals of n-dimensional arrays</span>
<span class="sd">        as approximated along a single axis by the trapezoidal rule.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array((1, 2, 3)), b=ivy.array((1, 5, 10)))</span>
<span class="sd">    &gt;&gt;&gt; y.trapz()</span>
<span class="sd">    {</span>
<span class="sd">        a: 4.0</span>
<span class="sd">        b: 10.5</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_trapz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="c1">#ivy.container.experimental</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Literal</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>




<div class="viewcode-block" id="static_sinc"><a class="viewcode-back" href="../../../functional/ivy/experimental/sinc/static_sinc_container.html#ivy.container.container_methods.static_sinc">[docs]</a><span class="k">def</span> <span class="nf">static_sinc</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sinc. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sinc also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the sinc of each element in ``x``. The returned</span>
<span class="sd">        container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.5, 1.5, 2.5]),</span>
<span class="sd">    ...                   b=ivy.array([3.5, 4.5, 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sinc(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.636, -0.212, 0.127]),</span>
<span class="sd">        b: ivy.array([-0.090, 0.070, -0.057])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sinc&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sinc"><a class="viewcode-back" href="../../../functional/ivy/experimental/sinc/sinc_container.html#ivy.container.container_methods.sinc">[docs]</a><span class="k">def</span> <span class="nf">sinc</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sinc. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sinc also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the sinc of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.5, 1.5, 2.5]),</span>
<span class="sd">    ...                   b=ivy.array([3.5, 4.5, 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sinc()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.637,-0.212,0.127]),</span>
<span class="sd">        b: ivy.array([-0.0909,0.0707,-0.0579])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sinc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_lcm"><a class="viewcode-back" href="../../../functional/ivy/experimental/lcm/static_lcm_container.html#ivy.container.container_methods.static_lcm">[docs]</a><span class="k">def</span> <span class="nf">static_lcm</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.lcm. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.lcm also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input container.</span>
<span class="sd">    x2</span>
<span class="sd">        second input container.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise least common multiples</span>
<span class="sd">        of the arrays contained in x1 and x2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1=ivy.Container(a=ivy.array([2, 3, 4]),</span>
<span class="sd">    ...                  b=ivy.array([6, 54, 62, 10]))</span>
<span class="sd">    &gt;&gt;&gt; x2=ivy.Container(a=ivy.array([5, 8, 15]),</span>
<span class="sd">    ...                  b=ivy.array([32, 40, 25, 13]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.lcm(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10, 21, 60]),</span>
<span class="sd">        b: ivy.array([96, 1080, 1550, 130])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;lcm&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lcm"><a class="viewcode-back" href="../../../functional/ivy/experimental/lcm/lcm_container.html#ivy.container.container_methods.lcm">[docs]</a><span class="k">def</span> <span class="nf">lcm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.lcm. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.lcm also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input container.</span>
<span class="sd">    x2</span>
<span class="sd">        second input container.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the the element-wise least common multiples</span>
<span class="sd">        of the arrays contained in x1 and x2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1=ivy.Container(a=ivy.array([2, 3, 4]),</span>
<span class="sd">    ...                  b=ivy.array([6, 54, 62, 10]))</span>
<span class="sd">    &gt;&gt;&gt; x2=ivy.Container(a=ivy.array([5, 8, 15]),</span>
<span class="sd">    ...                  b=ivy.array([32, 40, 25, 13]))</span>
<span class="sd">    &gt;&gt;&gt; x1.lcm(x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10, 24, 60]),</span>
<span class="sd">        b: ivy.array([96, 1080, 1550, 130])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_lcm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_fmod"><a class="viewcode-back" href="../../../functional/ivy/experimental/fmod/static_fmod_container.html#ivy.container.container_methods.static_fmod">[docs]</a><span class="k">def</span> <span class="nf">static_fmod</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.fmod. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.fmod also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        container with the first input arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        container with the second input arrays</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise remainder of divisions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2, 3, 4]),\</span>
<span class="sd">                           b=ivy.array([ivy.nan, 0, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1, 5, 2]),\</span>
<span class="sd">                           b=ivy.array([0, ivy.nan, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_fmod(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([ 0,  3,  0])</span>
<span class="sd">        b: ivy.array([ nan,  nan,  nan])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;fmod&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fmod"><a class="viewcode-back" href="../../../functional/ivy/experimental/fmod/fmod_container.html#ivy.container.container_methods.fmod">[docs]</a><span class="k">def</span> <span class="nf">fmod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.fmod. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fmod also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with the first input arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        container with the second input arrays</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise remainder of divisions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2, 3, 4]),\</span>
<span class="sd">                           b=ivy.array([ivy.nan, 0, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1, 5, 2]),\</span>
<span class="sd">                           b=ivy.array([0, ivy.nan, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; x1.fmod(x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([ 0,  3,  0])</span>
<span class="sd">        b: ivy.array([ nan,  nan,  nan])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_fmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_fmax"><a class="viewcode-back" href="../../../functional/ivy/experimental/fmax/static_fmax_container.html#ivy.container.container_methods.static_fmax">[docs]</a><span class="k">def</span> <span class="nf">static_fmax</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.fmax. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.fmax also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        container with the first input arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        container with the second input arrays</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise maximums.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2, 3, 4]),\</span>
<span class="sd">                           b=ivy.array([ivy.nan, 0, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1, 5, 2]),\</span>
<span class="sd">                           b=ivy.array([0, ivy.nan, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_fmax(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([ 2.,  5.,  4.])</span>
<span class="sd">        b: ivy.array([ 0,  0,  nan])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;fmax&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fmax"><a class="viewcode-back" href="../../../functional/ivy/experimental/fmax/fmax_container.html#ivy.container.container_methods.fmax">[docs]</a><span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.fmax. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fmax also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with the first input arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        container with the second input arrays</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise maximums.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2, 3, 4]),\</span>
<span class="sd">                           b=ivy.array([ivy.nan, 0, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1, 5, 2]),\</span>
<span class="sd">                           b=ivy.array([0, ivy.nan, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; x1.fmax(x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([ 2.,  5.,  4.])</span>
<span class="sd">        b: ivy.array([ 0,  0,  nan])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_fmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_float_power"><a class="viewcode-back" href="../../../functional/ivy/experimental/float_power/static_float_power_container.html#ivy.container.container_methods.static_float_power">[docs]</a><span class="k">def</span> <span class="nf">static_float_power</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.float_power. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.float_power also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        container with the exponent input arrays</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with base arrays raised to the powers</span>
<span class="sd">        of exponents arrays, element-wise .</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                           b=ivy.array([2, 10]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1, 3, 1]), b=0)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_float_power(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1,  8,  3])</span>
<span class="sd">        b: ivy.array([1, 1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;float_power&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="float_power"><a class="viewcode-back" href="../../../functional/ivy/experimental/float_power/float_power_container.html#ivy.container.container_methods.float_power">[docs]</a><span class="k">def</span> <span class="nf">float_power</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.float_power. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.float_power also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        container with the exponent input arrays</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with base arrays raised to the powers</span>
<span class="sd">        of exponents arrays, element-wise .</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                           b=ivy.array([2, 10]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1, 3, 1]), b=0)</span>
<span class="sd">    &gt;&gt;&gt; x1.float_power(x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1,  8,  3])</span>
<span class="sd">        b: ivy.array([1, 1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_float_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_exp2"><a class="viewcode-back" href="../../../functional/ivy/experimental/exp2/static_exp2_container.html#ivy.container.container_methods.static_exp2">[docs]</a><span class="k">def</span> <span class="nf">static_exp2</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.exp2. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.exp2 also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise 2 to the power</span>
<span class="sd">        of input arrays elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                           b=[5, 6, 7])</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_exp2(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2.,  4.,  8.])</span>
<span class="sd">        b: ivy.array([32., 64., 128.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;exp2&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="exp2"><a class="viewcode-back" href="../../../functional/ivy/experimental/exp2/exp2_container.html#ivy.container.container_methods.exp2">[docs]</a><span class="k">def</span> <span class="nf">exp2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.exp2. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.exp2 also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise 2 to the power</span>
<span class="sd">        of input array elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                           b=[5, 6, 7])</span>
<span class="sd">    &gt;&gt;&gt; x.exp2()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2.,  4.,  8.])</span>
<span class="sd">        b: ivy.array([32., 64., 128.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_exp2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_count_nonzero"><a class="viewcode-back" href="../../../functional/ivy/experimental/count_nonzero/static_count_nonzero_container.html#ivy.container.container_methods.static_count_nonzero">[docs]</a><span class="k">def</span> <span class="nf">static_count_nonzero</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.count_nonzero. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.count_nonzero also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    axis</span>
<span class="sd">        optional axis or tuple of axes along which to count non-zeros. Default is</span>
<span class="sd">        None, meaning that non-zeros will be counted along a flattened</span>
<span class="sd">        version of the input array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        optional, if this is set to True, the axes that are counted are left in the</span>
<span class="sd">        result as dimensions with size one. With this option, the result</span>
<span class="sd">        will broadcast correctly against the input array.</span>
<span class="sd">    dtype</span>
<span class="sd">        optional output dtype. Default is of type integer.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including number of non-zero values in the array along a</span>
<span class="sd">        given axis. Otherwise, container with the total number of non-zero</span>
<span class="sd">        values in the array is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1, 2, 3],[4, 5, 6, 7]]),\</span>
<span class="sd">                    b=ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_count_nonzero(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(7),</span>
<span class="sd">        b: ivy.array(7)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1, 2, 3],[4, 5, 6, 7]]),\</span>
<span class="sd">                    b=ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_count_nonzero(x, axis=0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 2, 2]),</span>
<span class="sd">        b: ivy.array([[1, 2],</span>
<span class="sd">                      [2, 2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1, 2, 3],[4, 5, 6, 7]]),\</span>
<span class="sd">                    b=ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_count_nonzero(x, axis=(0,1), keepdims=True)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[7]]),</span>
<span class="sd">        b: ivy.array([[[3, 4]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;count_nonzero&quot;</span><span class="p">,</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="count_nonzero"><a class="viewcode-back" href="../../../functional/ivy/experimental/count_nonzero/count_nonzero_container.html#ivy.container.container_methods.count_nonzero">[docs]</a><span class="k">def</span> <span class="nf">count_nonzero</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.count_nonzero. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.count_nonzero also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    axis</span>
<span class="sd">        optional axis or tuple of axes along which to count non-zeros. Default is</span>
<span class="sd">        None, meaning that non-zeros will be counted along a flattened</span>
<span class="sd">        version of the input array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        optional, if this is set to True, the axes that are counted are left in the</span>
<span class="sd">        result as dimensions with size one. With this option, the result</span>
<span class="sd">        will broadcast correctly against the input array.</span>
<span class="sd">    dtype</span>
<span class="sd">        optional output dtype. Default is of type integer.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including number of non-zero values in the array along a</span>
<span class="sd">        given axis. Otherwise, container with the total number of non-zero</span>
<span class="sd">        values in the array is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1, 2, 3],[4, 5, 6, 7]]),\</span>
<span class="sd">                    b=ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]]))</span>
<span class="sd">    &gt;&gt;&gt; x.count_nonzero()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(7),</span>
<span class="sd">        b: ivy.array(7)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1, 2, 3],[4, 5, 6, 7]]),\</span>
<span class="sd">                    b=ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]]))</span>
<span class="sd">    &gt;&gt;&gt; x.count_nonzero(axis=0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 2, 2]),</span>
<span class="sd">        b: ivy.array([[1, 2],</span>
<span class="sd">                      [2, 2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1, 2, 3],[4, 5, 6, 7]]),\</span>
<span class="sd">                    b=ivy.array([[[0,1],[2,3]],[[4,5],[6,7]]]))</span>
<span class="sd">    &gt;&gt;&gt; x.count_nonzero(axis=(0,1), keepdims=True)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[7]]),</span>
<span class="sd">        b: ivy.array([[[3, 4]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_count_nonzero</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_nansum"><a class="viewcode-back" href="../../../functional/ivy/experimental/nansum/static_nansum_container.html#ivy.container.container_methods.static_nansum">[docs]</a><span class="k">def</span> <span class="nf">static_nansum</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.nansum. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.nansum also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the sum is computed.</span>
<span class="sd">        The default is to compute the sum of the flattened array.</span>
<span class="sd">    dtype</span>
<span class="sd">        The type of the returned array and of the accumulator in</span>
<span class="sd">        which the elements are summed. By default, the dtype of input is used.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>
<span class="sd">    </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new array holding the result is returned unless out is specified,</span>
<span class="sd">        in which it is returned.</span>
<span class="sd">    </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[10, 7, 4], [3, 2, 1]]),\</span>
<span class="sd">            b=ivy.array([[1, 4, 2], [ivy.nan, ivy.nan, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_nansum(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: 27,</span>
<span class="sd">        b: 7.0</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; ivy.Container.static_nansum(x, axis=0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([13, 9, 5]),</span>
<span class="sd">        b: ivy.array([1., 4., 2.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; ivy.Container.static_nansum(x, axis=1)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([21, 6]),</span>
<span class="sd">        b: ivy.array([7., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;nansum&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="nansum"><a class="viewcode-back" href="../../../functional/ivy/experimental/nansum/nansum_container.html#ivy.container.container_methods.nansum">[docs]</a><span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.nansum. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nansum also applies to this</span>
<span class="sd">    method with minimal changes.</span>
<span class="sd">    </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container including arrays.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the sum is computed.</span>
<span class="sd">        The default is to compute the sum of the flattened array.</span>
<span class="sd">    dtype</span>
<span class="sd">        The type of the returned array and of the accumulator in</span>
<span class="sd">        which the elements are summed. By default, the dtype of input is used.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>
<span class="sd">    </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new array holding the result is returned unless out is specified,</span>
<span class="sd">        in which it is returned.</span>
<span class="sd">    </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[10, 7, 4], [3, 2, 1]]),\</span>
<span class="sd">            b=ivy.array([[1, 4, 2], [ivy.nan, ivy.nan, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; x.nansum(axis=0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([13, 9, 5]),</span>
<span class="sd">        b: ivy.array([1., 4., 2.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.nansum(axis=1)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([21, 6]),</span>
<span class="sd">        b: ivy.array([7., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_nansum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_gcd"><a class="viewcode-back" href="../../../functional/ivy/experimental/gcd/static_gcd_container.html#ivy.container.container_methods.static_gcd">[docs]</a><span class="k">def</span> <span class="nf">static_gcd</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.gcd. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.gcd also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input container with array-like items.</span>
<span class="sd">    x2</span>
<span class="sd">        second input container with array-like items.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise gcd of input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                           b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([5, 6, 7]),\</span>
<span class="sd">                           b=10)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_gcd(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.,  1.,  3.])</span>
<span class="sd">        b: ivy.array([1., 2., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;gcd&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gcd"><a class="viewcode-back" href="../../../functional/ivy/experimental/gcd/gcd_container.html#ivy.container.container_methods.gcd">[docs]</a><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.gcd. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.gcd also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container with array-like items.</span>
<span class="sd">    x2</span>
<span class="sd">        second input container with array-like items.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise gcd of input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                           b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([5, 6, 7]),\</span>
<span class="sd">                           b=10)</span>
<span class="sd">    &gt;&gt;&gt; x1.gcd(x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.,  1.,  3.])</span>
<span class="sd">        b: ivy.array([1., 2., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_gcd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_isclose"><a class="viewcode-back" href="../../../functional/ivy/experimental/isclose/static_isclose_container.html#ivy.container.container_methods.static_isclose">[docs]</a><span class="k">def</span> <span class="nf">static_isclose</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-08</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isclose. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isclose also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a</span>
<span class="sd">        Input container containing first input array.</span>
<span class="sd">    b</span>
<span class="sd">        Input container containing second input array.</span>
<span class="sd">    rtol</span>
<span class="sd">        The relative tolerance parameter.</span>
<span class="sd">    atol</span>
<span class="sd">        The absolute tolerance parameter.</span>
<span class="sd">    equal_nan</span>
<span class="sd">        Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in a will be</span>
<span class="sd">        considered equal to NaN&#39;s in b in the output array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new array holding the result is returned unless out is specified,</span>
<span class="sd">        in which it is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, ivy.nan]),\</span>
<span class="sd">            b=ivy.array([1.0, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1.0, ivy.nan]),\</span>
<span class="sd">            b=ivy.array([1.0, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_isclose(x, y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False]),</span>
<span class="sd">        b: ivy.array([True, False])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; ivy.Container.static_isclose(x, y, equal_nan=True)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True]),</span>
<span class="sd">        b: ivy.array([True, True])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 2.0]),\</span>
<span class="sd">            b=ivy.array([1.0, 2.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1.0, 2.001]),\</span>
<span class="sd">            b=ivy.array([1.0, 2.0]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_isclose(x, y, atol=0.0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False]),</span>
<span class="sd">        b: ivy.array([True, True])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; ivy.Container.static_isclose(x, y, rtol=0.01, atol=0.0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True]),</span>
<span class="sd">        b: ivy.array([True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;isclose&quot;</span><span class="p">,</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">b</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
        <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isclose"><a class="viewcode-back" href="../../../functional/ivy/experimental/isclose/isclose_container.html#ivy.container.container_methods.isclose">[docs]</a><span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-08</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isclose. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.isclose also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container containing first input array.</span>
<span class="sd">    b</span>
<span class="sd">        Input container containing second input array.</span>
<span class="sd">    rtol</span>
<span class="sd">        The relative tolerance parameter.</span>
<span class="sd">    atol</span>
<span class="sd">        The absolute tolerance parameter.</span>
<span class="sd">    equal_nan</span>
<span class="sd">        Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in a will be</span>
<span class="sd">        considered equal to NaN&#39;s in b in the output array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new array holding the result is returned unless out is specified,</span>
<span class="sd">        in which it is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, ivy.nan]),\</span>
<span class="sd">            b=ivy.array([1.0, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1.0, ivy.nan]),\</span>
<span class="sd">            b=ivy.array([1.0, ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; x.isclose(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False]),</span>
<span class="sd">        b: ivy.array([True, False])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.isclose(y, equal_nan=True)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True]),</span>
<span class="sd">        b: ivy.array([True, True])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 2.0]),\</span>
<span class="sd">            b=ivy.array([1.0, 2.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1.0, 2.001]),\</span>
<span class="sd">            b=ivy.array([1.0, 2.0]))</span>
<span class="sd">    &gt;&gt;&gt; x.isclose(y, atol=0.0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False]),</span>
<span class="sd">        b: ivy.array([True, True])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.isclose(y, rtol=0.01, atol=0.0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True]),</span>
<span class="sd">        b: ivy.array([True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_isclose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">b</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
        <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_isposinf"><a class="viewcode-back" href="../../../functional/ivy/experimental/isposinf/static_isposinf_container.html#ivy.container.container_methods.static_isposinf">[docs]</a><span class="k">def</span> <span class="nf">static_isposinf</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isposinf. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isposinf also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including a boolean array with values</span>
<span class="sd">        True where the corresponding element of the input</span>
<span class="sd">        is positive infinity and values False where the</span>
<span class="sd">        element of the input is not positive infinity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, ivy.inf, -ivy.inf]),\</span>
<span class="sd">                            b=ivy.array([5, ivy.inf, ivy.inf]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_isposinf(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False]),</span>
<span class="sd">        b: ivy.array([False, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;isposinf&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isposinf"><a class="viewcode-back" href="../../../functional/ivy/experimental/isposinf/isposinf_container.html#ivy.container.container_methods.isposinf">[docs]</a><span class="k">def</span> <span class="nf">isposinf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isposinf. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.isposinf also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns container including a boolean array with values</span>
<span class="sd">        True where the corresponding element of the input</span>
<span class="sd">        is positive infinity and values False where the</span>
<span class="sd">        element of the input is not positive infinity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, ivy.inf, -ivy.inf]),\</span>
<span class="sd">                           b=ivy.array([5, ivy.inf, ivy.inf]))</span>
<span class="sd">    &gt;&gt;&gt; x.isposinf()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False]),</span>
<span class="sd">        b: ivy.array([False, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_isposinf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_isneginf"><a class="viewcode-back" href="../../../functional/ivy/experimental/isneginf/static_isneginf_container.html#ivy.container.container_methods.static_isneginf">[docs]</a><span class="k">def</span> <span class="nf">static_isneginf</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isneginf. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.isneginf also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including a boolean array with values</span>
<span class="sd">        True where the corresponding element of the input</span>
<span class="sd">        is negative infinity and values False where the</span>
<span class="sd">        element of the input is not negative infinity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, ivy.inf, -ivy.inf]),\</span>
<span class="sd">                            b=ivy.array([5, -ivy.inf, -ivy.inf]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_isneginf(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, True]),</span>
<span class="sd">        b: ivy.array([False, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;isneginf&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isneginf"><a class="viewcode-back" href="../../../functional/ivy/experimental/isneginf/isneginf_container.html#ivy.container.container_methods.isneginf">[docs]</a><span class="k">def</span> <span class="nf">isneginf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isneginf. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.isneginf also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with the base input arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns container including a boolean array with values</span>
<span class="sd">        True where the corresponding element of the input</span>
<span class="sd">        is negative infinity and values False where the</span>
<span class="sd">        element of the input is not negative infinity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, ivy.inf, -ivy.inf]),\</span>
<span class="sd">                           b=ivy.array([5, -ivy.inf, -ivy.inf]))</span>
<span class="sd">    &gt;&gt;&gt; x.isneginf()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, True]),</span>
<span class="sd">        b: ivy.array([False, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_isneginf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_nan_to_num"><a class="viewcode-back" href="../../../functional/ivy/experimental/nan_to_num/static_nan_to_num_container.html#ivy.container.container_methods.static_nan_to_num">[docs]</a><span class="k">def</span> <span class="nf">static_nan_to_num</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">nan</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">posinf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">neginf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.nan_to_num. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.nan_to_num also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input container with array items.</span>
<span class="sd">    copy</span>
<span class="sd">        Whether to create a copy of x (True) or to replace values in-place (False).</span>
<span class="sd">        The in-place operation only occurs if casting to an array does not require</span>
<span class="sd">        a copy. Default is True.</span>
<span class="sd">    nan</span>
<span class="sd">        Value to be used to fill NaN values. If no value is passed then NaN values</span>
<span class="sd">        will be replaced with 0.0.</span>
<span class="sd">    posinf</span>
<span class="sd">        Value to be used to fill positive infinity values. If no value is passed</span>
<span class="sd">        then positive infinity values will be replaced with a very large number.</span>
<span class="sd">    neginf</span>
<span class="sd">        Value to be used to fill negative infinity values.</span>
<span class="sd">        If no value is passed then negative infinity values</span>
<span class="sd">        will be replaced with a very small (or negative) number.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with replaced non-finite elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3, nan]),\</span>
<span class="sd">                           b=ivy.array([1, 2, 3, inf]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_nan_to_num(x, posinf=5e+100)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.,  1.,  3.,  0.0])</span>
<span class="sd">        b: ivy.array([1., 2., 1.,  5e+100])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;nan_to_num&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span>
        <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="nan_to_num"><a class="viewcode-back" href="../../../functional/ivy/experimental/nan_to_num/nan_to_num_container.html#ivy.container.container_methods.nan_to_num">[docs]</a><span class="k">def</span> <span class="nf">nan_to_num</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">nan</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">posinf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">neginf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.nan_to_num. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nan_to_num also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container with array items.</span>
<span class="sd">    copy</span>
<span class="sd">        Whether to create a copy of x (True) or to replace values in-place (False).</span>
<span class="sd">        The in-place operation only occurs if casting to an array does not require</span>
<span class="sd">        a copy. Default is True.</span>
<span class="sd">    nan</span>
<span class="sd">        Value to be used to fill NaN values. If no value is passed then NaN values</span>
<span class="sd">        will be replaced with 0.0.</span>
<span class="sd">    posinf</span>
<span class="sd">        Value to be used to fill positive infinity values. If no value is passed</span>
<span class="sd">        then positive infinity values will be replaced with a very large number.</span>
<span class="sd">    neginf</span>
<span class="sd">        Value to be used to fill negative infinity values.</span>
<span class="sd">        If no value is passed then negative infinity values</span>
<span class="sd">        will be replaced with a very small (or negative) number.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with replaced non-finite elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3, nan]),\</span>
<span class="sd">                           b=ivy.array([1, 2, 3, inf]))</span>
<span class="sd">    &gt;&gt;&gt; x.nan_to_num(posinf=5e+100)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.,  1.,  3.,  0.0])</span>
<span class="sd">        b: ivy.array([1., 2., 1.,  5e+100])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_nan_to_num</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_logaddexp2"><a class="viewcode-back" href="../../../functional/ivy/experimental/logaddexp2/static_logaddexp2_container.html#ivy.container.container_methods.static_logaddexp2">[docs]</a><span class="k">def</span> <span class="nf">static_logaddexp2</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logaddexp2. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.logaddexp2 also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input container with array-like items.</span>
<span class="sd">    x2</span>
<span class="sd">        second input container with array-like items.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise logaddexp2 of input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                           b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                           b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_logaddexp2(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4.169925, 5.169925, 6.169925])</span>
<span class="sd">        b: ivy.array([5.08746284, 5.169925  , 5.32192809])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;logaddexp2&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logaddexp2"><a class="viewcode-back" href="../../../functional/ivy/experimental/logaddexp2/logaddexp2_container.html#ivy.container.container_methods.logaddexp2">[docs]</a><span class="k">def</span> <span class="nf">logaddexp2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.logaddexp2. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.logaddexp2 also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container with array-like items.</span>
<span class="sd">    x2</span>
<span class="sd">        second input container with array-like items.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise logaddexp2 of input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                           b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                           b=5)</span>
<span class="sd">    &gt;&gt;&gt; x1.logaddexp2(x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4.169925, 5.169925, 6.169925])</span>
<span class="sd">        b: ivy.array([5.08746284, 5.169925  , 5.32192809])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_logaddexp2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_signbit"><a class="viewcode-back" href="../../../functional/ivy/experimental/signbit/static_signbit_container.html#ivy.container.container_methods.static_signbit">[docs]</a><span class="k">def</span> <span class="nf">static_signbit</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.signbit. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.signbit also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container with array-like items.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise signbit of input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, -2, 3]),\</span>
<span class="sd">                           b=-5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_signbit(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False])</span>
<span class="sd">        b: ivy.array([True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;signbit&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="signbit"><a class="viewcode-back" href="../../../functional/ivy/experimental/signbit/signbit_container.html#ivy.container.container_methods.signbit">[docs]</a><span class="k">def</span> <span class="nf">signbit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.signbit. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.signbit also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container with array-like items.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise signbit of input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, -2, 3]),\</span>
<span class="sd">                           b=-5)</span>
<span class="sd">    &gt;&gt;&gt; x.signbit()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False])</span>
<span class="sd">        b: ivy.array([True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_signbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_allclose"><a class="viewcode-back" href="../../../functional/ivy/experimental/allclose/static_allclose_container.html#ivy.container.container_methods.static_allclose">[docs]</a><span class="k">def</span> <span class="nf">static_allclose</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-08</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.allclose. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.allclose also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        Input container containing first input array.</span>
<span class="sd">    x2</span>
<span class="sd">        Input container containing second input array.</span>
<span class="sd">    rtol</span>
<span class="sd">        The relative tolerance parameter.</span>
<span class="sd">    atol</span>
<span class="sd">        The absolute tolerance parameter.</span>
<span class="sd">    equal_nan</span>
<span class="sd">        Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in x1 will be</span>
<span class="sd">        considered equal to NaN&#39;s in x2 in the output array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new container holding the result is returned unless out is specified,</span>
<span class="sd">        in which it is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">    ...                         b=ivy.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">    ...                         b=ivy.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_allclose(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">    ...                         b=ivy.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2., 3.0003]),\</span>
<span class="sd">    ...                         b=ivy.array([1.0006, 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_allclose(x1, x2, rtol=1e-3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;allclose&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
        <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="allclose"><a class="viewcode-back" href="../../../functional/ivy/experimental/allclose/allclose_container.html#ivy.container.container_methods.allclose">[docs]</a><span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-08</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.allclose. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.allclose also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container containing first input array.</span>
<span class="sd">    x2</span>
<span class="sd">        Input container containing second input array.</span>
<span class="sd">    rtol</span>
<span class="sd">        The relative tolerance parameter.</span>
<span class="sd">    atol</span>
<span class="sd">        The absolute tolerance parameter.</span>
<span class="sd">    equal_nan</span>
<span class="sd">        Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in x1 will be</span>
<span class="sd">        considered equal to NaN&#39;s in x2 in the output array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A new container holding the result is returned unless out is specified,</span>
<span class="sd">        in which it is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">    ...                         b=ivy.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">    ...                         b=ivy.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.allclose(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">    ...                         b=ivy.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2., 3.0003]),\</span>
<span class="sd">    ...                         b=ivy.array([1.0006, 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.allclose(x2, rtol=1e-3)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_allclose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
        <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_fix"><a class="viewcode-back" href="../../../functional/ivy/experimental/fix/static_fix_container.html#ivy.container.container_methods.static_fix">[docs]</a><span class="k">def</span> <span class="nf">static_fix</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.fix. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.fix also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container with array items.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise rounding of</span>
<span class="sd">        input arrays elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2.1, 2.9, -2.1]),\</span>
<span class="sd">                           b=ivy.array([3.14]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_fix(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([ 2.,  2., -2.])</span>
<span class="sd">        b: ivy.array([ 3.0 ])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;fix&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fix"><a class="viewcode-back" href="../../../functional/ivy/experimental/fix/fix_container.html#ivy.container.container_methods.fix">[docs]</a><span class="k">def</span> <span class="nf">fix</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.fix. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fix also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container with array items.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with element-wise rounding of</span>
<span class="sd">        input arrays elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2.1, 2.9, -2.1]),\</span>
<span class="sd">                           b=ivy.array([3.14]))</span>
<span class="sd">    &gt;&gt;&gt; x.fix()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([ 2.,  2., -2.])</span>
<span class="sd">        b: ivy.array([ 3.0 ])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_nextafter"><a class="viewcode-back" href="../../../functional/ivy/experimental/nextafter/static_nextafter_container.html#ivy.container.container_methods.static_nextafter">[docs]</a><span class="k">def</span> <span class="nf">static_nextafter</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.nextafter. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.nextafter also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        Input container containing first input arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        Input container containing second input arrays.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including the next representable values of</span>
<span class="sd">        input container&#39;s arrays, element-wise</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1.0e-50, 2.0e+50]),\</span>
<span class="sd">    ...                         b=ivy.array([2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([5.5e-30]),\</span>
<span class="sd">    ...                         b=ivy.array([-2.0]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_nextafter(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.4013e-45., 3.4028e+38]),</span>
<span class="sd">        b: ivy.array([5.5e-30])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;nextafter&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="nextafter"><a class="viewcode-back" href="../../../functional/ivy/experimental/nextafter/nextafter_container.html#ivy.container.container_methods.nextafter">[docs]</a><span class="k">def</span> <span class="nf">nextafter</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.nextafter. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nextafter also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container containing first input array.</span>
<span class="sd">    x2</span>
<span class="sd">        Input container containing second input array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including the next representable values of</span>
<span class="sd">        input container&#39;s arrays, element-wise</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1.0e-50, 2.0e+50]),\</span>
<span class="sd">    ...                         b=ivy.array([2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([5.5e-30]),\</span>
<span class="sd">    ...                         b=ivy.array([-2.0]))</span>
<span class="sd">    &gt;&gt;&gt; x1.nextafter(x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.4013e-45., 3.4028e+38]),</span>
<span class="sd">        b: ivy.array([5.5e-30])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_nextafter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_zeta"><a class="viewcode-back" href="../../../functional/ivy/experimental/zeta/static_zeta_container.html#ivy.container.container_methods.static_zeta">[docs]</a><span class="k">def</span> <span class="nf">static_zeta</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.zeta. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.zeta also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input container containing first input arrays.</span>
<span class="sd">    q</span>
<span class="sd">        Input container containing second input arrays.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including the zeta function computed element-wise</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5.0, 3.0]),\</span>
<span class="sd">    ...                         b=ivy.array([2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; q = ivy.Container(a=ivy.array([2.0]),\</span>
<span class="sd">    ...                         b=ivy.array([5.0]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_zeta(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.0369, 0.2021]),</span>
<span class="sd">        b: ivy.array([0.0006, 0.0244])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;zeta&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">q</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="zeta"><a class="viewcode-back" href="../../../functional/ivy/experimental/zeta/zeta_container.html#ivy.container.container_methods.zeta">[docs]</a><span class="k">def</span> <span class="nf">zeta</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">q</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.zeta. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zeta also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container containing first input array.</span>
<span class="sd">    q</span>
<span class="sd">        Input container containing second input array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including the zeta function computed element-wise</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5.0, 3.0]),\</span>
<span class="sd">    ...                         b=ivy.array([2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; q = ivy.Container(a=ivy.array([2.0]),\</span>
<span class="sd">    ...                         b=ivy.array([5.0]))</span>
<span class="sd">    &gt;&gt;&gt; x.zeta(q)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.0369, 0.2021]),</span>
<span class="sd">        b: ivy.array([0.0006, 0.0244])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_zeta</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_median"><a class="viewcode-back" href="../../../functional/ivy/experimental/median/static_median_container.html#ivy.container.container_methods.static_median">[docs]</a><span class="k">def</span> <span class="nf">static_median</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.median. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.median also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input</span>
<span class="sd">        Input container including arrays.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the medians are computed. The default is to compute</span>
<span class="sd">        the median along a flattened version of the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result</span>
<span class="sd">        as dimensions with size one.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The median of the array elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.zeros((3, 4, 5)), b=ivy.zeros((2,7,6)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_moveaxis(x, 0, -1).shape</span>
<span class="sd">    {</span>
<span class="sd">        a: (4, 5, 3)</span>
<span class="sd">        b: (7, 6, 2)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;median&quot;</span><span class="p">,</span>
        <span class="nb">input</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="median"><a class="viewcode-back" href="../../../functional/ivy/experimental/median/median_container.html#ivy.container.container_methods.median">[docs]</a><span class="k">def</span> <span class="nf">median</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.median. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.median also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container including arrays.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the medians are computed. The default is to compute</span>
<span class="sd">        the median along a flattened version of the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result</span>
<span class="sd">        as dimensions with size one.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The median of the array elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(</span>
<span class="sd">    &gt;&gt;&gt;     a=ivy.array([[10, 7, 4], [3, 2, 1]]),</span>
<span class="sd">    &gt;&gt;&gt;     b=ivy.array([[1, 4, 2], [8, 7, 0]])</span>
<span class="sd">    &gt;&gt;&gt; )</span>
<span class="sd">    &gt;&gt;&gt; x.median(axis=0)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([6.5, 4.5, 2.5]),</span>
<span class="sd">        b: ivy.array([4.5, 5.5, 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_nanmean"><a class="viewcode-back" href="../../../functional/ivy/experimental/nanmean/static_nanmean_container.html#ivy.container.container_methods.static_nanmean">[docs]</a><span class="k">def</span> <span class="nf">static_nanmean</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.nanmean. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.nanmean also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input</span>
<span class="sd">        Input container including arrays.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the means are computed.</span>
<span class="sd">        The default is to compute the mean of the flattened array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result</span>
<span class="sd">        as dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the original a. If the value is anything but the default,</span>
<span class="sd">        then keepdims will be passed through to the mean or sum methods of </span>
<span class="sd">        sub-classes of ndarray. If the sub-classes methods does not implement </span>
<span class="sd">        keepdims any exceptions will be raised.</span>
<span class="sd">    dtype</span>
<span class="sd">        The desired data type of returned tensor. Default is None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The nanmean of the array elements in the container.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(x=ivy.array([[1, ivy.nan], [3, 4]]),\</span>
<span class="sd">                            y=ivy.array([[ivy.nan, 1, 2], [1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_moveaxis(a)</span>
<span class="sd">    {</span>
<span class="sd">        x: 2.6666666666666665</span>
<span class="sd">        y: 1.8</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;nanmean&quot;</span><span class="p">,</span>
        <span class="nb">input</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="nanmean"><a class="viewcode-back" href="../../../functional/ivy/experimental/nanmean/nanmean_container.html#ivy.container.container_methods.nanmean">[docs]</a><span class="k">def</span> <span class="nf">nanmean</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.nanmean. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nanmean also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container including arrays.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis or axes along which the means are computed.</span>
<span class="sd">        The default is to compute the mean of the flattened array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result</span>
<span class="sd">        as dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the original a. If the value is anything but the default,</span>
<span class="sd">        then keepdims will be passed through to the mean or sum methods of </span>
<span class="sd">        sub-classes of ndarray. If the sub-classes methods does not implement </span>
<span class="sd">        keepdims any exceptions will be raised.</span>
<span class="sd">    dtype</span>
<span class="sd">        The desired data type of returned tensor. Default is None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The nanmean of the array elements in the input container.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(x=ivy.array([[1, ivy.nan], [3, 4]]),\</span>
<span class="sd">                            y=ivy.array([[ivy.nan, 1, 2], [1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; a.nanmean()</span>
<span class="sd">    {</span>
<span class="sd">        x: 2.6666666666666665</span>
<span class="sd">        y: 1.8</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_nanmean</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_unravel_index"><a class="viewcode-back" href="../../../functional/ivy/experimental/unravel_index/static_unravel_index_container.html#ivy.container.container_methods.static_unravel_index">[docs]</a><span class="k">def</span> <span class="nf">static_unravel_index</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.unravel_index.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.unravel_index also applies to this method with minimal</span>
<span class="sd">    changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input</span>
<span class="sd">        Input container including arrays.</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the array to use for unraveling indices.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with tuples that have arrays with the same shape as</span>
<span class="sd">        the arrays in the input container.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.Container(a=ivy.array([22, 41, 37])), b=ivy.array([30, 2]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_unravel_index(indices, (7,6))</span>
<span class="sd">    {</span>
<span class="sd">        a: (ivy.array([3, 6, 6]), ivy.array([4, 5, 1]))</span>
<span class="sd">        b: (ivy.array([5, 0], ivy.array([0, 2])))</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;unravel_index&quot;</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="unravel_index"><a class="viewcode-back" href="../../../functional/ivy/experimental/unravel_index/unravel_index_container.html#ivy.container.container_methods.unravel_index">[docs]</a><span class="k">def</span> <span class="nf">unravel_index</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.unravel_index.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.unravel_index also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container including arrays.</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the array to use for unraveling indices.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with tuples that have arrays with the same shape as</span>
<span class="sd">        the arrays in the input container.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.Container(a=ivy.array([22, 41, 37])), b=ivy.array([30, 2]))</span>
<span class="sd">    &gt;&gt;&gt; indices.unravel_index((7, 6))</span>
<span class="sd">    {</span>
<span class="sd">        a: (ivy.array([3, 6, 6]), ivy.array([4, 5, 1]))</span>
<span class="sd">        b: (ivy.array([5, 0], ivy.array([0, 2])))</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_unravel_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_diagflat"><a class="viewcode-back" href="../../../functional/ivy/experimental/diagflat/static_diagflat_container.html#ivy.container.container_methods.static_diagflat">[docs]</a><span class="k">def</span> <span class="nf">static_diagflat</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">padding_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">align</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;RIGHT_LEFT&quot;</span><span class="p">,</span>
    <span class="n">num_rows</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">num_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;diagflat&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">padding_value</span><span class="o">=</span><span class="n">padding_value</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
        <span class="n">num_rows</span><span class="o">=</span><span class="n">num_rows</span><span class="p">,</span>
        <span class="n">num_cols</span><span class="o">=</span><span class="n">num_cols</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="diagflat"><a class="viewcode-back" href="../../../functional/ivy/experimental/diagflat/diagflat_container.html#ivy.container.container_methods.diagflat">[docs]</a><span class="k">def</span> <span class="nf">diagflat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">padding_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">align</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;RIGHT_LEFT&quot;</span><span class="p">,</span>
    <span class="n">num_rows</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">num_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.diagflat.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.diagflat also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=[1,2])</span>
<span class="sd">    &gt;&gt;&gt; ivy.diagflat(x, k=1)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1, 0],</span>
<span class="sd">                      [0, 0, 2],</span>
<span class="sd">                      [0, 0, 0]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_diagflat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">padding_value</span><span class="o">=</span><span class="n">padding_value</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
        <span class="n">num_rows</span><span class="o">=</span><span class="n">num_rows</span><span class="p">,</span>
        <span class="n">num_cols</span><span class="o">=</span><span class="n">num_cols</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_kron"><a class="viewcode-back" href="../../../functional/ivy/experimental/kron/static_kron_container.html#ivy.container.container_methods.static_kron">[docs]</a><span class="k">def</span> <span class="nf">static_kron</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.kron. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.kron also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a</span>
<span class="sd">        first container with input arrays.</span>
<span class="sd">    b</span>
<span class="sd">        second container with input arrays</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays corresponding to the Kronecker product of</span>
<span class="sd">        the arrays in the input containers, computed element-wise</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(x=ivy.array([1,2]), y=ivy.array(50))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(x=ivy.array([3,4]), y=ivy.array(9))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_kron(a, b)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3, 4, 6, 8])</span>
<span class="sd">        b: ivy.array([450])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;kron&quot;</span><span class="p">,</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">b</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="kron"><a class="viewcode-back" href="../../../functional/ivy/experimental/kron/kron_container.html#ivy.container.container_methods.kron">[docs]</a><span class="k">def</span> <span class="nf">kron</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.kron.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.kron also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(x=ivy.array([1,2]), y=ivy.array([50]))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(x=ivy.array([3,4]), y=ivy.array(9))</span>
<span class="sd">    &gt;&gt;&gt; a.kron(b)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3, 4, 6, 8])</span>
<span class="sd">        b: ivy.array([450])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_kron</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">b</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_msort"><a class="viewcode-back" href="../../../functional/ivy/experimental/msort/static_msort_container.html#ivy.container.container_methods.static_msort">[docs]</a><span class="k">def</span> <span class="nf">static_msort</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.msort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.msort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a</span>
<span class="sd">        array-like or container input.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing sorted input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.Container(x = ivy.randint(10, size=(2,3)),</span>
<span class="sd">    ...                   y = ivy.randint(5, size=(2,2))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_msort(a)</span>
<span class="sd">    {</span>
<span class="sd">        x: ivy.array(</span>
<span class="sd">            [[6, 2, 6],</span>
<span class="sd">             [8, 9, 6]]</span>
<span class="sd">            ),</span>
<span class="sd">        y: ivy.array(</span>
<span class="sd">            [[0, 0],</span>
<span class="sd">             [4, 0]]</span>
<span class="sd">            )</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;msort&quot;</span><span class="p">,</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="msort"><a class="viewcode-back" href="../../../functional/ivy/experimental/msort/msort_container.html#ivy.container.container_methods.msort">[docs]</a><span class="k">def</span> <span class="nf">msort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.msort.</span>
<span class="sd">    This method simply wraps the function, and</span>
<span class="sd">    so the docstring for ivy.msort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container with array-like inputs to sort.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the sorted input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(x = ivy.randint(10, size=(2,3)),</span>
<span class="sd">    ...                   y = ivy.randint(5, size=(2,2))</span>
<span class="sd">    &gt;&gt;&gt; a.msort()</span>
<span class="sd">    {</span>
<span class="sd">        x: ivy.array(</span>
<span class="sd">            [[6, 2, 6],</span>
<span class="sd">             [8, 9, 6]]</span>
<span class="sd">            ),</span>
<span class="sd">        y: ivy.array(</span>
<span class="sd">            [[0, 0],</span>
<span class="sd">             [4, 0]]</span>
<span class="sd">            )</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_msort</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_moveaxis"><a class="viewcode-back" href="../../../functional/ivy/experimental/moveaxis/static_moveaxis_container.html#ivy.container.container_methods.static_moveaxis">[docs]</a><span class="k">def</span> <span class="nf">static_moveaxis</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">destination</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.moveaxis. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.moveaxis also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a</span>
<span class="sd">        The container with the arrays whose axes should be reordered.</span>
<span class="sd">    source</span>
<span class="sd">        Original positions of the axes to move. These must be unique.</span>
<span class="sd">    destination</span>
<span class="sd">        Destination positions for each of the original axes.</span>
<span class="sd">        These must also be unique.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with moved axes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.zeros((3, 4, 5)), b=ivy.zeros((2,7,6)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_moveaxis(x, 0, -1).shape</span>
<span class="sd">    {</span>
<span class="sd">        a: (4, 5, 3)</span>
<span class="sd">        b: (7, 6, 2)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;moveaxis&quot;</span><span class="p">,</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">destination</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="moveaxis"><a class="viewcode-back" href="../../../functional/ivy/experimental/moveaxis/moveaxis_container.html#ivy.container.container_methods.moveaxis">[docs]</a><span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">destination</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.moveaxis. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flatten also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The container with the arrays whose axes should be reordered.</span>
<span class="sd">    source</span>
<span class="sd">        Original positions of the axes to move. These must be unique.</span>
<span class="sd">    destination</span>
<span class="sd">        Destination positions for each of the original axes.</span>
<span class="sd">        These must also be unique.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container including arrays with moved axes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.zeros((3, 4, 5)), b=ivy.zeros((2,7,6)))</span>
<span class="sd">    &gt;&gt;&gt; x.moveaxis(, 0, -1).shape</span>
<span class="sd">    {</span>
<span class="sd">        a: (4, 5, 3)</span>
<span class="sd">        b: (7, 6, 2)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_heaviside"><a class="viewcode-back" href="../../../functional/ivy/experimental/heaviside/static_heaviside_container.html#ivy.container.container_methods.static_heaviside">[docs]</a><span class="k">def</span> <span class="nf">static_heaviside</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.heaviside. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.heaviside also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input container including the arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        values to use where the array is zero.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        output container with element-wise Heaviside step function of each array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([-1.5, 0, 2.0]), b=ivy.array([3.0, 5.0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=0.5, b=[1.0, 2.0])</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_heaviside(x1, x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([ 0. ,  0.5,  1. ])</span>
<span class="sd">        b: ivy.array([1.0, 1.0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;heaviside&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="heaviside"><a class="viewcode-back" href="../../../functional/ivy/experimental/heaviside/heaviside_container.html#ivy.container.container_methods.heaviside">[docs]</a><span class="k">def</span> <span class="nf">heaviside</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.heaviside. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.heaviside also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container including the arrays.</span>
<span class="sd">    x2</span>
<span class="sd">        values to use where the array is zero.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        output container with element-wise Heaviside step function of each array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Array` input:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([-1.5, 0, 2.0]), b=ivy.array([3.0, 5.0])</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=0.5, b=[1.0, 2.0])</span>
<span class="sd">    &gt;&gt;&gt; x1.heaviside(x2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([ 0. ,  0.5,  1. ])</span>
<span class="sd">        b: ivy.array([1.0, 1.0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_heaviside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_flipud"><a class="viewcode-back" href="../../../functional/ivy/experimental/flipud/static_flipud_container.html#ivy.container.container_methods.static_flipud">[docs]</a><span class="k">def</span> <span class="nf">static_flipud</span><span class="p">(</span>
    <span class="n">m</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.flipud. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.flipud also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m</span>
<span class="sd">        the container with arrays to be flipped.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays corresponding to the input container&#39;s array</span>
<span class="sd">        with elements order reversed along axis 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.Container(a=ivy.diag([1, 2, 3]), b=ivy.arange(4))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_flipud(m)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(</span>
<span class="sd">            [[ 0.,  0.,  3.],</span>
<span class="sd">             [ 0.,  2.,  0.],</span>
<span class="sd">             [ 1.,  0.,  0.]]</span>
<span class="sd">        )</span>
<span class="sd">        b: ivy.array([3, 2, 1, 0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;flipud&quot;</span><span class="p">,</span>
        <span class="n">m</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="flipud"><a class="viewcode-back" href="../../../functional/ivy/experimental/flipud/flipud_container.html#ivy.container.container_methods.flipud">[docs]</a><span class="k">def</span> <span class="nf">flipud</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.flipud. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flipud also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        the container with arrays to be flipped.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays corresponding to the input container&#39;s array</span>
<span class="sd">        with elements order reversed along axis 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.Container(a=ivy.diag([1, 2, 3]), b=ivy.arange(4))</span>
<span class="sd">    &gt;&gt;&gt; m.flipud()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(</span>
<span class="sd">            [[ 0.,  0.,  3.],</span>
<span class="sd">             [ 0.,  2.,  0.],</span>
<span class="sd">             [ 1.,  0.,  0.]]</span>
<span class="sd">        )</span>
<span class="sd">        b: ivy.array([3, 2, 1, 0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_flipud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="vstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/vstack/vstack_container.html#ivy.container.container_methods.vstack">[docs]</a><span class="k">def</span> <span class="nf">vstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stack</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[3, 2], [1,0]]), b=ivy.array([[1, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; x.vstack([y])</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[0, 1],</span>
<span class="sd">                    [2, 3]],</span>
<span class="sd">                    [[3, 2],</span>
<span class="sd">                    [1, 0]]]),</span>
<span class="sd">        b: ivy.array([[[4, 5]],</span>
<span class="sd">                    [[1, 0]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_xs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_xs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_vstack</span><span class="p">(</span>
        <span class="n">new_xs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_vstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/vstack/static_vstack_container.html#ivy.container.container_methods.static_vstack">[docs]</a><span class="k">def</span> <span class="nf">static_vstack</span><span class="p">(</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stack. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.vstack also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; c = ivy.Container(a=[ivy.array([1,2,3]), ivy.array([0,0,0])],</span>
<span class="sd">                          b=ivy.arange(3))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_vstack(c)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 2, 3],</span>
<span class="sd">                      [0, 0, 0]]),</span>
<span class="sd">        b: ivy.array([[0],</span>
<span class="sd">                      [1],</span>
<span class="sd">                      [2]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;vstack&quot;</span><span class="p">,</span>
        <span class="n">xs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="hstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/hstack/hstack_container.html#ivy.container.container_methods.hstack">[docs]</a><span class="k">def</span> <span class="nf">hstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.hstack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.hstack</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[3, 2], [1,0]]), b=ivy.array([[1, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; x.hstack([y])</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1, 3, 2],</span>
<span class="sd">                      [2, 3, 1, 0]]),</span>
<span class="sd">        b: ivy.array([[4, 5, 1, 0]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_xs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_xs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_hstack</span><span class="p">(</span>
        <span class="n">new_xs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_hstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/hstack/static_hstack_container.html#ivy.container.container_methods.static_hstack">[docs]</a><span class="k">def</span> <span class="nf">static_hstack</span><span class="p">(</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.hstack. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.hstack also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; c = ivy.Container(a=[ivy.array([1,2,3]), ivy.array([0,0,0])])</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_hstack(c)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 3, 0, 0, 0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;hstack&quot;</span><span class="p">,</span>
        <span class="n">xs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_rot90"><a class="viewcode-back" href="../../../functional/ivy/experimental/rot90/static_rot90_container.html#ivy.container.container_methods.static_rot90">[docs]</a><span class="k">def</span> <span class="nf">static_rot90</span><span class="p">(</span>
    <span class="n">m</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.rot90.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.rot90 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m</span>
<span class="sd">        Input array of two or more dimensions.</span>
<span class="sd">    k</span>
<span class="sd">        Number of times the array is rotated by 90 degrees.</span>
<span class="sd">    axes</span>
<span class="sd">        The array is rotated in the plane defined by the axes. Axes must be</span>
<span class="sd">        different.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with a rotated view of m.</span>
<span class="sd">        </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.Container(a=ivy.array([[1,2], [3,4]]),\</span>
<span class="sd">                    b=ivy.array([[1,2,3,4],\</span>
<span class="sd">                                [7,8,9,10]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_rot90(m)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[2, 4],</span>
<span class="sd">                      [1, 3]]),</span>
<span class="sd">        b: ivy.array([[4, 10],</span>
<span class="sd">                      [3, 9],</span>
<span class="sd">                      [2, 8],</span>
<span class="sd">                      [1, 7]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;rot90&quot;</span><span class="p">,</span>
        <span class="n">m</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="rot90"><a class="viewcode-back" href="../../../functional/ivy/experimental/rot90/rot90_container.html#ivy.container.container_methods.rot90">[docs]</a><span class="k">def</span> <span class="nf">rot90</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.rot90.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.rot90 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array of two or more dimensions.</span>
<span class="sd">    k</span>
<span class="sd">        Number of times the array is rotated by 90 degrees.</span>
<span class="sd">    axes</span>
<span class="sd">        The array is rotated in the plane defined by the axes. Axes must be</span>
<span class="sd">        different.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with a rotated view of input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.Container(a=ivy.array([[1,2], [3,4]]),\</span>
<span class="sd">                    b=ivy.array([[1,2,3,4],\</span>
<span class="sd">                                [7,8,9,10]]))</span>
<span class="sd">    &gt;&gt;&gt; m.rot90()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[2, 4],</span>
<span class="sd">                      [1, 3]]),</span>
<span class="sd">        b: ivy.array([[4, 10],</span>
<span class="sd">                      [3, 9],</span>
<span class="sd">                      [2, 8],</span>
<span class="sd">                      [1, 7]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_rot90</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_top_k"><a class="viewcode-back" href="../../../functional/ivy/experimental/top_k/static_top_k_container.html#ivy.container.container_methods.static_top_k">[docs]</a><span class="k">def</span> <span class="nf">static_top_k</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">largest</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.top_k. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.top_k also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The container to compute top_k for.</span>
<span class="sd">    k</span>
<span class="sd">        Number of top elements to retun must not exceed the array size.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which we must return the top elements default value is 1.</span>
<span class="sd">    largest</span>
<span class="sd">        If largest is set to False we return k smallest elements of the array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``</span>
<span class="sd">    out:</span>
<span class="sd">        Optional output tuple, for writing the result to. Must have two Container,</span>
<span class="sd">        with a shape that the returned tuple broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with indices and values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 2, -4]), b=ivy.array([4., 5., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_top_k(x, 2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: [</span>
<span class="sd">            values = ivy.array([ 2, -1]),</span>
<span class="sd">            indices = ivy.array([1, 0])</span>
<span class="sd">        ],</span>
<span class="sd">        b: [</span>
<span class="sd">            values = ivy.array([5., 4.]),</span>
<span class="sd">            indices = ivy.array([1, 0])</span>
<span class="sd">        ]</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;top_k&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">largest</span><span class="o">=</span><span class="n">largest</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="top_k"><a class="viewcode-back" href="../../../functional/ivy/experimental/top_k/top_k_container.html#ivy.container.container_methods.top_k">[docs]</a><span class="k">def</span> <span class="nf">top_k</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">largest</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.top_k. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.top_k</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The container to compute top_k for.</span>
<span class="sd">    k</span>
<span class="sd">        Number of top elements to retun must not exceed the array size.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which we must return the top elements default value is 1.</span>
<span class="sd">    largest</span>
<span class="sd">        If largest is set to False we return k smallest elements of the array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``</span>
<span class="sd">    out:</span>
<span class="sd">        Optional output tuple, for writing the result to. Must have two Container,</span>
<span class="sd">        with a shape that the returned tuple broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with indices and values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 2, -4]), b=ivy.array([4., 5., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.top_k(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: [</span>
<span class="sd">            values = ivy.array([ 2, -1]),</span>
<span class="sd">            indices = ivy.array([1, 0])</span>
<span class="sd">        ],</span>
<span class="sd">        b: [</span>
<span class="sd">            values = ivy.array([5., 4.]),</span>
<span class="sd">            indices = ivy.array([1, 0])</span>
<span class="sd">        ]</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_top_k</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">largest</span><span class="o">=</span><span class="n">largest</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_fliplr"><a class="viewcode-back" href="../../../functional/ivy/experimental/fliplr/static_fliplr_container.html#ivy.container.container_methods.static_fliplr">[docs]</a><span class="k">def</span> <span class="nf">static_fliplr</span><span class="p">(</span>
    <span class="n">m</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.fliplr. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.fliplr also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m</span>
<span class="sd">        the container with arrays to be flipped. Arrays must be at least 2-D.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays corresponding to the input container&#39;s array</span>
<span class="sd">        with elements order reversed along axis 1.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.Container(a=ivy.diag([1, 2, 3]),\</span>
<span class="sd">                        b=ivy.array([[1, 2, 3],[4, 5, 6]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_fliplr(m)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 0, 1],</span>
<span class="sd">                      [0, 2, 0],</span>
<span class="sd">                      [3, 0, 0]]),</span>
<span class="sd">        b: ivy.array([[3, 2, 1],</span>
<span class="sd">                      [6, 5, 4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;fliplr&quot;</span><span class="p">,</span>
        <span class="n">m</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fliplr"><a class="viewcode-back" href="../../../functional/ivy/experimental/fliplr/fliplr_container.html#ivy.container.container_methods.fliplr">[docs]</a><span class="k">def</span> <span class="nf">fliplr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.fliplr. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.fliplr also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        the container with arrays to be flipped. Arrays must be at least 2-D.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays corresponding to the input container&#39;s array</span>
<span class="sd">        with elements order reversed along axis 1.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.Container(a=ivy.diag([1, 2, 3]),\</span>
<span class="sd">                        b=ivy.array([[1, 2, 3],[4, 5, 6]]))</span>
<span class="sd">    &gt;&gt;&gt; m.fliplr()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 0, 1],</span>
<span class="sd">                      [0, 2, 0],</span>
<span class="sd">                      [3, 0, 0]]),</span>
<span class="sd">        b: ivy.array([[3, 2, 1],</span>
<span class="sd">                      [6, 5, 4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_fliplr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_i0"><a class="viewcode-back" href="../../../functional/ivy/experimental/i0/static_i0_container.html#ivy.container.container_methods.static_i0">[docs]</a><span class="k">def</span> <span class="nf">static_i0</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.i0. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.i0 also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        the container with array inputs.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays with the modified Bessel</span>
<span class="sd">        function evaluated at each of the elements of x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array(4))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_i0(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.26606588, 2.2795853 , 4.88079259])</span>
<span class="sd">        b: ivy.array(11.30192195)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;i0&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="i0"><a class="viewcode-back" href="../../../functional/ivy/experimental/i0/i0_container.html#ivy.container.container_methods.i0">[docs]</a><span class="k">def</span> <span class="nf">i0</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.i0. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.i0 also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        the container with array inputs.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays with the modified Bessel</span>
<span class="sd">        function evaluated at each of the elements of x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array(4))</span>
<span class="sd">    &gt;&gt;&gt; x.i0()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.26606588, 2.2795853 , 4.88079259])</span>
<span class="sd">        b: ivy.array(11.30192195)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_i0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_flatten"><a class="viewcode-back" href="../../../functional/ivy/experimental/flatten/static_flatten_container.html#ivy.container.container_methods.static_flatten">[docs]</a><span class="k">def</span> <span class="nf">static_flatten</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">start_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">end_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.flatten. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.flatten also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to flatten at leaves.</span>
<span class="sd">    start_dim</span>
<span class="sd">        first dim to flatten. If not set, defaults to 0.</span>
<span class="sd">    end_dim</span>
<span class="sd">        last dim to flatten. If not set, defaults to -1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with arrays flattened at leaves.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[9, 10], [11, 12]], [[13, 14], [15, 16]]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.flatten(x)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([1, 2, 3, 4, 5, 6, 7, 8])</span>
<span class="sd">        b: ivy.array([9, 10, 11, 12, 13, 14, 15, 16])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;flatten&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">start_dim</span><span class="o">=</span><span class="n">start_dim</span><span class="p">,</span>
        <span class="n">end_dim</span><span class="o">=</span><span class="n">end_dim</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="flatten"><a class="viewcode-back" href="../../../functional/ivy/experimental/flatten/flatten_container.html#ivy.container.container_methods.flatten">[docs]</a><span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">start_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">end_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.flatten. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flatten also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container to flatten at leaves.</span>
<span class="sd">    start_dim</span>
<span class="sd">        first dim to flatten. If not set, defaults to 0.</span>
<span class="sd">    end_dim</span>
<span class="sd">        last dim to flatten. If not set, defaults to -1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container with arrays flattened at leaves.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[9, 10], [11, 12]], [[13, 14], [15, 16]]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.flatten(x)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([1, 2, 3, 4, 5, 6, 7, 8])</span>
<span class="sd">        b: ivy.array([9, 10, 11, 12, 13, 14, 15, 16])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="n">start_dim</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=</span><span class="n">end_dim</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_pad"><a class="viewcode-back" href="../../../functional/ivy/experimental/pad/static_pad_container.html#ivy.container.container_methods.static_pad">[docs]</a><span class="k">def</span> <span class="nf">static_pad</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span>
            <span class="n">Literal</span><span class="p">[</span>
                <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
                <span class="s2">&quot;edge&quot;</span><span class="p">,</span>
                <span class="s2">&quot;linear_ramp&quot;</span><span class="p">,</span>
                <span class="s2">&quot;maximum&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                <span class="s2">&quot;median&quot;</span><span class="p">,</span>
                <span class="s2">&quot;minimum&quot;</span><span class="p">,</span>
                <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
                <span class="s2">&quot;symmetric&quot;</span><span class="p">,</span>
                <span class="s2">&quot;wrap&quot;</span><span class="p">,</span>
                <span class="s2">&quot;empty&quot;</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">Callable</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">stat_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">constant_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span> <span class="n">Number</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">end_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span> <span class="n">Number</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">reflect_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;even&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;even&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.pad also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;pad&quot;</span><span class="p">,</span>
        <span class="nb">input</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">stat_length</span><span class="o">=</span><span class="n">stat_length</span><span class="p">,</span>
        <span class="n">constant_values</span><span class="o">=</span><span class="n">constant_values</span><span class="p">,</span>
        <span class="n">end_values</span><span class="o">=</span><span class="n">end_values</span><span class="p">,</span>
        <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="pad"><a class="viewcode-back" href="../../../functional/ivy/experimental/pad/pad_container.html#ivy.container.container_methods.pad">[docs]</a><span class="k">def</span> <span class="nf">pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span>
            <span class="n">Literal</span><span class="p">[</span>
                <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
                <span class="s2">&quot;edge&quot;</span><span class="p">,</span>
                <span class="s2">&quot;linear_ramp&quot;</span><span class="p">,</span>
                <span class="s2">&quot;maximum&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                <span class="s2">&quot;median&quot;</span><span class="p">,</span>
                <span class="s2">&quot;minimum&quot;</span><span class="p">,</span>
                <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
                <span class="s2">&quot;symmetric&quot;</span><span class="p">,</span>
                <span class="s2">&quot;wrap&quot;</span><span class="p">,</span>
                <span class="s2">&quot;empty&quot;</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">Callable</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">stat_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">constant_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span> <span class="n">Number</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">end_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span> <span class="n">Number</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">reflect_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;even&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;even&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.pad also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">stat_length</span><span class="o">=</span><span class="n">stat_length</span><span class="p">,</span>
        <span class="n">constant_values</span><span class="o">=</span><span class="n">constant_values</span><span class="p">,</span>
        <span class="n">end_values</span><span class="o">=</span><span class="n">end_values</span><span class="p">,</span>
        <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_vsplit"><a class="viewcode-back" href="../../../functional/ivy/experimental/vsplit/static_vsplit_container.html#ivy.container.container_methods.static_vsplit">[docs]</a><span class="k">def</span> <span class="nf">static_vsplit</span><span class="p">(</span>
    <span class="n">ary</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">indices_or_sections</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.vsplit. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.vsplit also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary</span>
<span class="sd">        the container with array inputs.</span>
<span class="sd">    indices_or_sections</span>
<span class="sd">        If indices_or_sections is an integer n, the array is split into n sections.</span>
<span class="sd">        If the array is divisible by n vertically, each section will be of equal</span>
<span class="sd">        size. If input is not divisible by n, the sizes of the first</span>
<span class="sd">        int(ary.size(0) % n) sections will have size int(ary.size(0) / n) + 1, and</span>
<span class="sd">        the rest will have size int(ary.size(0) / n).</span>
<span class="sd">        If indices_or_sections is a tuple of ints, then input is split at each of</span>
<span class="sd">        the indices in the tuple.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including input arrays split vertically.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary = ivy.Container(</span>
<span class="sd">        a = ivy.ivy.array(</span>
<span class="sd">                [[[0.,  1.],</span>
<span class="sd">                  [2.,  3.]],</span>
<span class="sd">                  [[4.,  5.],</span>
<span class="sd">                  [6.,  7.]]]</span>
<span class="sd">            ),</span>
<span class="sd">        b=ivy.array(</span>
<span class="sd">                [[ 0.,  1.,  2.,  3.],</span>
<span class="sd">                 [ 4.,  5.,  6.,  7.],</span>
<span class="sd">                 [ 8.,  9., 10., 11.],</span>
<span class="sd">                 [12., 13., 14., 15.]])</span>
<span class="sd">            )</span>
<span class="sd">        )</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_vsplit(ary, 2)</span>
<span class="sd">    {</span>
<span class="sd">        a: [ivy.array([[[0., 1.], [2., 3.]]]),</span>
<span class="sd">            ivy.array([[[4., 5.], [6., 7.]]])],</span>
<span class="sd">        b: [ivy.array([[0., 1., 2., 3.], [4., 5., 6., 7.]]),</span>
<span class="sd">            ivy.array([[ 8.,  9., 10., 11.], [12., 13., 14., 15.]])]</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;vsplit&quot;</span><span class="p">,</span>
        <span class="n">ary</span><span class="p">,</span>
        <span class="n">indices_or_sections</span><span class="o">=</span><span class="n">indices_or_sections</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vsplit"><a class="viewcode-back" href="../../../functional/ivy/experimental/vsplit/vsplit_container.html#ivy.container.container_methods.vsplit">[docs]</a><span class="k">def</span> <span class="nf">vsplit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">indices_or_sections</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.vsplit. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.vsplit also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        the container with array inputs.</span>
<span class="sd">    indices_or_sections</span>
<span class="sd">        If indices_or_sections is an integer n, the array is split into n sections.</span>
<span class="sd">        If the array is divisible by n vertically, each section will be of equal</span>
<span class="sd">        size. If input is not divisible by n, the sizes of the first</span>
<span class="sd">        int(ary.size(0) % n) sections will have size int(ary.size(0) / n) + 1, and</span>
<span class="sd">        the rest will have size int(ary.size(0) / n).</span>
<span class="sd">        If indices_or_sections is a tuple of ints, then input is split at each of</span>
<span class="sd">        the indices in the tuple.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays with the modified Bessel</span>
<span class="sd">        function evaluated at each of the elements of x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary = ivy.Container(</span>
<span class="sd">        a = ivy.ivy.array(</span>
<span class="sd">                [[[0.,  1.],</span>
<span class="sd">                  [2.,  3.]],</span>
<span class="sd">                  [[4.,  5.],</span>
<span class="sd">                  [6.,  7.]]]</span>
<span class="sd">            ),</span>
<span class="sd">        b=ivy.array(</span>
<span class="sd">                [[ 0.,  1.,  2.,  3.],</span>
<span class="sd">                 [ 4.,  5.,  6.,  7.],</span>
<span class="sd">                 [ 8.,  9., 10., 11.],</span>
<span class="sd">                 [12., 13., 14., 15.]])</span>
<span class="sd">            )</span>
<span class="sd">        )</span>
<span class="sd">    &gt;&gt;&gt; ary.vsplit(2)</span>
<span class="sd">    {</span>
<span class="sd">        a: [ivy.array([[[0., 1.], [2., 3.]]]),</span>
<span class="sd">            ivy.array([[[4., 5.], [6., 7.]]])],</span>
<span class="sd">        b: [ivy.array([[0., 1., 2., 3.], [4., 5., 6., 7.]]),</span>
<span class="sd">            ivy.array([[ 8.,  9., 10., 11.], [12., 13., 14., 15.]])]</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_vsplit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="o">=</span><span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_dsplit"><a class="viewcode-back" href="../../../functional/ivy/experimental/dsplit/static_dsplit_container.html#ivy.container.container_methods.static_dsplit">[docs]</a><span class="k">def</span> <span class="nf">static_dsplit</span><span class="p">(</span>
    <span class="n">ary</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">indices_or_sections</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.dsplit. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.dsplit also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary</span>
<span class="sd">        the container with array inputs.</span>
<span class="sd">    indices_or_sections</span>
<span class="sd">        If indices_or_sections is an integer n, the array is split into n sections.</span>
<span class="sd">        If the array is divisible by n along the 3rd axis, each section will be of</span>
<span class="sd">        equal size. If input is not divisible by n, the sizes of the first</span>
<span class="sd">        int(ary.size(0) % n) sections will have size int(ary.size(0) / n) + 1, and</span>
<span class="sd">        the rest will have size int(ary.size(0) / n).</span>
<span class="sd">        If indices_or_sections is a tuple of ints, then input is split at each of</span>
<span class="sd">        the indices in the tuple.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including input arrays split along the 3rd axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary = ivy.Container(</span>
<span class="sd">        a = ivy.ivy.array(</span>
<span class="sd">                [[[0.,  1.],</span>
<span class="sd">                  [2.,  3.]],</span>
<span class="sd">                  [[4.,  5.],</span>
<span class="sd">                  [6.,  7.]]]</span>
<span class="sd">            ),</span>
<span class="sd">        b=ivy.array(</span>
<span class="sd">                [[ 0.,  1.,  2.,  3.],</span>
<span class="sd">                 [ 4.,  5.,  6.,  7.],</span>
<span class="sd">                 [ 8.,  9., 10., 11.],</span>
<span class="sd">                 [12., 13., 14., 15.]])</span>
<span class="sd">            )</span>
<span class="sd">        )</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_dsplit(ary, 2)</span>
<span class="sd">    {</span>
<span class="sd">        a: [ivy.array([[[0., 1.], [2., 3.]]]),</span>
<span class="sd">            ivy.array([[[4., 5.], [6., 7.]]])],</span>
<span class="sd">        b: [ivy.array([[0., 1., 2., 3.], [4., 5., 6., 7.]]),</span>
<span class="sd">            ivy.array([[ 8.,  9., 10., 11.], [12., 13., 14., 15.]])]</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;dsplit&quot;</span><span class="p">,</span>
        <span class="n">ary</span><span class="p">,</span>
        <span class="n">indices_or_sections</span><span class="o">=</span><span class="n">indices_or_sections</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dsplit"><a class="viewcode-back" href="../../../functional/ivy/experimental/dsplit/dsplit_container.html#ivy.container.container_methods.dsplit">[docs]</a><span class="k">def</span> <span class="nf">dsplit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">indices_or_sections</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.dsplit. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.dsplit also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        the container with array inputs.</span>
<span class="sd">    indices_or_sections</span>
<span class="sd">        If indices_or_sections is an integer n, the array is split into n sections.</span>
<span class="sd">        If the array is divisible by n along the 3rd axis, each section will be of</span>
<span class="sd">        equal size. If input is not divisible by n, the sizes of the first</span>
<span class="sd">        int(ary.size(0) % n) sections will have size int(ary.size(0) / n) + 1, and</span>
<span class="sd">        the rest will have size int(ary.size(0) / n).</span>
<span class="sd">        If indices_or_sections is a tuple of ints, then input is split at each of</span>
<span class="sd">        the indices in the tuple.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including arrays with the modified Bessel</span>
<span class="sd">        function evaluated at each of the elements of x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary = ivy.Container(</span>
<span class="sd">        a = ivy.ivy.array(</span>
<span class="sd">                [[[0.,  1.],</span>
<span class="sd">                  [2.,  3.]],</span>
<span class="sd">                  [[4.,  5.],</span>
<span class="sd">                  [6.,  7.]]]</span>
<span class="sd">            ),</span>
<span class="sd">        b=ivy.array(</span>
<span class="sd">                [[ 0.,  1.,  2.,  3.],</span>
<span class="sd">                 [ 4.,  5.,  6.,  7.],</span>
<span class="sd">                 [ 8.,  9., 10., 11.],</span>
<span class="sd">                 [12., 13., 14., 15.]])</span>
<span class="sd">            )</span>
<span class="sd">        )</span>
<span class="sd">    &gt;&gt;&gt; ary.dsplit(2)</span>
<span class="sd">    {</span>
<span class="sd">        a: [ivy.array([[[0., 1.], [2., 3.]]]),</span>
<span class="sd">            ivy.array([[[4., 5.], [6., 7.]]])],</span>
<span class="sd">        b: [ivy.array([[0., 1., 2., 3.], [4., 5., 6., 7.]]),</span>
<span class="sd">            ivy.array([[ 8.,  9., 10., 11.], [12., 13., 14., 15.]])]</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_dsplit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="o">=</span><span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/dstack/dstack_container.html#ivy.container.container_methods.dstack">[docs]</a><span class="k">def</span> <span class="nf">dstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stack</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[3, 2], [1,0]]), b=ivy.array([[1, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; x.dstack([y])</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[0, 3],</span>
<span class="sd">                       [1, 2]],</span>
<span class="sd">                      [[2, 1],</span>
<span class="sd">                       [3, 0]]]),</span>
<span class="sd">        b: ivy.array([[[4, 1]],</span>
<span class="sd">                       [[5, 0]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_xs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_xs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_dstack</span><span class="p">(</span>
        <span class="n">new_xs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_dstack"><a class="viewcode-back" href="../../../functional/ivy/experimental/dstack/static_dstack_container.html#ivy.container.container_methods.static_dstack">[docs]</a><span class="k">def</span> <span class="nf">static_dstack</span><span class="p">(</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stack. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.dstack also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; c = ivy.Container(a=[ivy.array([1,2,3]), ivy.array([0,0,0])],</span>
<span class="sd">                          b=ivy.arange(3))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_dstack(c)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 0],</span>
<span class="sd">                      [2, 0]</span>
<span class="sd">                      [3,0]]),</span>
<span class="sd">        b: ivy.array([[0, 1, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;dstack&quot;</span><span class="p">,</span>
        <span class="n">xs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_atleast_2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/atleast_2d/static_atleast_2d_container.html#ivy.container.container_methods.static_atleast_2d">[docs]</a><span class="k">def</span> <span class="nf">static_atleast_2d</span><span class="p">(</span>
    <span class="o">*</span><span class="n">arys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.atleast_2d. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.atleast_2d also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arys</span>
<span class="sd">        one or more container with array inputs.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The keychains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container or list of container where each elements within container is</span>
<span class="sd">        atleast 2D. Copies are made only if necessary.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary = ivy.Container(a=ivy.array(1), b=ivy.array([3,4,5]),\</span>
<span class="sd">                    c=ivy.array([[3]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_atleast_2d(ary)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1]]),</span>
<span class="sd">        b: ivy.array([[3, 4, 5]]),</span>
<span class="sd">        c: ivy.array([[3]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;atleast_2d&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arys</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="atleast_2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/atleast_2d/atleast_2d_container.html#ivy.container.container_methods.atleast_2d">[docs]</a><span class="k">def</span> <span class="nf">atleast_2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="n">arys</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.atleast_2d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.atleast_2d also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with array inputs.</span>
<span class="sd">    arys</span>
<span class="sd">        one or more container with array inputs.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The keychains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container or list of container where each elements within container is</span>
<span class="sd">        atleast 2D. Copies are made only if necessary.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ary1 = ivy.Container(a=ivy.array(1), b=ivy.array([3,4]),\</span>
<span class="sd">                        c=ivy.array([[5]]))</span>
<span class="sd">    &gt;&gt;&gt; ary2 = ivy.Container(a=ivy.array(9), b=ivy.array(2),\</span>
<span class="sd">                        c=ivy.array(3))</span>
<span class="sd">    &gt;&gt;&gt; ary1.atleast_2d(ary2)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([[1]]),</span>
<span class="sd">        b: ivy.array([[3, 4]]),</span>
<span class="sd">        c: ivy.array([[5]])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([[9]]),</span>
<span class="sd">        b: ivy.array([[2]]),</span>
<span class="sd">        c: ivy.array([[3]])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_atleast_2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arys</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_take_along_axis"><a class="viewcode-back" href="../../../functional/ivy/experimental/take_along_axis/static_take_along_axis_container.html#ivy.container.container_methods.static_take_along_axis">[docs]</a><span class="k">def</span> <span class="nf">static_take_along_axis</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.take_along_axis. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.take_along_axis also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr</span>
<span class="sd">        container with array inputs.</span>
<span class="sd">    indices</span>
<span class="sd">        container with indices of the values to extract.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis over which to select values. If axis is None, then arr and indices</span>
<span class="sd">        must be 1-D sequences of the same length.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The keychains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with arrays of the same shape as those in indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = ivy.Container(a=ivy.array([[1, 2], [3, 4]]),\</span>
<span class="sd">                            b=ivy.array([[5, 6], [7, 8]]))</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.Container(a=ivy.array([[0, 0], [1, 1]]),\</span>
<span class="sd">                                b=ivy.array([[1, 0], [1, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_take_along_axis(arr, indices, axis=1)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 1],</span>
<span class="sd">                      [4, 4]]),</span>
<span class="sd">        b: ivy.array([[6, 5],</span>
<span class="sd">                      [8, 7]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;take_along_axis&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="take_along_axis"><a class="viewcode-back" href="../../../functional/ivy/experimental/take_along_axis/take_along_axis_container.html#ivy.container.container_methods.take_along_axis">[docs]</a><span class="k">def</span> <span class="nf">take_along_axis</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.take_along_axis.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.take_along_axis also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        container with array inputs.</span>
<span class="sd">    indices</span>
<span class="sd">        container with indices of the values to extract.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis over which to select values. If axis is None, then arr and indices</span>
<span class="sd">        must be 1-D sequences of the same length.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The keychains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with arrays of the same shape as those in indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = ivy.Container(a=ivy.array([[1, 2], [3, 4]]),\</span>
<span class="sd">                            b=ivy.array([[5, 6], [7, 8]]))</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.Container(a=ivy.array([[0, 0], [1, 1]]),\</span>
<span class="sd">                                b=ivy.array([[1, 0], [1, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; arr.take_along_axis(indices, axis=1)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([[1, 1],</span>
<span class="sd">                      [4, 4]]),</span>
<span class="sd">        b: ivy.array([[6, 5],</span>
<span class="sd">                        [8, 7]])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_take_along_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_dirichlet"><a class="viewcode-back" href="../../../functional/ivy/experimental/dirichlet/static_dirichlet_container.html#ivy.container.container_methods.static_dirichlet">[docs]</a><span class="k">def</span> <span class="nf">static_dirichlet</span><span class="p">(</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.dirichlet. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.dirichlet also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha</span>
<span class="sd">        Sequence of floats of length k </span>
<span class="sd">    size</span>
<span class="sd">        optional container including ints or tuple of ints, </span>
<span class="sd">        Output shape for the arrays in the input container. </span>
<span class="sd">    dtype</span>
<span class="sd">        output container array data type. If ``dtype`` is ``None``, the output data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including the drawn samples.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; alpha = ivy.Container(a=ivy.array([7,6,5]), \</span>
<span class="sd">                              b=ivy.array([8,9,4]))</span>
<span class="sd">    &gt;&gt;&gt; size = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_dirichlet(alpha, size)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(</span>
<span class="sd">            [[0.43643127, 0.32325703, 0.24031169],</span>
<span class="sd">             [0.34251311, 0.31692529, 0.3405616 ],</span>
<span class="sd">             [0.5319725 , 0.22458365, 0.24344385]]</span>
<span class="sd">            ),</span>
<span class="sd">        b: ivy.array(</span>
<span class="sd">            [[0.26588406, 0.61075421, 0.12336174],</span>
<span class="sd">             [0.51142915, 0.25041268, 0.23815817],</span>
<span class="sd">             [0.64042903, 0.25763214, 0.10193883],</span>
<span class="sd">             [0.31624692, 0.46567987, 0.21807321],</span>
<span class="sd">             [0.37677699, 0.39914594, 0.22407707]]</span>
<span class="sd">            )</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;dirichlet&quot;</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dirichlet"><a class="viewcode-back" href="../../../functional/ivy/experimental/dirichlet/dirichlet_container.html#ivy.container.container_methods.dirichlet">[docs]</a><span class="k">def</span> <span class="nf">dirichlet</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.dirichlet. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.shuffle also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Sequence of floats of length k </span>
<span class="sd">    size</span>
<span class="sd">        optional container including ints or tuple of ints, </span>
<span class="sd">        Output shape for the arrays in the input container. </span>
<span class="sd">    dtype</span>
<span class="sd">        output container array data type. If ``dtype`` is ``None``, the output data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container including the drawn samples.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; alpha = ivy.Container(a=ivy.array([7,6,5]), \</span>
<span class="sd">                              b=ivy.array([8,9,4]))</span>
<span class="sd">    &gt;&gt;&gt; size = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; alpha.dirichlet(size)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(</span>
<span class="sd">            [[0.43643127, 0.32325703, 0.24031169],</span>
<span class="sd">             [0.34251311, 0.31692529, 0.3405616 ],</span>
<span class="sd">             [0.5319725 , 0.22458365, 0.24344385]]</span>
<span class="sd">            ),</span>
<span class="sd">        b: ivy.array(</span>
<span class="sd">            [[0.26588406, 0.61075421, 0.12336174],</span>
<span class="sd">             [0.51142915, 0.25041268, 0.23815817],</span>
<span class="sd">             [0.64042903, 0.25763214, 0.10193883],</span>
<span class="sd">             [0.31624692, 0.46567987, 0.21807321],</span>
<span class="sd">             [0.37677699, 0.39914594, 0.22407707]]</span>
<span class="sd">            )</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_dirichlet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_triu_indices"><a class="viewcode-back" href="../../../functional/ivy/experimental/triu_indices/static_triu_indices_container.html#ivy.container.container_methods.static_triu_indices">[docs]</a><span class="k">def</span> <span class="nf">static_triu_indices</span><span class="p">(</span>
    <span class="n">n_rows</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;triu_indices&quot;</span><span class="p">,</span>
        <span class="n">n_rows</span><span class="p">,</span>
        <span class="n">n_cols</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="triu_indices"><a class="viewcode-back" href="../../../functional/ivy/experimental/triu_indices/triu_indices_container.html#ivy.container.container_methods.triu_indices">[docs]</a><span class="k">def</span> <span class="nf">triu_indices</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">n_rows</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_triu_indices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_rows</span><span class="p">,</span>
        <span class="n">n_cols</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_hann_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/hann_window/static_hann_window_container.html#ivy.container.container_methods.static_hann_window">[docs]</a><span class="k">def</span> <span class="nf">static_hann_window</span><span class="p">(</span>
    <span class="n">window_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">periodic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.hann_window. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.hann_window also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    window_length</span>
<span class="sd">        container including multiple window sizes.</span>
<span class="sd">    periodic</span>
<span class="sd">        If True, returns a window to be used as periodic function.</span>
<span class="sd">        If False, return a symmetric window.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type to produce. Must be a floating point type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that contains the Hann windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_hann(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.0000, 0.7500, 0.7500])</span>
<span class="sd">        b: ivy.array([0.0000, 0.3455, 0.9045, 0.9045, 0.3455])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;hann_window&quot;</span><span class="p">,</span>
        <span class="n">window_length</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="hann_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/hann_window/hann_window_container.html#ivy.container.container_methods.hann_window">[docs]</a><span class="k">def</span> <span class="nf">hann_window</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">periodic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.hann_window. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.hann_window also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container with window sizes.</span>
<span class="sd">    periodic</span>
<span class="sd">        If True, returns a window to be used as periodic function.</span>
<span class="sd">        If False, return a symmetric window.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type to produce. Must be a floating point type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container containing the Hann windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.hann_window(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.0000, 0.7500, 0.7500])</span>
<span class="sd">        b: ivy.array([0.0000, 0.3455, 0.9045, 0.9045, 0.3455])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_hann_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_kaiser_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/kaiser_window/static_kaiser_window_container.html#ivy.container.container_methods.static_kaiser_window">[docs]</a><span class="k">def</span> <span class="nf">static_kaiser_window</span><span class="p">(</span>
    <span class="n">window_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">12.0</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.kaiser_window. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.kaiser_window</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    window_length</span>
<span class="sd">        input container including window lenghts.</span>
<span class="sd">    periodic</span>
<span class="sd">        If True, returns a periodic window suitable for use in spectral analysis.</span>
<span class="sd">        If False, returns a symmetric window suitable for use in filter design.</span>
<span class="sd">    beta</span>
<span class="sd">        a float used as shape parameter for the window.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that includes the Kaiser windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_kaiser_window(x, True, 5)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.2049, 0.8712, 0.8712]),</span>
<span class="sd">        a: ivy.array([0.0367, 0.7753, 0.7753]),</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;kaiser_window&quot;</span><span class="p">,</span>
        <span class="n">window_length</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="kaiser_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/kaiser_window/kaiser_window_container.html#ivy.container.container_methods.kaiser_window">[docs]</a><span class="k">def</span> <span class="nf">kaiser_window</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">12.0</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.kaiser_window. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.kaiser_window</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container including window lenghts.</span>
<span class="sd">    periodic</span>
<span class="sd">        If True, returns a periodic window suitable for use in spectral analysis.</span>
<span class="sd">        If False, returns a symmetric window suitable for use in filter design.</span>
<span class="sd">    beta</span>
<span class="sd">        a float used as shape parameter for the window.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that includes the Kaiser windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_kaiser_window(x, True, 5)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.2049, 0.8712, 0.8712]),</span>
<span class="sd">        a: ivy.array([0.0367, 0.7753, 0.7753]),</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_kaiser_window</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_kaiser_bessel_derived_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/kaiser_bessel_derived_window/static_kaiser_bessel_derived_window_container.html#ivy.container.container_methods.static_kaiser_bessel_derived_window">[docs]</a><span class="k">def</span> <span class="nf">static_kaiser_bessel_derived_window</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">12.0</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.kaiser_bessel_derived_window.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.kaiser_bessel_derived_window also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container including window lenghts.</span>
<span class="sd">    periodic</span>
<span class="sd">        If True, returns a periodic window suitable for use in spectral analysis.</span>
<span class="sd">        If False, returns a symmetric window suitable for use in filter design.</span>
<span class="sd">    beta</span>
<span class="sd">        a float used as shape parameter for the window.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that includes the Kaiser Bessel Derived windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_kaiser_bessel_derived_window(x, True, 5)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.70710677, 0.70710677]),</span>
<span class="sd">        b: ivy.array([0.18493208, 0.9827513 , 0.9827513 , 0.18493208]),</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;kaiser_bessel_derived_window&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="kaiser_bessel_derived_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/kaiser_bessel_derived_window/kaiser_bessel_derived_window_container.html#ivy.container.container_methods.kaiser_bessel_derived_window">[docs]</a><span class="k">def</span> <span class="nf">kaiser_bessel_derived_window</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">12.0</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.kaiser_bessel_derived_window.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.kaiser_bessel_derived_window also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container including window lenghts.</span>
<span class="sd">    periodic</span>
<span class="sd">        If True, returns a periodic window suitable for use in spectral analysis.</span>
<span class="sd">        If False, returns a symmetric window suitable for use in filter design.</span>
<span class="sd">    beta</span>
<span class="sd">        a float used as shape parameter for the window.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that includes the Kaiser Bessel Derived windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5))</span>
<span class="sd">    &gt;&gt;&gt; x.kaiser_bessel_derived_window(True, 5)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.70710677, 0.70710677]),</span>
<span class="sd">        b: ivy.array([0.18493208, 0.9827513 , 0.9827513 , 0.18493208]),</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_kaiser_bessel_derived_window</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_hamming_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/hamming_window/static_hamming_window_container.html#ivy.container.container_methods.static_hamming_window">[docs]</a><span class="k">def</span> <span class="nf">static_hamming_window</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">periodic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.54</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.46</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.hamming_window.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.hamming_window also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container including window lenghts.</span>
<span class="sd">    periodic</span>
<span class="sd">        If True, returns a window to be used as periodic function.</span>
<span class="sd">        If False, return a symmetric window.</span>
<span class="sd">    alpha</span>
<span class="sd">        The coefficient alpha in the hamming window equation</span>
<span class="sd">    beta</span>
<span class="sd">        The coefficient beta in the hamming window equation</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that includes the Hamming windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_hamming_window(x, periodic=True, alpha=0.2, beta=2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.8000,  1.2000,  1.2000]),</span>
<span class="sd">        b: ivy.array([-1.8000, -0.4180,  1.8180,  1.8180, -0.4180])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;hamming_window&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="hamming_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/hamming_window/hamming_window_container.html#ivy.container.container_methods.hamming_window">[docs]</a><span class="k">def</span> <span class="nf">hamming_window</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">periodic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.54</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.46</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.hamming_window.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.hamming_window also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container including window lenghts.</span>
<span class="sd">    periodic</span>
<span class="sd">        If True, returns a window to be used as periodic function.</span>
<span class="sd">        If False, return a symmetric window.</span>
<span class="sd">    alpha</span>
<span class="sd">        The coefficient alpha in the hamming window equation</span>
<span class="sd">    beta</span>
<span class="sd">        The coefficient beta in the hamming window equation</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that includes the Hamming windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5))</span>
<span class="sd">    &gt;&gt;&gt; x.hamming_window(periodic=True, alpha=0.2, beta=2)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.8000,  1.2000,  1.2000]),</span>
<span class="sd">        b: ivy.array([-1.8000, -0.4180,  1.8180,  1.8180, -0.4180])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_hamming_window</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_vorbis_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/vorbis_window/static_vorbis_window_container.html#ivy.container.container_methods.static_vorbis_window">[docs]</a><span class="k">def</span> <span class="nf">static_vorbis_window</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.vorbis_window.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.vorbis_window also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container including window lenghts.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that includes the vorbis windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_vorbis_window(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.38268343, 0.92387953, 1., 0.92387953,</span>
<span class="sd">                      0.38268343]),</span>
<span class="sd">        b: ivy.array([0., 0.14943586, 0.51644717, 0.85631905, 0.98877142,</span>
<span class="sd">                      1., 0.98877142, 0.85631905, 0.51644717, 0.14943586])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;vorbis_window&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vorbis_window"><a class="viewcode-back" href="../../../functional/ivy/experimental/vorbis_window/vorbis_window_container.html#ivy.container.container_methods.vorbis_window">[docs]</a><span class="k">def</span> <span class="nf">vorbis_window</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.vorbis_window.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.vorbis_window also applies to this method with</span>
<span class="sd">    minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container including window lenghts.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned arrays.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The container that includes the vorbis windows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=3, b=5))</span>
<span class="sd">    &gt;&gt;&gt; x.vorbis_window()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.38268343, 0.92387953, 1., 0.92387953,</span>
<span class="sd">                      0.38268343]),</span>
<span class="sd">        b: ivy.array([0., 0.14943586, 0.51644717, 0.85631905, 0.98877142,</span>
<span class="sd">                      1., 0.98877142, 0.85631905, 0.51644717, 0.14943586])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_vorbis_window</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_max_pool1d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool1d/static_max_pool1d_container.html#ivy.container.container_methods.static_max_pool1d">[docs]</a><span class="k">def</span> <span class="nf">static_max_pool1d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.max_pool1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.max_pool1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Container of input images *[batch_size, w, d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Size of the kernel i.e., the sliding window for each</span>
<span class="sd">        dimension of input. *[w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list</span>
<span class="sd">        indicating the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12.).reshape((2,2,3))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(24.).reshape((2,3,4))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_max_pool1d(x,2, 2, &quot;VALID&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[3., 4., 5.]],</span>
<span class="sd">                      [[9., 10., 11.]]]),</span>
<span class="sd">        b: ivy.array([[[4., 5., 6., 7.]],</span>
<span class="sd">                      [[16., 17., 18., 19.]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;max_pool1d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="max_pool1d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool1d/max_pool1d_container.html#ivy.container.container_methods.max_pool1d">[docs]</a><span class="k">def</span> <span class="nf">max_pool1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of `ivy.max_pool1d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.max_pool1d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Container of input images *[batch_size, w, d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Size of the kernel i.e., the sliding window for each</span>
<span class="sd">        dimension of input. *[w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list</span>
<span class="sd">        indicating the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12.).reshape((2,2,3))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(24.).reshape((2,3,4))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool1d(2, 2, &quot;VALID&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[3., 4., 5.]],</span>
<span class="sd">                      [[9., 10., 11.]]]),</span>
<span class="sd">        b: ivy.array([[[4., 5., 6., 7.]],</span>
<span class="sd">                      [[16., 17., 18., 19.]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_max_pool1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_max_pool2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool2d/static_max_pool2d_container.html#ivy.container.container_methods.static_max_pool2d">[docs]</a><span class="k">def</span> <span class="nf">static_max_pool2d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.max_pool2dd. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.max_pool2d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        The size of the window to take a max over.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12).reshape((2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(48).reshape((2, 4, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_max_pool2d(x, (2, 2), (1, 1), &quot;SAME&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: (&lt;class ivy.array.array.Array&gt; shape=[2, 1, 3, 2]),</span>
<span class="sd">        b: (&lt;class ivy.array.array.Array&gt; shape=[2, 4, 3, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;max_pool2d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="max_pool2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool2d/max_pool2d_container.html#ivy.container.container_methods.max_pool2d">[docs]</a><span class="k">def</span> <span class="nf">max_pool2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of `ivy.max_pool2d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.max_pool2d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        The size of the window to take a max over.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12).reshape((2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(48).reshape((2, 4, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool2d(2, 2), (1, 1), &quot;SAME&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: (&lt;class ivy.array.array.Array&gt; shape=[2, 1, 3, 2]),</span>
<span class="sd">        b: (&lt;class ivy.array.array.Array&gt; shape=[2, 4, 3, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_max_pool2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_max_pool3d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool3d/static_max_pool3d_container.html#ivy.container.container_methods.static_max_pool3d">[docs]</a><span class="k">def</span> <span class="nf">static_max_pool3d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.max_pool3d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.max_pool3d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input volume *[batch_size,d,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Convolution filters *[d,h,w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NDHWC&quot; or &quot;NCDHW&quot;. Defaults to &quot;NDHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12).reshape((1, 2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(48).reshape((2, 2, 2, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_max_pool3d(x, 2, 1, &quot;VALID&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([], shape=(1, 1, 0, 2, 2)),</span>
<span class="sd">        b: ivy.array([[[[[20, 21],</span>
<span class="sd">                         [22, 23]]]],</span>
<span class="sd">                   [[[[44, 45],</span>
<span class="sd">                         [46, 47]]]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;max_pool3d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="max_pool3d"><a class="viewcode-back" href="../../../functional/ivy/experimental/max_pool3d/max_pool3d_container.html#ivy.container.container_methods.max_pool3d">[docs]</a><span class="k">def</span> <span class="nf">max_pool3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.max_pool3d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.max_pool3d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input volume *[batch_size,d,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Convolution filters *[d,h,w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NDHWC&quot; or &quot;NCDHW&quot;. Defaults to &quot;NDHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12).reshape((1, 2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(48).reshape((2, 2, 2, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool3d(2, 1, &quot;VALID&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([], shape=(1, 1, 0, 2, 2)),</span>
<span class="sd">        b: ivy.array([[[[[20, 21],</span>
<span class="sd">                         [22, 23]]]],</span>
<span class="sd">                   [[[[44, 45],</span>
<span class="sd">                         [46, 47]]]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_max_pool3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_avg_pool1d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool1d/static_avg_pool1d_container.html#ivy.container.container_methods.static_avg_pool1d">[docs]</a><span class="k">def</span> <span class="nf">static_avg_pool1d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.avg_pool1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.avg_pool1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Container of input images *[batch_size, w, d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Size of the kernel i.e., the sliding window for each</span>
<span class="sd">        dimension of input. *[w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list</span>
<span class="sd">        indicating the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12.).reshape((2,2,3))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(24.).reshape((2,3,4))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_avg_pool1d(x,2, 2, &quot;VALID&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[1.5, 2.5, 3.5]],</span>
<span class="sd">                      [[7.5, 8.5, 9.5]]]),</span>
<span class="sd">        b: ivy.array([[[2., 3., 4., 5.]],</span>
<span class="sd">                      [[14., 15., 16., 17.]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;avg_pool1d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="avg_pool1d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool1d/avg_pool1d_container.html#ivy.container.container_methods.avg_pool1d">[docs]</a><span class="k">def</span> <span class="nf">avg_pool1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of `ivy.avg_pool1d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.avg_pool1d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Container of input images *[batch_size, w, d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Size of the kernel i.e., the sliding window for each</span>
<span class="sd">        dimension of input. *[w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list</span>
<span class="sd">        indicating the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12.).reshape((2,2,3))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(24.).reshape((2,3,4))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(x.avg_pool1d(2, 2, &quot;VALID&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[1.5, 2.5, 3.5]],</span>
<span class="sd">                      [[7.5, 8.5, 9.5]]]),</span>
<span class="sd">        b: ivy.array([[[2., 3., 4., 5.]],</span>
<span class="sd">                      [[14., 15., 16., 17.]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_avg_pool1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_avg_pool2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool2d/static_avg_pool2d_container.html#ivy.container.container_methods.static_avg_pool2d">[docs]</a><span class="k">def</span> <span class="nf">static_avg_pool2d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.avg_pool2d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.avg_pool2d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        The size of the window to take a max over.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12).reshape((2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(48).reshape((2, 4, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_avg_pool2d(x, (2, 2), (1, 1), &quot;SAME&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([], shape=(2, 0, 2, 2)),</span>
<span class="sd">        b: (&lt;class ivy.array.array.Array&gt; shape=[2, 3, 2, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;avg_pool2d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="avg_pool2d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool2d/avg_pool2d_container.html#ivy.container.container_methods.avg_pool2d">[docs]</a><span class="k">def</span> <span class="nf">avg_pool2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of `ivy.avg_pool2d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.avg_pool2d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        The size of the window to take a max over.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12).reshape((2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(48).reshape((2, 4, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(x.avg_pool2d((2, 2), (1, 1), &quot;SAME&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([], shape=(2, 0, 2, 2)),</span>
<span class="sd">        b: (&lt;class ivy.array.array.Array&gt; shape=[2, 3, 2, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_avg_pool2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_avg_pool3d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool3d/static_avg_pool3d_container.html#ivy.container.container_methods.static_avg_pool3d">[docs]</a><span class="k">def</span> <span class="nf">static_avg_pool3d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.avg_pool3d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.avg_pool3d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input volume *[batch_size,d,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Convolution filters *[d,h,w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NDHWC&quot; or &quot;NCDHW&quot;. Defaults to &quot;NDHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12).reshape((1, 2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(48).reshape((2, 2, 2, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_avg_pool3d(x, 2, 1, &quot;VALID&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([], shape=(1, 1, 0, 2, 2)),</span>
<span class="sd">        b: ivy.array([[[[[10., 11.],</span>
<span class="sd">                         [12., 13.]]]],</span>
<span class="sd">                   [[[[34., 35.],</span>
<span class="sd">                         [36., 37.]]]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;avg_pool3d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="avg_pool3d"><a class="viewcode-back" href="../../../functional/ivy/experimental/avg_pool3d/avg_pool3d_container.html#ivy.container.container_methods.avg_pool3d">[docs]</a><span class="k">def</span> <span class="nf">avg_pool3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.avg_pool3d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.avg_pool3d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input volume *[batch_size,d,h,w,d_in]*.</span>
<span class="sd">    kernel</span>
<span class="sd">        Convolution filters *[d,h,w]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        NDHWC&quot; or &quot;NCDHW&quot;. Defaults to &quot;NDHWC&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the pooling operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.arange(12).reshape((1, 2, 1, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.arange(48).reshape((2, 2, 2, 3, 2))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: a, &#39;b&#39;: b})</span>
<span class="sd">    &gt;&gt;&gt; print(x.max_pool3d(2, 1, &quot;VALID&quot;))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([], shape=(1, 1, 0, 2, 2)),</span>
<span class="sd">        b: ivy.array([[[[[10., 11.],</span>
<span class="sd">                         [12., 13.]]]],</span>
<span class="sd">                   [[[[34., 35.],</span>
<span class="sd">                         [36., 37.]]]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_avg_pool3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_dct"><a class="viewcode-back" href="../../../functional/ivy/experimental/dct/static_dct_container.html#ivy.container.container_methods.static_dct">[docs]</a><span class="k">def</span> <span class="nf">static_dct</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ortho&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.dct. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.dct also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Container with the input signals.</span>
<span class="sd">    type</span>
<span class="sd">        The type of the dct. Must be 1, 2, 3 or 4.</span>
<span class="sd">    n</span>
<span class="sd">        The lenght of the transform. If n is less than the input signal lenght,</span>
<span class="sd">        then x is truncated, if n is larger than x is zero-padded.</span>
<span class="sd">    norm</span>
<span class="sd">        The type of normalization to be applied. Must be either None or &quot;ortho&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The transformed input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([8, 16, 24, 32, 40, 48, 56, 64]),</span>
<span class="sd">    ...                   b=ivy.array([1,  2,  3,  4,  5,  6,  7,  8]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_dct(x, type=2, norm=&#39;ortho&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([102., -51.5, 0., -5.39, 0., -1.61, 0.,</span>
<span class="sd">                    -0.406]),</span>
<span class="sd">        b: ivy.array([12.7, -6.44, 0., -0.673, 0., -0.201, 0.,</span>
<span class="sd">                    -0.0507])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([  8, 16,  24,  32,   40,   48,   56,   64]),</span>
<span class="sd">    ...                   b=ivy.array([11., 54, 23., 13., 255., 255., 132., 182.]))</span>
<span class="sd">    &gt;&gt;&gt; n = ivy.Container(a=9, b=5)</span>
<span class="sd">    &gt;&gt;&gt; type = ivy.Container(a=2, b=4)</span>
<span class="sd">    &gt;&gt;&gt; norm = ivy.Container(a=&quot;ortho&quot;, b=None)</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_dct(x, type=type, n=n, norm=norm)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([96., -28.2, -31.9, 22.9, -26., 19.8, -17., 10.9,</span>
<span class="sd">                    -5.89]),</span>
<span class="sd">        b: ivy.array([242., -253., 286., -515., 467.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;dct&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
        <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dct"><a class="viewcode-back" href="../../../functional/ivy/experimental/dct/dct_container.html#ivy.container.container_methods.dct">[docs]</a><span class="k">def</span> <span class="nf">dct</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ortho&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.dct. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.dct also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Container with the input signals.</span>
<span class="sd">    type</span>
<span class="sd">        The type of the dct. Must be 1, 2, 3 or 4.</span>
<span class="sd">    n</span>
<span class="sd">        The lenght of the transform. If n is less than the input signal lenght,</span>
<span class="sd">        then x is truncated, if n is larger then x is zero-padded.</span>
<span class="sd">    norm</span>
<span class="sd">        The type of normalization to be applied. Must be either None or &quot;ortho&quot;.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The transformed input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([8, 16, 24, 32, 40, 48, 56, 64]),</span>
<span class="sd">    ...                   b=ivy.array([1,  2,  3,  4,  5,  6,  7,  8]))</span>
<span class="sd">    &gt;&gt;&gt; x.dct(type=2, norm=&#39;ortho&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([102., -51.5, 0., -5.39, 0., -1.61, 0.,</span>
<span class="sd">                    -0.406]),</span>
<span class="sd">        b: ivy.array([12.7, -6.44, 0., -0.673, 0., -0.201, 0.,</span>
<span class="sd">                    -0.0507])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_dct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
        <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.general</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_is_native_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_native_array/static_is_native_array_container.html#ivy.container.container_methods.static_is_native_array">[docs]</a><span class="k">def</span> <span class="nf">static_is_native_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_native_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.is_native_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is a native array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;is_native_array&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_native_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_native_array/is_native_array_container.html#ivy.container.container_methods.is_native_array">[docs]</a><span class="k">def</span> <span class="nf">is_native_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_native_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ivy.is_native_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is a native array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_is_native_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_is_ivy_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_ivy_array/static_is_ivy_array_container.html#ivy.container.container_methods.static_is_ivy_array">[docs]</a><span class="k">def</span> <span class="nf">static_is_ivy_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_ivy_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.is_ivy_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;is_ivy_array&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_ivy_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_ivy_array/is_ivy_array_container.html#ivy.container.container_methods.is_ivy_array">[docs]</a><span class="k">def</span> <span class="nf">is_ivy_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_native_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ivy.is_native_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_is_ivy_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_is_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_array/static_is_array_container.html#ivy.container.container_methods.static_is_array">[docs]</a><span class="k">def</span> <span class="nf">static_is_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ivy.is_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;is_array&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_array/is_array_container.html#ivy.container.container_methods.is_array">[docs]</a><span class="k">def</span> <span class="nf">is_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.is_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_is_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_is_ivy_container"><a class="viewcode-back" href="../../../functional/ivy/general/is_ivy_container/static_is_ivy_container_container.html#ivy.container.container_methods.static_is_ivy_container">[docs]</a><span class="k">def</span> <span class="nf">static_is_ivy_container</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_ivy_container.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ivy.is_ivy_container also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to check</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an ivy container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;is_ivy_container&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_ivy_container"><a class="viewcode-back" href="../../../functional/ivy/general/is_ivy_container/is_ivy_container_container.html#ivy.container.container_methods.is_ivy_container">[docs]</a><span class="k">def</span> <span class="nf">is_ivy_container</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_ivy_container.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.is_ivy_container also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an ivy container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_is_ivy_container</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_clip_vector_norm"><a class="viewcode-back" href="../../../functional/ivy/general/clip_vector_norm/static_clip_vector_norm_container.html#ivy.container.container_methods.static_clip_vector_norm">[docs]</a><span class="k">def</span> <span class="nf">static_clip_vector_norm</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.clip_vector_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.clip_vector_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array</span>
<span class="sd">    max_norm</span>
<span class="sd">        float, the maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        optional float, the p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_clip_vector_norm(x, 2.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.894, 1.79]),</span>
<span class="sd">        b: ivy.array([0.849, 1.13, 1.41])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;clip_vector_norm&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">max_norm</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="clip_vector_norm"><a class="viewcode-back" href="../../../functional/ivy/general/clip_vector_norm/clip_vector_norm_container.html#ivy.container.container_methods.clip_vector_norm">[docs]</a><span class="k">def</span> <span class="nf">clip_vector_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.clip_vector_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.clip_vector_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    max_norm</span>
<span class="sd">        float, the maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        optional float, the p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip_vector_norm(2.0, p=1.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.667, 1.33]),</span>
<span class="sd">        b: ivy.array([0.5, 0.667, 0.833])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_clip_vector_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_norm</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_inplace_update"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_update/static_inplace_update_container.html#ivy.container.container_methods.static_inplace_update">[docs]</a><span class="k">def</span> <span class="nf">static_inplace_update</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inplace_update. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_update</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to be updated inplace</span>
<span class="sd">    val</span>
<span class="sd">        value to update the input container with</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># inplace update the leaves</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;inplace_update&quot;</span><span class="p">,</span>
        <span class="n">cont</span><span class="p">,</span>
        <span class="n">val</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># inplace update the container</span>
    <span class="n">x</span><span class="o">.</span><span class="n">cont_inplace_update</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="inplace_update"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_update/inplace_update_container.html#ivy.container.container_methods.inplace_update">[docs]</a><span class="k">def</span> <span class="nf">inplace_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inplace_update. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_update</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container to be updated inplace</span>
<span class="sd">    val</span>
<span class="sd">        value to update the input container with</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_inplace_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">val</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_inplace_decrement"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_decrement/static_inplace_decrement_container.html#ivy.container.container_methods.static_inplace_decrement">[docs]</a><span class="k">def</span> <span class="nf">static_inplace_decrement</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.inplace_decrement. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_decrement</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input array to be decremented by the defined value.</span>
<span class="sd">    val</span>
<span class="sd">        The value of decrement.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following an in-place decrement.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Decrement by a value</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.5, -5., 30.]),b=ivy.array([0., -25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.inplace_decrement(x, 1.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1., -6.5, 28.5]),</span>
<span class="sd">        b: ivy.array([-1.5, -26.5, 48.5])</span>
<span class="sd">    }</span>
<span class="sd">    Decrement by a Container</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 15., 30.]), b=ivy.array([0., 25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 15., 30.]), b=ivy.array([0., 25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.inplace_decrement(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 0.]),</span>
<span class="sd">        b: ivy.array([0., 0., 0.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([3., 7., 10.]), b=ivy.array([0., 75., 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([2., 5.5, 7.]), b=ivy.array([0., 25., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.inplace_decrement(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 1.5, 3.]),</span>
<span class="sd">        b: ivy.array([0., 50., 3.5])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;inplace_decrement&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">val</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="inplace_decrement"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_decrement/inplace_decrement_container.html#ivy.container.container_methods.inplace_decrement">[docs]</a><span class="k">def</span> <span class="nf">inplace_decrement</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inplace_decrement. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_decrement</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to apply an in-place decrement.</span>
<span class="sd">    val</span>
<span class="sd">        The value of decrement.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the array following the in-place decrement.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-6.7, 2.4, -8.5]),</span>
<span class="sd">    ...                   b=ivy.array([1.5, -0.3, 0]),</span>
<span class="sd">    ...                   c=ivy.array([-4.7, -5.4, 7.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_decrement(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-8.7, 0.4, -10.5]),</span>
<span class="sd">        b: ivy.array([-0.5, -2.3, -2]),</span>
<span class="sd">        c: ivy.array([-6.7, -7.4, 5.5])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_inplace_decrement</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">val</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_inplace_increment"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_increment/static_inplace_increment_container.html#ivy.container.container_methods.static_inplace_increment">[docs]</a><span class="k">def</span> <span class="nf">static_inplace_increment</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.inplace_increment. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_increment</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input array to be incremented by the defined value.</span>
<span class="sd">    val</span>
<span class="sd">        The value of increment.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following an in-place increment.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Increment by a value</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.5, -5., 30.]),b=ivy.array([0., -25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.inplace_increment(x, 1.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., -3.5, 31.5]),</span>
<span class="sd">        b: ivy.array([1.5, -23.5, 51.5])</span>
<span class="sd">    }</span>
<span class="sd">    Increment by a Container</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 15., 30.]), b=ivy.array([0., 25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 15., 30.]), b=ivy.array([0., 25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.inplace_increment(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 30., 60.]),</span>
<span class="sd">        b: ivy.array([0., 50., 100.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([3., 7., 10.]), b=ivy.array([0., 75., 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([2., 5.5, 7.]), b=ivy.array([0., 25., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.inplace_increment(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5., 12.5, 17.]),</span>
<span class="sd">        b: ivy.array([0., 100., 7.5])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;inplace_increment&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">val</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="inplace_increment"><a class="viewcode-back" href="../../../functional/ivy/general/inplace_increment/inplace_increment_container.html#ivy.container.container_methods.inplace_increment">[docs]</a><span class="k">def</span> <span class="nf">inplace_increment</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inplace_increment.</span>
<span class="sd">    This method wraps the function, and so the docstring for</span>
<span class="sd">    ivy.inplace_increment also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to apply an in-place increment.</span>
<span class="sd">    val</span>
<span class="sd">        The value of increment.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the array following the in-place increment.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-6.7, 2.4, -8.5]),</span>
<span class="sd">    ...                   b=ivy.array([1.5, -0.3, 0]),</span>
<span class="sd">    ...                   c=ivy.array([-4.7, -5.4, 7.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_increment(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-4.7, 4.4, -6.5]),</span>
<span class="sd">        b: ivy.array([3.5, 1.7, 2.]),</span>
<span class="sd">        c: ivy.array([-2.7, -3.4, 9.5])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_inplace_increment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">val</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_assert_supports_inplace"><a class="viewcode-back" href="../../../functional/ivy/general/assert_supports_inplace/static_assert_supports_inplace_container.html#ivy.container.container_methods.static_assert_supports_inplace">[docs]</a><span class="k">def</span> <span class="nf">static_assert_supports_inplace</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.assert_supports_inplace. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.assert_supports_inplace also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to check for inplace support for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        True if support, raises exception otherwise`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;assert_supports_inplace&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="assert_supports_inplace"><a class="viewcode-back" href="../../../functional/ivy/general/assert_supports_inplace/assert_supports_inplace_container.html#ivy.container.container_methods.assert_supports_inplace">[docs]</a><span class="k">def</span> <span class="nf">assert_supports_inplace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.assert_supports_inplace. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.assert_supports_inplace also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to check for inplace support for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of whether or not inplace operations are supported for x and</span>
<span class="sd">        its leaves.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_assert_supports_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_all_equal"><a class="viewcode-back" href="../../../functional/ivy/general/all_equal/static_all_equal_container.html#ivy.container.container_methods.static_all_equal">[docs]</a><span class="k">def</span> <span class="nf">static_all_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="n">xs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
    <span class="n">equality_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.all_equal. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.all_equal also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input container.</span>
<span class="sd">    xs</span>
<span class="sd">        arrays or containers to be compared to ``x1``.</span>
<span class="sd">    equality_matrix</span>
<span class="sd">        Whether to return a matrix of equalities comparing each input with every</span>
<span class="sd">        other. Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not the inputs are equal, or matrix container of</span>
<span class="sd">        booleans if equality_matrix=True is set.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 0, 1, 1]), b=ivy.array([1, -1, 0, 0]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all_equal(x1, x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True, True]),</span>
<span class="sd">        b: ivy.array([True, False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 0, 1, 1]),</span>
<span class="sd">    ...                    b=ivy.native_array([1, 0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.native_array([1, 0, 1, 1]),</span>
<span class="sd">    ...                    b=ivy.array([1, 0, -1, -1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all_equal(x1, x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True, True]),</span>
<span class="sd">        b: ivy.array([True, True, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;all_equal&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="o">*</span><span class="n">xs</span><span class="p">,</span>
        <span class="n">equality_matrix</span><span class="o">=</span><span class="n">equality_matrix</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="all_equal"><a class="viewcode-back" href="../../../functional/ivy/general/all_equal/all_equal_container.html#ivy.container.container_methods.all_equal">[docs]</a><span class="k">def</span> <span class="nf">all_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="n">xs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
    <span class="n">equality_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.all_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.all_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    xs</span>
<span class="sd">        arrays or containers to be compared to ``self``.</span>
<span class="sd">    equality_matrix</span>
<span class="sd">        Whether to return a matrix of equalities comparing each input with every</span>
<span class="sd">        other. Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not the inputs are equal, or matrix container of</span>
<span class="sd">        booleans if equality_matrix=True is set.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` instances:</span>
<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 0, 1, 1]), b=ivy.array([1, -1, 0, 0]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.all_equal(x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 0, 1, 1]), b=ivy.array([1, -1, 0, 0]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all_equal(x1, x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.native_array([1, 0, 0]),</span>
<span class="sd">    ...                    b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.native_array([1, 0, 1]),</span>
<span class="sd">    ...                    b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.all_equal(x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.native_array([1, 0, 0]),</span>
<span class="sd">    ...                    b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.native_array([1, 0, 1]),</span>
<span class="sd">    ...                    b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all_equal(x1, x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_all_equal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">xs</span><span class="p">,</span>
        <span class="n">equality_matrix</span><span class="o">=</span><span class="n">equality_matrix</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_fourier_encode"><a class="viewcode-back" href="../../../functional/ivy/general/fourier_encode/static_fourier_encode_container.html#ivy.container.container_methods.static_fourier_encode">[docs]</a><span class="k">def</span> <span class="nf">static_fourier_encode</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">max_freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">flatten</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.fourier_encode. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.fourier_encode</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input container to apply fourier_encode.</span>
<span class="sd">    max_freq</span>
<span class="sd">        The maximum frequency of the encoding.</span>
<span class="sd">    num_bands</span>
<span class="sd">        The number of frequency bands for the encoding. Default is 4.</span>
<span class="sd">    linear</span>
<span class="sd">        Whether to space the frequency bands linearly as opposed to geometrically.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    flatten</span>
<span class="sd">        Whether to flatten the position dimension into the batch dimension.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with the final dimension expanded of arrays at its leaves,</span>
<span class="sd">        and the encodings stored in this channel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;fourier_encode&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="p">,</span>
        <span class="n">num_bands</span><span class="o">=</span><span class="n">num_bands</span><span class="p">,</span>
        <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
        <span class="n">concat</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">flatten</span><span class="o">=</span><span class="n">flatten</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fourier_encode"><a class="viewcode-back" href="../../../functional/ivy/general/fourier_encode/fourier_encode_container.html#ivy.container.container_methods.fourier_encode">[docs]</a><span class="k">def</span> <span class="nf">fourier_encode</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">flatten</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.fourier_encode. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.fourier_encode</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to apply fourier_encode at leaves.</span>
<span class="sd">    max_freq</span>
<span class="sd">        The maximum frequency of the encoding.</span>
<span class="sd">    num_bands</span>
<span class="sd">        The number of frequency bands for the encoding. Default is 4.</span>
<span class="sd">    linear</span>
<span class="sd">        Whether to space the frequency bands linearly as opposed to geometrically.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    flatten</span>
<span class="sd">        Whether to flatten the position dimension into the batch dimension.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with the final dimension expanded of arrays at its leaves,</span>
<span class="sd">        and the encodings stored in this channel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_fourier_encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="p">,</span>
        <span class="n">num_bands</span><span class="o">=</span><span class="n">num_bands</span><span class="p">,</span>
        <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
        <span class="n">flatten</span><span class="o">=</span><span class="n">flatten</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_gather"><a class="viewcode-back" href="../../../functional/ivy/general/gather/static_gather_container.html#ivy.container.container_methods.static_gather">[docs]</a><span class="k">def</span> <span class="nf">static_gather</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">batch_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.gather. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.gather also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The container from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        The container or array which indicates the indices that will be</span>
<span class="sd">        gathered along the specified axis.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis from which the indices will be gathered. Default is ``-1``.</span>
<span class="sd">    batch_dims</span>
<span class="sd">        optional int, lets you gather different items from each element of a batch.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with the values gathered at the specified indices</span>
<span class="sd">        along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b = ivy.array([4., 5., 6.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.array([0, 1]),</span>
<span class="sd">    ...                   b = ivy.array([1, 2]))</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_gather(x, y))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.]),</span>
<span class="sd">        b: ivy.array([5., 6.])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Array` and :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b = ivy.array([4., 5., 6.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_gather(x, y))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.]),</span>
<span class="sd">        b: ivy.array([4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;gather&quot;</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gather"><a class="viewcode-back" href="../../../functional/ivy/general/gather/gather_container.html#ivy.container.container_methods.gather">[docs]</a><span class="k">def</span> <span class="nf">gather</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">batch_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.gather. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.gather also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The container from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        The container or array which indicates the indices that will be</span>
<span class="sd">        gathered along the specified axis.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis from which the indices will be gathered. Default is ``-1``.</span>
<span class="sd">    batch_dims</span>
<span class="sd">        optional int, lets you gather different items from each element of a batch.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is</span>
<span class="sd">        False.</span>
<span class="sd">    out</span>
<span class="sd">        optional array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with the values gathered at the specified indices</span>
<span class="sd">        along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b = ivy.array([4., 5., 6.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.array([0, 1]),</span>
<span class="sd">    ...                   b = ivy.array([1, 2]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.gather(y))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.]),</span>
<span class="sd">        b: ivy.array([5., 6.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_gather</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_has_nans"><a class="viewcode-back" href="../../../functional/ivy/general/has_nans/static_has_nans_container.html#ivy.container.container_methods.static_has_nans">[docs]</a><span class="k">def</span> <span class="nf">static_has_nans</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">include_infs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether arrays in the container contain any nans, as well as infs</span>
<span class="sd">    or -infs if specified.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The container to check for nans.</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include infs and -infs in the check. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Whether the container has any nans, applied either leafwise or across the</span>
<span class="sd">        entire container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;has_nans&quot;</span><span class="p">,</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">include_infs</span><span class="o">=</span><span class="n">include_infs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="has_nans"><a class="viewcode-back" href="../../../functional/ivy/general/has_nans/has_nans_container.html#ivy.container.container_methods.has_nans">[docs]</a><span class="k">def</span> <span class="nf">has_nans</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">include_infs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether arrays in the container contain any nans, as well as infs</span>
<span class="sd">    or -infs if specified.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include infs and -infs in the check. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Whether the container has any nans, applied across the entire container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_has_nans</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">include_infs</span><span class="o">=</span><span class="n">include_infs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_scatter_nd"><a class="viewcode-back" href="../../../functional/ivy/general/scatter_nd/static_scatter_nd_container.html#ivy.container.container_methods.static_scatter_nd">[docs]</a><span class="k">def</span> <span class="nf">static_scatter_nd</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.scatter_nd. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.scatter_nd also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the result. Default is ``None``, in which case tensor argument</span>
<span class="sd">        must be provided.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ref</span>
<span class="sd">        New container of given shape, with the values updated at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    scatter into an empty array</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.Container(a=ivy.array([[5],[6],[7]]),</span>
<span class="sd">    ...                         b=ivy.array([[2],[3],[4]]))</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.Container(a=ivy.array([50, 60, 70]),</span>
<span class="sd">    ...                         b=ivy.array([20, 30, 40]))</span>
<span class="sd">    &gt;&gt;&gt; shape = ivy.Container(a=ivy.array([10]),</span>
<span class="sd">    ...                       b=ivy.array([10]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_scatter_nd(indices, updates, shape=shape)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 0, 0, 0, 0, 50, 60, 70, 0, 0]),</span>
<span class="sd">        b: ivy.array([0, 0, 20, 30, 40, 0, 0, 0, 0, 0])</span>
<span class="sd">    }</span>
<span class="sd">    scatter into a container</span>

<span class="sd">    &gt;&gt;&gt; indices = ivy.Container(a=ivy.array([[5],[6],[7]]),</span>
<span class="sd">    ...          b=ivy.array([[2],[3],[4]]))</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.Container(a=ivy.array([50, 60, 70]),</span>
<span class="sd">    ...                         b=ivy.array([20, 30, 40]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),</span>
<span class="sd">    ...                   b=ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_scatter_nd(indices, updates,</span>
<span class="sd">    ...                                    reduction=&#39;replace&#39;, out = z)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 3, 4, 5, 50, 60, 70, 9, 10]),</span>
<span class="sd">        b: ivy.array([1, 2, 20, 30, 40, 6, 7, 8, 9, 10])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;scatter_nd&quot;</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">updates</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="scatter_nd"><a class="viewcode-back" href="../../../functional/ivy/general/scatter_nd/scatter_nd_container.html#ivy.container.container_methods.scatter_nd">[docs]</a><span class="k">def</span> <span class="nf">scatter_nd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.scatter_nd.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.scatter_nd also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the result. Default is ``None``, in which case tensor argument</span>
<span class="sd">        must be provided.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container of given shape, with the values updated at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    scatter into an empty container</span>
<span class="sd">    &gt;&gt;&gt; indices = ivy.Container(a=ivy.array([[4],[3],[6]]),</span>
<span class="sd">    ...                         b=ivy.array([[5],[1],[2]]))</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.Container(a=ivy.array([100, 200, 200]),</span>
<span class="sd">    ...                         b=ivy.array([20, 30, 40]))</span>
<span class="sd">    &gt;&gt;&gt; shape = ivy.Container(a=ivy.array([10]),</span>
<span class="sd">    ...                       b=ivy.array([10]))</span>
<span class="sd">    &gt;&gt;&gt; z = indices.scatter_nd(updates, shape=shape)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 0, 0, 200, 100, 0, 200, 0, 0, 0]),</span>
<span class="sd">        b: ivy.array([0, 30, 40, 0, 0, 20, 0, 0, 0, 0])</span>
<span class="sd">    }</span>
<span class="sd">    scatter into a container.</span>

<span class="sd">    &gt;&gt;&gt; indices = ivy.Container(a=ivy.array([[5],[6],[7]]),</span>
<span class="sd">    ...                         b=ivy.array([[2],[3],[4]]))</span>
<span class="sd">    &gt;&gt;&gt; updates = ivy.Container(a=ivy.array([50, 60, 70]),</span>
<span class="sd">    ...                         b=ivy.array([20, 30, 40]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),</span>
<span class="sd">    ...                   b=ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))</span>
<span class="sd">    &gt;&gt;&gt; indices.scatter_nd(updates,reduction=&#39;replace&#39;, out = z)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 3, 4, 5, 50, 60, 70, 9, 10]),</span>
<span class="sd">        b: ivy.array([1, 2, 20, 30, 40, 6, 7, 8, 9, 10])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_scatter_nd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">updates</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_scatter_flat"><a class="viewcode-back" href="../../../functional/ivy/general/scatter_flat/static_scatter_flat_container.html#ivy.container.container_methods.static_scatter_flat">[docs]</a><span class="k">def</span> <span class="nf">static_scatter_flat</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.scatter_flat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.scatter_flat also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    size</span>
<span class="sd">        The size of the result.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ref</span>
<span class="sd">        New container of given shape, with the values updated at the indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;scatter_flat&quot;</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">updates</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="scatter_flat"><a class="viewcode-back" href="../../../functional/ivy/general/scatter_flat/scatter_flat_container.html#ivy.container.container_methods.scatter_flat">[docs]</a><span class="k">def</span> <span class="nf">scatter_flat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.scatter_flat.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.scatter_flat also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    size</span>
<span class="sd">        The size of the result.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container of given shape, with the values updated at the indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_scatter_flat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">updates</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_gather_nd"><a class="viewcode-back" href="../../../functional/ivy/general/gather_nd/static_gather_nd_container.html#ivy.container.container_methods.static_gather_nd">[docs]</a><span class="k">def</span> <span class="nf">static_gather_nd</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Gather slices from all container params into a arrays with shape specified by</span>
<span class="sd">    indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices</span>
<span class="sd">        Index array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object with all sub-array dimensions gathered.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 10., 20.],[30.,40.,50.]]),</span>
<span class="sd">    ...                   b=ivy.array([[0., 100., 200.],[300.,400.,500.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1,0]),</span>
<span class="sd">    ...                   b=ivy.array([0]))</span>
<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_gather_nd(x, y))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(30.),</span>
<span class="sd">        b: ivy.array([0., 100., 200.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;gather_nd&quot;</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gather_nd"><a class="viewcode-back" href="../../../functional/ivy/general/gather_nd/gather_nd_container.html#ivy.container.container_methods.gather_nd">[docs]</a><span class="k">def</span> <span class="nf">gather_nd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.gather_nd.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.gather_nd also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The container from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc. Same as</span>
<span class="sd">        ``x`` if None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container of given shape, with the values gathered at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[0., 10.], [20.,30.]],</span>
<span class="sd">    ...                                [[40.,50.], [60.,70.]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[0., 100.], [200.,300.]],</span>
<span class="sd">    ...                                [[400.,500.],[600.,700.]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1,0]),</span>
<span class="sd">    ...                   b=ivy.array([0]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.gather_nd(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([40., 50.]),</span>
<span class="sd">        b: ivy.array([[0., 100.],</span>
<span class="sd">                    [200., 300.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_gather_nd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_einops_reduce"><a class="viewcode-back" href="../../../functional/ivy/general/einops_reduce/static_einops_reduce_container.html#ivy.container.container_methods.static_einops_reduce">[docs]</a><span class="k">def</span> <span class="nf">static_einops_reduce</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform einops reduce operation on each sub array in the container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Reduction pattern.</span>
<span class="sd">    reduction</span>
<span class="sd">        One of available reductions (&#39;min&#39;, &#39;max&#39;, &#39;sum&#39;, &#39;mean&#39;, &#39;prod&#39;), or</span>
<span class="sd">        callable.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.reduce applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[-4.47, 0.93, -3.34],</span>
<span class="sd">    ...                                [3.66, 24.29, 3.64]]),</span>
<span class="sd">    ...                   b=ivy.array([[4.96, 1.52, -10.67],</span>
<span class="sd">    ...                                [4.36, 13.96, 0.3]]))</span>
<span class="sd">    &gt;&gt;&gt; reduced = ivy.Container.static_einops_reduce(x, &#39;a b -&gt; a&#39;, &#39;mean&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(reduced)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-2.29, 10.5]),</span>
<span class="sd">        b: ivy.array([-1.4, 6.21])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;einops_reduce&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">,</span>
        <span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">axes_lengths</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="einops_reduce"><a class="viewcode-back" href="../../../functional/ivy/general/einops_reduce/einops_reduce_container.html#ivy.container.container_methods.einops_reduce">[docs]</a><span class="k">def</span> <span class="nf">einops_reduce</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.einops_reduce. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.einops_reduce also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to be reduced.</span>
<span class="sd">    pattern</span>
<span class="sd">        Reduction pattern.</span>
<span class="sd">    reduction</span>
<span class="sd">        One of available reductions (&#39;min&#39;, &#39;max&#39;, &#39;sum&#39;, &#39;mean&#39;, &#39;prod&#39;), or</span>
<span class="sd">        callable.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with einops.reduce having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[5, 4, 3],</span>
<span class="sd">    ...                                 [11, 2, 9]],</span>
<span class="sd">    ...                                [[3, 5, 7],</span>
<span class="sd">    ...                                 [9, 7, 1]]]),</span>
<span class="sd">    ...                    b=ivy.array([[[9,7,6],</span>
<span class="sd">    ...                                  [5,2,1]],</span>
<span class="sd">    ...                                 [[4,1,2],</span>
<span class="sd">    ...                                  [2,3,6]],</span>
<span class="sd">    ...                                 [[1, 9, 6],</span>
<span class="sd">    ...                                  [0, 2, 1]]]))</span>
<span class="sd">    &gt;&gt;&gt; reduced = x.einops_reduce(&#39;a b c -&gt; a b&#39;, &#39;sum&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(reduced)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[12, 22],</span>
<span class="sd">                    [15, 17]]),</span>
<span class="sd">        b: ivy.array([[22, 8],</span>
<span class="sd">                    [7, 11],</span>
<span class="sd">                    [16, 3]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_einops_reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">,</span>
        <span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">axes_lengths</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_einops_repeat"><a class="viewcode-back" href="../../../functional/ivy/general/einops_repeat/static_einops_repeat_container.html#ivy.container.container_methods.static_einops_repeat">[docs]</a><span class="k">def</span> <span class="nf">static_einops_repeat</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform einops repeat operation on each sub array in the container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    **axes_lengths</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.repeat applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[30, 40], [50, 75]]),</span>
<span class="sd">    ...                   b=ivy.array([[1, 2], [4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; repeated = ivy.Container.static_einops_repeat(</span>
<span class="sd">    ...    x, &#39;h w -&gt; (tile h) w&#39;, tile=2)</span>
<span class="sd">    &gt;&gt;&gt; print(repeated)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[30, 40],</span>
<span class="sd">                    [50, 75],</span>
<span class="sd">                    [30, 40],</span>
<span class="sd">                    [50, 75]]),</span>
<span class="sd">        b: ivy.array([[1, 2],</span>
<span class="sd">                    [4, 5],</span>
<span class="sd">                    [1, 2],</span>
<span class="sd">                    [4, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;einops_repeat&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">axes_lengths</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="einops_repeat"><a class="viewcode-back" href="../../../functional/ivy/general/einops_repeat/einops_repeat_container.html#ivy.container.container_methods.einops_repeat">[docs]</a><span class="k">def</span> <span class="nf">einops_repeat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.einops_repeat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.einops_repeat also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array or container to be repeated.</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with einops.repeat having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[30, 40], [50, 75]]),</span>
<span class="sd">    ...                   b=ivy.array([[1, 2], [4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; repeated = x.einops_repeat(&#39;h w -&gt;  h  (w tile)&#39;, tile=2)</span>
<span class="sd">    &gt;&gt;&gt; print(repeated)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[30, 30, 40, 40],</span>
<span class="sd">                      [50, 50, 75, 75]]),</span>
<span class="sd">        b: ivy.array([[1, 1, 2, 2],</span>
<span class="sd">                      [4, 4, 5, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_einops_repeat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">axes_lengths</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_value_is_nan"><a class="viewcode-back" href="../../../functional/ivy/general/value_is_nan/static_value_is_nan_container.html#ivy.container.container_methods.static_value_is_nan">[docs]</a><span class="k">def</span> <span class="nf">static_value_is_nan</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">include_infs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.value_is_nan. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.value_is_nan also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include infs and -infs in the check. Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is</span>
<span class="sd">        None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean as to whether the input value is a nan or not.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([452]), b=ivy.array([float(&#39;inf&#39;)]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_value_is_nan(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    With :class:`ivy.Container` input:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([float(&#39;nan&#39;)]), b=ivy.array([0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_value_is_nan(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>
<span class="sd">    With :class:`ivy.Container` input:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([float(&#39;inf&#39;)]), b=ivy.array([22]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_value_is_nan(x, include_infs=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;value_is_nan&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">include_infs</span><span class="o">=</span><span class="n">include_infs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="value_is_nan"><a class="viewcode-back" href="../../../functional/ivy/general/value_is_nan/value_is_nan_container.html#ivy.container.container_methods.value_is_nan">[docs]</a><span class="k">def</span> <span class="nf">value_is_nan</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">include_infs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.value_is_nan. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.value_is_nan also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include infs and -infs in the check. Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is</span>
<span class="sd">        None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise</span>
<span class="sd">        key_chains will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean as to whether the input value is a nan or not.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([425]), b=ivy.array([float(&#39;nan&#39;)]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([float(&#39;inf&#39;)]), b=ivy.array([0]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([float(&#39;inf&#39;)]), b=ivy.array([22]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.value_is_nan(include_infs=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_value_is_nan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">include_infs</span><span class="o">=</span><span class="n">include_infs</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_to_numpy"><a class="viewcode-back" href="../../../functional/ivy/general/to_numpy/static_to_numpy_container.html#ivy.container.container_methods.static_to_numpy">[docs]</a><span class="k">def</span> <span class="nf">static_to_numpy</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_numpy. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_numpy also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    copy</span>
<span class="sd">        Whether to copy the input. Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of numpy arrays copying all the element of the container</span>
<span class="sd">        ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 1, 1]),</span>
<span class="sd">    ...                   b=ivy.array([1, -1, 0, 0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_to_numpy(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([1, 0, 1, 1], dtype=int32),</span>
<span class="sd">        b: array([1, -1, 0, 0], dtype=int32)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 0., 0., 1.]),</span>
<span class="sd">    ...                   b=ivy.native_array([1, 1, -1, 0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_to_numpy(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([1., 0., 0., 1.], dtype=float32),</span>
<span class="sd">        b: array([1, 1, -1, 0], dtype=int32)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;to_numpy&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="to_numpy"><a class="viewcode-back" href="../../../functional/ivy/general/to_numpy/to_numpy_container.html#ivy.container.container_methods.to_numpy">[docs]</a><span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_numpy. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_numpy also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    copy</span>
<span class="sd">        Whether to copy the input. Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of numpy arrays copying all the element of the container</span>
<span class="sd">        ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` instances:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0, 1]), b=ivy.array([1, 0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_numpy()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([-1, 0, 1], dtype=int32),</span>
<span class="sd">        b: array([1, 0, 1, 1], dtype=int32)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.native_array([[-1, 0, 1], [-1, 0, 1], [1, 0, -1]]),</span>
<span class="sd">    ...                   b=ivy.native_array([[-1, 0, 0], [1, 0, 1], [1, 1, 1]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_numpy()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([[-1, 0, 1],</span>
<span class="sd">                [-1, 0, 1],</span>
<span class="sd">                [1, 0, -1]], dtype=int32),</span>
<span class="sd">        b: array([[-1, 0, 0],</span>
<span class="sd">                [1, 0, 1],</span>
<span class="sd">                [1, 1, 1]], dtype=int32)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_to_numpy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_to_scalar"><a class="viewcode-back" href="../../../functional/ivy/general/to_scalar/static_to_scalar_container.html#ivy.container.container_methods.static_to_scalar">[docs]</a><span class="k">def</span> <span class="nf">static_to_scalar</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_scalar. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_scalar also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of scalar values copying all the element of the container</span>
<span class="sd">        ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1]), b=ivy.array([3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_to_scalar(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: -1,</span>
<span class="sd">        b: 3</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;to_scalar&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="to_scalar"><a class="viewcode-back" href="../../../functional/ivy/general/to_scalar/to_scalar_container.html#ivy.container.container_methods.to_scalar">[docs]</a><span class="k">def</span> <span class="nf">to_scalar</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_scalar. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_scalar also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of scalar values copying all the element of the container</span>
<span class="sd">        ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` instance:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1]), b=ivy.array([0]),</span>
<span class="sd">    ...                   c=ivy.array([-1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_scalar()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: 1,</span>
<span class="sd">        b: 0,</span>
<span class="sd">        c: -1</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_to_scalar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_to_list"><a class="viewcode-back" href="../../../functional/ivy/general/to_list/static_to_list_container.html#ivy.container.container_methods.static_to_list">[docs]</a><span class="k">def</span> <span class="nf">static_to_list</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_list. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_list also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list representation of the input array ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` inputs:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_to_list(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {a:[0,1,2]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;to_list&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_list. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_list also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list representation of the input array ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` instances:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_list()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {a:[0,1,2]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_to_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="static_stable_divide"><a class="viewcode-back" href="../../../functional/ivy/general/stable_divide/static_stable_divide_container.html#ivy.container.container_methods.static_stable_divide">[docs]</a><span class="k">def</span> <span class="nf">static_stable_divide</span><span class="p">(</span>
    <span class="n">numerator</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stable_divide. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stable_divide also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numerator</span>
<span class="sd">        Container of the numerators of the division.</span>
<span class="sd">    denominator</span>
<span class="sd">        Container of the denominators of the division.</span>
<span class="sd">    min_denominator</span>
<span class="sd">        Container of the minimum denominator to use,</span>
<span class="sd">        use global ivy._MIN_DENOMINATOR by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container of elements containing the new items following the numerically</span>
<span class="sd">        stable division.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([10., 15.]), b=ivy.asarray([20., 25.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.stable_divide(x, 0.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([20., 30.]),</span>
<span class="sd">        b: ivy.array([40., 50.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=1, b=10)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.asarray([4, 5])</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.stable_divide(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.25, 0.2]),</span>
<span class="sd">        b: ivy.array([2.5, 2.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=1, b=10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.array((4.5, 9))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.stable_divide(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([0.22222222, 0.11111111]),</span>
<span class="sd">        b: array([2.22222222, 1.11111111])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([1., 2.]), b=ivy.asarray([3., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.asarray([0.5, 2.5]), b=ivy.asarray([3.5, 0.4]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.stable_divide(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0.8]),</span>
<span class="sd">        b: ivy.array([0.857, 10.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([1., 2.], [3., 4.]),</span>
<span class="sd">    ...                   b=ivy.asarray([5., 6.], [7., 8.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.asarray([0.5, 2.5]), b=ivy.asarray([3.5, 0.4]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.stable_divide(x, y, min_denominator=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.4, 0.444]),</span>
<span class="sd">        b: ivy.array([0.909, 2.5])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;stable_divide&quot;</span><span class="p">,</span>
        <span class="n">numerator</span><span class="p">,</span>
        <span class="n">denominator</span><span class="p">,</span>
        <span class="n">min_denominator</span><span class="o">=</span><span class="n">min_denominator</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="stable_divide"><a class="viewcode-back" href="../../../functional/ivy/general/stable_divide/stable_divide_container.html#ivy.container.container_methods.stable_divide">[docs]</a><span class="k">def</span> <span class="nf">stable_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stable_divide. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stable_divide</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    denominator</span>
<span class="sd">        Container of the denominators of the division.</span>
<span class="sd">    min_denominator</span>
<span class="sd">        Container of the minimum denominator to use,</span>
<span class="sd">        use global ivy._MIN_DENOMINATOR by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of numpy arrays copying all the element of the container</span>
<span class="sd">        ``self``.</span>
<span class="sd">        A container of elements containing the new items following the numerically</span>
<span class="sd">        stable division, using ``self`` as the numerator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([3., 6.]), b=ivy.asarray([9., 12.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.stable_divide(5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.6, 1.2]),</span>
<span class="sd">        b: ivy.array([1.8, 2.4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([[2., 4.], [6., 8.]]),</span>
<span class="sd">    ...                   b=ivy.asarray([[10., 12.], [14., 16.]]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.stable_divide(2, min_denominator=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0.5, 1.],</span>
<span class="sd">              [1.5, 2.]]),</span>
<span class="sd">        b: ivy.array([[2.5, 3.],</span>
<span class="sd">              [3.5, 4.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([3., 6.]), b=ivy.asarray([9., 12.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.asarray([6., 9.]), b=ivy.asarray([12., 15.]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.stable_divide(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.5, 0.667]),</span>
<span class="sd">        b: ivy.array([0.75, 0.8])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_stable_divide</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">denominator</span><span class="p">,</span>
        <span class="n">min_denominator</span><span class="o">=</span><span class="n">min_denominator</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_stable_pow"><a class="viewcode-back" href="../../../functional/ivy/general/stable_pow/static_stable_pow_container.html#ivy.container.container_methods.static_stable_pow">[docs]</a><span class="k">def</span> <span class="nf">static_stable_pow</span><span class="p">(</span>
    <span class="n">base</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">exponent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stable_pow. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stable_pow also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base</span>
<span class="sd">        Container of the base.</span>
<span class="sd">    exponent</span>
<span class="sd">        Container of the exponent.</span>
<span class="sd">    min_base</span>
<span class="sd">        The minimum base to use, use global ivy._MIN_BASE by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise</span>
<span class="sd">        key_chains will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is</span>
<span class="sd">        False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container of elements containing the new items following the</span>
<span class="sd">        numerically stable power.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;stable_pow&quot;</span><span class="p">,</span>
        <span class="n">base</span><span class="p">,</span>
        <span class="n">exponent</span><span class="p">,</span>
        <span class="n">min_base</span><span class="o">=</span><span class="n">min_base</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="stable_pow"><a class="viewcode-back" href="../../../functional/ivy/general/stable_pow/stable_pow_container.html#ivy.container.container_methods.stable_pow">[docs]</a><span class="k">def</span> <span class="nf">stable_pow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">exponent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stable_pow. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stable_pow</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Container of the base.</span>
<span class="sd">    exponent</span>
<span class="sd">        Container of the exponent.</span>
<span class="sd">    min_base</span>
<span class="sd">        The minimum base to use, use global ivy._MIN_BASE by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise</span>
<span class="sd">        key_chains will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is</span>
<span class="sd">        False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container of elements containing the new items following the</span>
<span class="sd">        numerically stable power.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_stable_pow</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exponent</span><span class="p">,</span>
        <span class="n">min_base</span><span class="o">=</span><span class="n">min_base</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_einops_rearrange"><a class="viewcode-back" href="../../../functional/ivy/general/einops_rearrange/static_einops_rearrange_container.html#ivy.container.container_methods.static_einops_rearrange">[docs]</a><span class="k">def</span> <span class="nf">static_einops_rearrange</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.einops_rearrange. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.einops_rearrange</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.rearrange applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;einops_rearrange&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">axes_lengths</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="einops_rearrange"><a class="viewcode-back" href="../../../functional/ivy/general/einops_rearrange/einops_rearrange_container.html#ivy.container.container_methods.einops_rearrange">[docs]</a><span class="k">def</span> <span class="nf">einops_rearrange</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.einops_rearrange. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.einops_rearrange</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    **axes_lengths</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.rearrange applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_einops_rearrange</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">axes_lengths</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_clip_matrix_norm"><a class="viewcode-back" href="../../../functional/ivy/general/clip_matrix_norm/static_clip_matrix_norm_container.html#ivy.container.container_methods.static_clip_matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">static_clip_matrix_norm</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.clip_matrix_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.clip_matrix_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array containing elements to clip.</span>
<span class="sd">    max_norm</span>
<span class="sd">        The maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        The p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the matrix norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1., 2.]]),</span>
<span class="sd">    ...                   b=ivy.array([[3., 4., 5.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_clip_matrix_norm(x, 2.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0., 0.894, 1.79]]),</span>
<span class="sd">        b: ivy.array([[0.849, 1.13, 1.41]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;clip_matrix_norm&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">max_norm</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="clip_matrix_norm"><a class="viewcode-back" href="../../../functional/ivy/general/clip_matrix_norm/clip_matrix_norm_container.html#ivy.container.container_methods.clip_matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">clip_matrix_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.clip_matrix_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.clip_matrix_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to clip.</span>
<span class="sd">    max_norm</span>
<span class="sd">        The maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        The p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the matrix norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1., 2.]]),</span>
<span class="sd">    ...                   b=ivy.array([[3., 4., 5.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip_matrix_norm(2.0, p=1.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0., 1., 2.]]),</span>
<span class="sd">        b: ivy.array([[1.2, 1.6, 2.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_clip_matrix_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_norm</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_supports_inplace_updates"><a class="viewcode-back" href="../../../functional/ivy/general/supports_inplace_updates/static_supports_inplace_updates_container.html#ivy.container.container_methods.static_supports_inplace_updates">[docs]</a><span class="k">def</span> <span class="nf">static_supports_inplace_updates</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.supports_inplace. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.supports_inplace</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        An ivy.Container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An ivy.Container instance of bool values.</span>
<span class="sd">        True if nodes of x support in-place operations. False otherwise.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If a node(s) of the container isn&#39;t a class instance of ivy.Array or</span>
<span class="sd">        ivy.NativeArray, an exception will be raised.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With `ivy.Container` input and backend set as &#39;numpy&#39;:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array(1.0), b=ivy.array(2))</span>
<span class="sd">    &gt;&gt;&gt; ret = ivy.Container.static_supports_inplace_updates(x)</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    With `ivy.Container` input and backend set as &#39;tensorflow&#39;:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array(ivy.array([2.0, 0.0])),</span>
<span class="sd">    ...                   b=ivy.array([0., 5.5, -8]))</span>
<span class="sd">    &gt;&gt;&gt; ret = ivy.Container.static_supports_inplace_updates(x)</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;supports_inplace_updates&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="supports_inplace_updates"><a class="viewcode-back" href="../../../functional/ivy/general/supports_inplace_updates/supports_inplace_updates_container.html#ivy.container.container_methods.supports_inplace_updates">[docs]</a><span class="k">def</span> <span class="nf">supports_inplace_updates</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.supports_inplace_updates.</span>
<span class="sd">    This method simply wraps the static function, and so the docstring for</span>
<span class="sd">    the static variant also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        An ivy.Container whose elements are data types supported by Ivy.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An ivy.Container instance of bool values.</span>
<span class="sd">        True if nodes of the Container support in-place operations. False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With an `ivy.Container` instance and backend set as &#39;numpy&#39;:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array(1.0), b=ivy.array(2))</span>
<span class="sd">    &gt;&gt;&gt; ret = x.supports_inplace_updates()</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>
<span class="sd">    With an `ivy.Container` instance and backend set as &#39;tensorflow&#39;:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.variable(ivy.array([2.0, 0.0])),</span>
<span class="sd">    ...                   b=ivy.array([0., 5.5, -8]))</span>
<span class="sd">    &gt;&gt;&gt; ret = x.supports_inplace_updates()</span>
<span class="sd">    &gt;&gt;&gt; print(ret)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerWithGeneral</span><span class="o">.</span><span class="n">static_supports_inplace_updates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_get_num_dims"><a class="viewcode-back" href="../../../functional/ivy/general/get_num_dims/static_get_num_dims_container.html#ivy.container.container_methods.static_get_num_dims">[docs]</a><span class="k">def</span> <span class="nf">static_get_num_dims</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">as_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.get_num_dims. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.get_num_dims</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        ivy.Container to infer the number of dimensions for</span>
<span class="sd">    as_array</span>
<span class="sd">        Whether to return the shape as a array, default False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Shape of the array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(b = ivy.asarray([[0.,1.,1.],[1.,0.,0.],[8.,2.,3.]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_get_num_dims(x)</span>
<span class="sd">    {</span>
<span class="sd">        b: 2</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(b = ivy.array([[[0,0,0],[0,0,0],[0,0,0]]</span>
<span class="sd">    ...                                    [[0,0,0],[0,0,0],[0,0,0]],</span>
<span class="sd">    ...                                    [[0,0,0],[0,0,0],[0,0,0]]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_get_num_dims(x)</span>
<span class="sd">    {</span>
<span class="sd">        b: 3</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(b = ivy.array([[[0,0,0],[0,0,0],[0,0,0]],</span>
<span class="sd">    ...                                    [[0,0,0],[0,0,0],[0,0,0]]]),</span>
<span class="sd">    ...                                    c = ivy.asarray([[0.,1.,1.],[8.,2.,3.]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_get_num_dims(x)</span>
<span class="sd">    {</span>
<span class="sd">        b: 3,</span>
<span class="sd">        c: 2</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; ivy.Container.static_get_num_dims(x, as_array=True)</span>
<span class="sd">    {</span>
<span class="sd">        b: ivy.array(3),</span>
<span class="sd">        c: ivy.array(2)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;get_num_dims&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">as_array</span><span class="o">=</span><span class="n">as_array</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="get_num_dims"><a class="viewcode-back" href="../../../functional/ivy/general/get_num_dims/get_num_dims_container.html#ivy.container.container_methods.get_num_dims">[docs]</a><span class="k">def</span> <span class="nf">get_num_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">as_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.get_num_dims. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.get_num_dims</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        ivy.Container to infer the number of dimensions for</span>
<span class="sd">    as_array</span>
<span class="sd">        Whether to return the shape as a array, default False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Shape of the array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(b = ivy.asarray([[0.,1.,1.],[1.,0.,0.],[8.,2.,3.]]))</span>
<span class="sd">    &gt;&gt;&gt; a.get_num_dims()</span>
<span class="sd">    {</span>
<span class="sd">        b: 2</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.Container(b = ivy.array([[[0,0,0],[0,0,0],[0,0,0]],</span>
<span class="sd">    ...                                    [[0,0,0],[0,0,0],[0,0,0]],</span>
<span class="sd">    ...                                    [[0,0,0],[0,0,0],[0,0,0]]]))</span>
<span class="sd">    &gt;&gt;&gt; a.get_num_dims()</span>
<span class="sd">    {</span>
<span class="sd">        b: 3</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.Container(b = ivy.array([[[0,0,0],[0,0,0],[0,0,0]],</span>
<span class="sd">    ...                                    [[0,0,0],[0,0,0],[0,0,0]]]),</span>
<span class="sd">    ...                                    c = ivy.asarray([[0.,1.,1.],[8.,2.,3.]]))</span>
<span class="sd">    &gt;&gt;&gt; a.get_num_dims()</span>
<span class="sd">    {</span>
<span class="sd">        b: 3,</span>
<span class="sd">        c: 2</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; a.get_num_dims(as_array=True)</span>
<span class="sd">    {</span>
<span class="sd">        b: ivy.array(3),</span>
<span class="sd">        c: ivy.array(2)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerWithGeneral</span><span class="o">.</span><span class="n">static_get_num_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">as_array</span><span class="o">=</span><span class="n">as_array</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.gradients</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_stop_gradient"><a class="viewcode-back" href="../../../functional/ivy/gradients/stop_gradient/static_stop_gradient_container.html#ivy.container.container_methods.static_stop_gradient">[docs]</a><span class="k">def</span> <span class="nf">static_stop_gradient</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">preserve_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stop_gradient. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stop_gradient also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Array or Container for which to stop the gradient.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    preserve_type</span>
<span class="sd">        Whether to preserve gradient computation on ivy.Array instances. Default is</span>
<span class="sd">        True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The same array x, but with no gradient information.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` inputs:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                      b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_stop_gradient(x, preserve_type=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                      b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_stop_gradient(x, preserve_type=True, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;stop_gradient&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">preserve_type</span><span class="o">=</span><span class="n">preserve_type</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="stop_gradient"><a class="viewcode-back" href="../../../functional/ivy/gradients/stop_gradient/stop_gradient_container.html#ivy.container.container_methods.stop_gradient">[docs]</a><span class="k">def</span> <span class="nf">stop_gradient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">preserve_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stop_gradient. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stop_gradient also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Container for which to stop the gradient.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    preserve_type</span>
<span class="sd">        Whether to preserve gradient computation on ivy.Array instances. Default is</span>
<span class="sd">        True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The same array x, but with no gradient information.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` inputs:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                      b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.stop_gradient(preserve_type=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                      b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; x.stop_gradient(preserve_type=True, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_stop_gradient</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">preserve_type</span><span class="o">=</span><span class="n">preserve_type</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="adam_step"><a class="viewcode-back" href="../../../functional/ivy/gradients/adam_step/adam_step_container.html#ivy.container.container_methods.adam_step">[docs]</a><span class="k">def</span> <span class="nf">adam_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">mw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">vw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.adam_step. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.adam_step also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    mw</span>
<span class="sd">        running average of the gradients.</span>
<span class="sd">    vw</span>
<span class="sd">        running average of second moments of the gradients.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The adam step delta.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                         b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; mw = ivy.array([1., 4., 9.])</span>
<span class="sd">    &gt;&gt;&gt; vw = ivy.array([0.,])</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array([3.4])</span>
<span class="sd">    &gt;&gt;&gt; beta1 = 0.87</span>
<span class="sd">    &gt;&gt;&gt; beta2 = 0.976</span>
<span class="sd">    &gt;&gt;&gt; epsilon = 1e-5</span>
<span class="sd">    &gt;&gt;&gt; adam_step_delta = dcdw.adam_step(mw, vw, step, beta1=beta1, beta2=beta2,</span>
<span class="sd">    ...                                     epsilon=epsilon)</span>
<span class="sd">    &gt;&gt;&gt; print(adam_step_delta)</span>
<span class="sd">    ({</span>
<span class="sd">        a: ivy.array([6.49e+04, 1.74e+01, 1.95e+01]),</span>
<span class="sd">        b: ivy.array([2.02, 4.82, 8.17])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0.87, 3.61, 8.09]),</span>
<span class="sd">        b: ivy.array([1.26, 4., 8.48])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0., 0.024, 0.096]),</span>
<span class="sd">        b: ivy.array([0.216, 0.384, 0.6])</span>
<span class="sd">    })</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; dcdw = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                        b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; mw = ivy.Container(a=ivy.array([0., 0., 0.]),</span>
<span class="sd">    ...                    b=ivy.array([0., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; vw = ivy.Container(a=ivy.array([0.,]),</span>
<span class="sd">    ...                    b=ivy.array([0.,]))</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array([3.4])</span>
<span class="sd">    &gt;&gt;&gt; beta1 = 0.87</span>
<span class="sd">    &gt;&gt;&gt; beta2 = 0.976</span>
<span class="sd">    &gt;&gt;&gt; epsilon = 1e-5</span>
<span class="sd">    &gt;&gt;&gt; adam_step_delta = dcdw.adam_step(mw, vw, step, beta1=beta1, beta2=beta2,</span>
<span class="sd">    ...                                     epsilon=epsilon)</span>
<span class="sd">    &gt;&gt;&gt; print(adam_step_delta)</span>
<span class="sd">    ({</span>
<span class="sd">        a: ivy.array([0., 0.626, 0.626]),</span>
<span class="sd">        b: ivy.array([0.626, 0.626, 0.626])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0., 0.13, 0.26]),</span>
<span class="sd">        b: ivy.array([0.39, 0.52, 0.65])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0., 0.024, 0.096]),</span>
<span class="sd">        b: ivy.array([0.216, 0.384, 0.6])</span>
<span class="sd">    })</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">adam_step</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mw</span><span class="p">,</span> <span class="n">vw</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">beta1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span> <span class="n">beta2</span><span class="o">=</span><span class="n">beta2</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="optimizer_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/optimizer_update/optimizer_update_container.html#ivy.container.container_methods.optimizer_update">[docs]</a><span class="k">def</span> <span class="nf">optimizer_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">effective_grad</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Update weights ws of some function, given the true or effective derivatives</span>
<span class="sd">    of some cost c with respect to ws, [dc/dw for w in ws].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    effective_grad</span>
<span class="sd">        Effective gradients of the cost c with respect to the weights ws,</span>
<span class="sd">        [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the optimizer updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                    b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; effective_grad = ivy.array([0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; lr = 3e-4</span>
<span class="sd">    &gt;&gt;&gt; ws_new = w.optimizer_update(effective_grad, lr)</span>
<span class="sd">    &gt;&gt;&gt; print(ws_new)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                      b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; effective_grad = ivy.Container(a=ivy.array([0., 0., 0.]),</span>
<span class="sd">    ...                                   b=ivy.array([0., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; lr = 3e-4</span>
<span class="sd">    &gt;&gt;&gt; ws_new = w.optimizer_update(effective_grad, lr, out=w)</span>
<span class="sd">    &gt;&gt;&gt; print(w)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                    b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; effective_grad = ivy.Container(a=ivy.array([0., 0., 0.]),</span>
<span class="sd">    ...                                b=ivy.array([0., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array([3e-4])</span>
<span class="sd">    &gt;&gt;&gt; ws_new = w.optimizer_update(effective_grad, lr, stop_gradients=False)</span>
<span class="sd">    &gt;&gt;&gt; print(ws_new)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">optimizer_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">effective_grad</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gradient_descent_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/gradient_descent_update/gradient_descent_update_container.html#ivy.container.container_methods.gradient_descent_update">[docs]</a><span class="k">def</span> <span class="nf">gradient_descent_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.gradient_descent_update.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.gradient_descent_update also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be</span>
<span class="sd">        updated relative to the gradient.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new weights, following the gradient descent updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` inputs:</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([1., 2., 3.]),</span>
<span class="sd">    ...                      b=ivy.array([3.48, 5.72, 1.98]))</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([0.5, 0.2, 0.1])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.3)</span>
<span class="sd">    &gt;&gt;&gt; w_new = w.gradient_descent_update(dcdw, lr)</span>
<span class="sd">    &gt;&gt;&gt; print(w_new)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.85, 1.94, 2.97]),</span>
<span class="sd">        b: ivy.array([3.33, 5.66, 1.95])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([1., 2., 3.]),</span>
<span class="sd">    ...                      b=ivy.array([3.48, 5.72, 1.98]))</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.Container(a=ivy.array([0.5, 0.2, 0.1]),</span>
<span class="sd">    ...                         b=ivy.array([2., 3.42, 1.69]))</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.3)</span>
<span class="sd">    &gt;&gt;&gt; w_new = w.gradient_descent_update(dcdw, lr)</span>
<span class="sd">    &gt;&gt;&gt; print(w_new)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.85, 1.94, 2.97]),</span>
<span class="sd">        b: ivy.array([2.88, 4.69, 1.47])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">gradient_descent_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dcdw</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">,</span>
        <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lars_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/lars_update/lars_update_container.html#ivy.container.container_methods.lars_update">[docs]</a><span class="k">def</span> <span class="nf">lars_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">decay_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Update weights ws of some function, given the derivatives of some cost c with</span>
<span class="sd">    respect to ws, [dc/dw for w in ws], by applying Layerwise Adaptive Rate Scaling</span>
<span class="sd">    (LARS) method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate, the rate at which the weights should be updated relative to</span>
<span class="sd">        the gradient.</span>
<span class="sd">    decay_lambda</span>
<span class="sd">        The factor used for weight decay. Default is zero.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the LARS updates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lars_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dcdw</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">,</span>
        <span class="n">decay_lambda</span><span class="o">=</span><span class="n">decay_lambda</span><span class="p">,</span>
        <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="adam_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/adam_update/adam_update_container.html#ivy.container.container_methods.adam_update">[docs]</a><span class="k">def</span> <span class="nf">adam_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">mw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">vw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Update weights ws of some function, given the derivatives of some cost c with</span>
<span class="sd">    respect to ws, using ADAM update. `[reference]</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    mw_tm1</span>
<span class="sd">        running average of the gradients, from the previous time-step.</span>
<span class="sd">    vw_tm1</span>
<span class="sd">        running average of second moments of the gradients, from the previous</span>
<span class="sd">        time-step.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, and also new mw and vw, following the adam</span>
<span class="sd">        updates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">adam_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dcdw</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">,</span>
        <span class="n">mw_tm1</span><span class="p">,</span>
        <span class="n">vw_tm1</span><span class="p">,</span>
        <span class="n">step</span><span class="p">,</span>
        <span class="n">beta1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span>
        <span class="n">beta2</span><span class="o">=</span><span class="n">beta2</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lamb_update"><a class="viewcode-back" href="../../../functional/ivy/gradients/lamb_update/lamb_update_container.html#ivy.container.container_methods.lamb_update">[docs]</a><span class="k">def</span> <span class="nf">lamb_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">mw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">vw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">max_trust_ratio</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">decay_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Update weights ws of some function, given the derivatives of some cost c with</span>
<span class="sd">    respect to ws, [dc/dw for w in ws], by applying LAMB method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    mw_tm1</span>
<span class="sd">        running average of the gradients, from the previous time-step.</span>
<span class="sd">    vw_tm1</span>
<span class="sd">        running average of second moments of the gradients, from the previous</span>
<span class="sd">        time-step.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    max_trust_ratio</span>
<span class="sd">        The maximum value for the trust ratio. Default is 10.</span>
<span class="sd">    decay_lambda</span>
<span class="sd">        The factor used for weight decay. Default is zero.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the LAMB updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` inputs:</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([1., 2., 3.]), b=ivy.array([4., 5., 6.]))</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([3., 4., 5.])</span>
<span class="sd">    &gt;&gt;&gt; mw_tm1 = ivy.array([0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; vw_tm1 = ivy.array([0.])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(1.)</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array([2])</span>
<span class="sd">    &gt;&gt;&gt; new_weights = w.lamb_update(dcdw, mw_tm1, vw_tm1, lr, step)</span>
<span class="sd">    &gt;&gt;&gt; print(new_weights)</span>
<span class="sd">    ({</span>
<span class="sd">        a: ivy.array([1., 2., 3.]),</span>
<span class="sd">        b: ivy.array([4., 5., 6.])</span>
<span class="sd">    }, ivy.array([0.3, 0.4, 0.5]), ivy.array([1.01, 1.01, 1.02]))</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([1.,3.,5.]),</span>
<span class="sd">    ...                      b=ivy.array([3.,4.,2.]))</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.Container(a=ivy.array([0.2,0.3,0.6]),</span>
<span class="sd">    ...                         b=ivy.array([0.6,0.4,0.7]))</span>
<span class="sd">    &gt;&gt;&gt; mw_tm1 = ivy.Container(a=ivy.array([0.,0.,0.]),</span>
<span class="sd">    ...                           b=ivy.array([0.,0.,0.]))</span>
<span class="sd">    &gt;&gt;&gt; vw_tm1 = ivy.Container(a=ivy.array([0.,]),</span>
<span class="sd">    ...                           b=ivy.array([0.,]))</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array([3.4])</span>
<span class="sd">    &gt;&gt;&gt; beta1 = 0.9</span>
<span class="sd">    &gt;&gt;&gt; beta2 = 0.999</span>
<span class="sd">    &gt;&gt;&gt; epsilon = 1e-7</span>
<span class="sd">    &gt;&gt;&gt; max_trust_ratio = 10</span>
<span class="sd">    &gt;&gt;&gt; decay_lambda = 0</span>
<span class="sd">    &gt;&gt;&gt; stop_gradients = True</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.5)</span>
<span class="sd">    &gt;&gt;&gt; new_weights = w.lamb_update(dcdw, lr, mw_tm1, vw_tm1, step, beta1=beta1,</span>
<span class="sd">    ...                                beta2=beta2, epsilon=epsilon,</span>
<span class="sd">    ...                                max_trust_ratio=max_trust_ratio,</span>
<span class="sd">    ...                                decay_lambda=decay_lambda,</span>
<span class="sd">    ...                                stop_gradients=stop_gradients)</span>
<span class="sd">    &gt;&gt;&gt; print(new_weights)</span>
<span class="sd">    ({</span>
<span class="sd">        a: ivy.array([-0.708, 1.29, 3.29]),</span>
<span class="sd">        b: ivy.array([1.45, 2.45, 0.445])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0.02, 0.03, 0.06]),</span>
<span class="sd">        b: ivy.array([0.06, 0.04, 0.07])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([4.0e-05, 9.0e-05, 3.6e-04]),</span>
<span class="sd">        b: ivy.array([0.00036, 0.00016, 0.00049])</span>
<span class="sd">    })</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">lamb_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dcdw</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">,</span>
        <span class="n">mw_tm1</span><span class="p">,</span>
        <span class="n">vw_tm1</span><span class="p">,</span>
        <span class="n">step</span><span class="p">,</span>
        <span class="n">beta1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span>
        <span class="n">beta2</span><span class="o">=</span><span class="n">beta2</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">max_trust_ratio</span><span class="o">=</span><span class="n">max_trust_ratio</span><span class="p">,</span>
        <span class="n">decay_lambda</span><span class="o">=</span><span class="n">decay_lambda</span><span class="p">,</span>
        <span class="n">stop_gradients</span><span class="o">=</span><span class="n">stop_gradients</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.layers</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_linear"><a class="viewcode-back" href="../../../functional/ivy/layers/linear/static_linear_container.html#ivy.container.container_methods.static_linear">[docs]</a><span class="k">def</span> <span class="nf">static_linear</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.linear. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.linear also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input x to compute linear transformation on.</span>
<span class="sd">        *[outer_batch_shape,inner_batch_shape,in_features]*</span>
<span class="sd">    weight</span>
<span class="sd">        The weight matrix. *[outer_batch_shape,out_features,in_features]*</span>
<span class="sd">    bias</span>
<span class="sd">        The bias vector, default is ``None``. *[outer_batch_shape,out_features]*</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape </span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Result array of the linear transformation.</span>
<span class="sd">        *[outer_batch_shape,inner_batch_shape,out_features]*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1.1, 2.2, 3.3], \</span>
<span class="sd">                                       [11., 22., 33.]]), \</span>
<span class="sd">                          b=ivy.array([[1.245, 0.278, 4.105], \</span>
<span class="sd">                                       [7., 13., 17.]]))</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.array([[1., 2., 3.], \</span>
<span class="sd">                       [4., 5., 6.], \</span>
<span class="sd">                       [7., 8., 9.]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([1., 0., -1.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_linear(x, w, bias=b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[16.4, 35.2, 54.],</span>
<span class="sd">                      [155., 352., 549.]]),</span>
<span class="sd">        b: ivy.array([[15.1, 31., 46.9],</span>
<span class="sd">                      [85., 195., 305.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1.1, 2.2, 3.3], \</span>
<span class="sd">                                       [.0, .1, .2]]), \</span>
<span class="sd">                          b=ivy.array([[1.245, 0.278, 4.105], \</span>
<span class="sd">                                       [.7, .8, .9]]))</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([[1., 2., 3.]]), \</span>
<span class="sd">                          b=ivy.array([[.1, .2, .3]]))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(a=ivy.array([1.]), b=ivy.array([-1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_linear(x, w, bias=b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[16.4], </span>
<span class="sd">                      [1.8]]),</span>
<span class="sd">        b: ivy.array([[0.412], </span>
<span class="sd">                      [-0.5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="linear"><a class="viewcode-back" href="../../../functional/ivy/layers/linear/linear_container.html#ivy.container.container_methods.linear">[docs]</a><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.linear. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.linear also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input container to compute linear transformation on.</span>
<span class="sd">        *[outer_batch_shape,inner_batch_shape,in_features]*</span>
<span class="sd">    weight</span>
<span class="sd">        The weight matrix. *[outer_batch_shape,out_features,in_features]*</span>
<span class="sd">    bias</span>
<span class="sd">        The bias vector, default is ``None``. *[outer_batch_shape,out_features]*</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape </span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Result array of the linear transformation.</span>
<span class="sd">        *[outer_batch_shape,inner_batch_shape,out_features]*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1.1, 2.2, 3.3], \</span>
<span class="sd">                                       [11., 22., 33.]]), \</span>
<span class="sd">                          b=ivy.array([[1.245, 0.278, 4.105], \</span>
<span class="sd">                                       [7., 13., 17.]]))</span>
<span class="sd">    &gt;&gt;&gt; w = ivy.array([[1., 2., 3.], \</span>
<span class="sd">                       [4., 5., 6.], \</span>
<span class="sd">                       [7., 8., 9.]])</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([1, 0, -1])</span>
<span class="sd">    &gt;&gt;&gt; y = x.linear(w, bias=b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[16.4, 35.2, 54.], \</span>
<span class="sd">                      [155., 352., 549.]]), \</span>
<span class="sd">        b: ivy.array([[15.1, 31., 46.9], \</span>
<span class="sd">                      [85., 195., 305.]])</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_linear</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_dropout"><a class="viewcode-back" href="../../../functional/ivy/layers/dropout/static_dropout_container.html#ivy.container.container_methods.static_dropout">[docs]</a><span class="k">def</span> <span class="nf">static_dropout</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;dropout&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dropout"><a class="viewcode-back" href="../../../functional/ivy/layers/dropout/dropout_container.html#ivy.container.container_methods.dropout">[docs]</a><span class="k">def</span> <span class="nf">dropout</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_dropout</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_dropout1d"><a class="viewcode-back" href="../../../functional/ivy/layers/dropout1d/static_dropout1d_container.html#ivy.container.container_methods.static_dropout1d">[docs]</a><span class="k">def</span> <span class="nf">static_dropout1d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;dropout1d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">,</span>
        <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dropout1d"><a class="viewcode-back" href="../../../functional/ivy/layers/dropout1d/dropout1d_container.html#ivy.container.container_methods.dropout1d">[docs]</a><span class="k">def</span> <span class="nf">dropout1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_dropout1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">,</span>
        <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_scaled_dot_product_attention"><a class="viewcode-back" href="../../../functional/ivy/layers/scaled_dot_product_attention/static_scaled_dot_product_attention_container.html#ivy.container.container_methods.static_scaled_dot_product_attention">[docs]</a><span class="k">def</span> <span class="nf">static_scaled_dot_product_attention</span><span class="p">(</span>
    <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;scaled_dot_product_attention&quot;</span><span class="p">,</span>
        <span class="n">q</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="scaled_dot_product_attention"><a class="viewcode-back" href="../../../functional/ivy/layers/scaled_dot_product_attention/scaled_dot_product_attention_container.html#ivy.container.container_methods.scaled_dot_product_attention">[docs]</a><span class="k">def</span> <span class="nf">scaled_dot_product_attention</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_scaled_dot_product_attention</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_multi_head_attention"><a class="viewcode-back" href="../../../functional/ivy/layers/multi_head_attention/static_multi_head_attention_container.html#ivy.container.container_methods.static_multi_head_attention">[docs]</a><span class="k">def</span> <span class="nf">static_multi_head_attention</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">scale</span><span class="p">,</span>
    <span class="n">num_heads</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;multi_head_attention&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">num_heads</span><span class="p">,</span>
        <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">to_q_fn</span><span class="o">=</span><span class="n">to_q_fn</span><span class="p">,</span>
        <span class="n">to_kv_fn</span><span class="o">=</span><span class="n">to_kv_fn</span><span class="p">,</span>
        <span class="n">to_out_fn</span><span class="o">=</span><span class="n">to_out_fn</span><span class="p">,</span>
        <span class="n">to_q_v</span><span class="o">=</span><span class="n">to_q_v</span><span class="p">,</span>
        <span class="n">to_kv_v</span><span class="o">=</span><span class="n">to_kv_v</span><span class="p">,</span>
        <span class="n">to_out_v</span><span class="o">=</span><span class="n">to_out_v</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="multi_head_attention"><a class="viewcode-back" href="../../../functional/ivy/layers/multi_head_attention/multi_head_attention_container.html#ivy.container.container_methods.multi_head_attention">[docs]</a><span class="k">def</span> <span class="nf">multi_head_attention</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">,</span>
    <span class="n">num_heads</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_multi_head_attention</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">num_heads</span><span class="p">,</span>
        <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">to_q_fn</span><span class="o">=</span><span class="n">to_q_fn</span><span class="p">,</span>
        <span class="n">to_kv_fn</span><span class="o">=</span><span class="n">to_kv_fn</span><span class="p">,</span>
        <span class="n">to_out_fn</span><span class="o">=</span><span class="n">to_out_fn</span><span class="p">,</span>
        <span class="n">to_q_v</span><span class="o">=</span><span class="n">to_q_v</span><span class="p">,</span>
        <span class="n">to_kv_v</span><span class="o">=</span><span class="n">to_kv_v</span><span class="p">,</span>
        <span class="n">to_out_v</span><span class="o">=</span><span class="n">to_out_v</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_conv1d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv1d/static_conv1d_container.html#ivy.container.container_methods.static_conv1d">[docs]</a><span class="k">def</span> <span class="nf">static_conv1d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.conv1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.conv1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,w, d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fw,d_in, d_out]*. (d_in must be the same as d from x)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[2., 3., 4.], [5., 6., 7.]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[7., 8., 9.], [10., 11., 12]]]))</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[0., 0.5, 1.], [0.25, 0.5, 0.75], [-0.5, 0., 0.5 ]]])</span>
<span class="sd">    &gt;&gt;&gt; result= ivy.Container.static_conv1d(x,filters,(1,),&#39;VALID&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    {</span>
<span class="sd">        ... a: ivy.array([[[-1.25, 2.5, 6.25],</span>
<span class="sd">        ...                [-2., 5.5, 13.]]]),</span>
<span class="sd">        ... b: ivy.array([[[-2.5, 7.5, 17.5],</span>
<span class="sd">        ...                [-3.25, 10.5, 24.2]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;conv1d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv1d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv1d/conv1d_container.html#ivy.container.container_methods.conv1d">[docs]</a><span class="k">def</span> <span class="nf">conv1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.conv1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.conv1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,w, d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fw,d_in, d_out]*. (d_in must be the same as d from x)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[2., 3., 4.], [5., 6., 7.]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[7., 8., 9.], [10., 11., 12]]]))</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[0., 0.5, 1.], [0.25, 0.5, 0.75], [-0.5, 0., 0.5 ]]])</span>
<span class="sd">    &gt;&gt;&gt; result= x.conv1d(filters, (1,), &#39;VALID&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    {</span>
<span class="sd">        ... a: ivy.array([[[-1.25, 2.5, 6.25],</span>
<span class="sd">        ...                [-2., 5.5, 13.]]]),</span>
<span class="sd">        ... b: ivy.array([[[-2.5, 7.5, 17.5],</span>
<span class="sd">        ...                [-3.25, 10.5, 24.2]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_conv1d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_conv2d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv2d/static_conv2d_container.html#ivy.container.container_methods.static_conv2d">[docs]</a><span class="k">def</span> <span class="nf">static_conv2d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.conv2d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.conv2d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.eye(3, 3).reshape((1, 3, 3, 1)),</span>
<span class="sd">    ...                   b = ivy.eye(5, 5).reshape((1, 5, 5, 1)))</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[2., 0., 1.],</span>
<span class="sd">    ...                      [1., 3., 1.],</span>
<span class="sd">    ...                      [0., 1., 1.]]).reshape((3, 3, 1, 1))</span>
<span class="sd">    &gt;&gt;&gt; result = ivy.Container.static_conv2d(x, filters, (2,), &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array([[[[4.],[0.]],[[1.],[5.]]]]),</span>
<span class="sd">        b:ivy.array([[[[4.],[0.],[0.]],[[1.],[6.],[0.]],[[0.],[1.],[5.]]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;conv2d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv2d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv2d/conv2d_container.html#ivy.container.container_methods.conv2d">[docs]</a><span class="k">def</span> <span class="nf">conv2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of `ivy.conv2d`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.conv2d` also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in,d_out]*.</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating</span>
<span class="sd">        the per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.eye(3, 3).reshape((1, 3, 3, 1)),</span>
<span class="sd">    ...                   b = ivy.eye(5, 5).reshape((1, 5, 5, 1)))</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[2, 0, 1],</span>
<span class="sd">    ...                      [1, 3, 1],</span>
<span class="sd">    ...                      [0, 1, 1]], dtype=ivy.float32).reshape((3, 3, 1, 1))</span>
<span class="sd">    &gt;&gt;&gt; result = x.conv2d(filters, 2, &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array([[[[4.],[0.]],[[1.],[5.]]]]),</span>
<span class="sd">        b:ivy.array([[[[4.],[0.],[0.]],[[1.],[6.],[0.]],[[0.],[1.],[5.]]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_conv2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_conv1d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv1d_transpose/static_conv1d_transpose_container.html#ivy.container.container_methods.static_conv1d_transpose">[docs]</a><span class="k">def</span> <span class="nf">static_conv1d_transpose</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;conv1d_transpose&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv1d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv1d_transpose/conv1d_transpose_container.html#ivy.container.container_methods.conv1d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv1d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_conv1d_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_conv2d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv2d_transpose/static_conv2d_transpose_container.html#ivy.container.container_methods.static_conv2d_transpose">[docs]</a><span class="k">def</span> <span class="nf">static_conv2d_transpose</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;conv2d_transpose&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv2d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv2d_transpose/conv2d_transpose_container.html#ivy.container.container_methods.conv2d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv2d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_conv2d_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_depthwise_conv2d"><a class="viewcode-back" href="../../../functional/ivy/layers/depthwise_conv2d/static_depthwise_conv2d_container.html#ivy.container.container_methods.static_depthwise_conv2d">[docs]</a><span class="k">def</span> <span class="nf">static_depthwise_conv2d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.depthwise_conv2d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.depthwise_conv2d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in]*. (d_in must be the same as d from x)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; inp = ivy.Container(a=a, b=b)</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.random_normal(mean=0, std=1, shape=[3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_depthwise_conv2d(</span>
<span class="sd">    ...                                            inp,</span>
<span class="sd">    ...                                            filters,</span>
<span class="sd">    ...                                            strides=2,</span>
<span class="sd">    ...                                            padding=&#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">    [1, 64, 64, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;depthwise_conv2d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="depthwise_conv2d"><a class="viewcode-back" href="../../../functional/ivy/layers/depthwise_conv2d/depthwise_conv2d_container.html#ivy.container.container_methods.depthwise_conv2d">[docs]</a><span class="k">def</span> <span class="nf">depthwise_conv2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.depthwise_conv2d. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.depthwise_conv2d</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,h,w,d]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in]*. (d_in must be the same as d from self)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; inp = ivy.Container(a=a, b=b)</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.random_normal(mean=0, std=1, shape=[3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = inp.depthwise_conv2d(filters, 2, &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">    [1, 64, 64, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_depthwise_conv2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_conv3d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv3d/static_conv3d_container.html#ivy.container.container_methods.static_conv3d">[docs]</a><span class="k">def</span> <span class="nf">static_conv3d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;conv3d&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv3d"><a class="viewcode-back" href="../../../functional/ivy/layers/conv3d/conv3d_container.html#ivy.container.container_methods.conv3d">[docs]</a><span class="k">def</span> <span class="nf">conv3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_conv3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_conv3d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv3d_transpose/static_conv3d_transpose_container.html#ivy.container.container_methods.static_conv3d_transpose">[docs]</a><span class="k">def</span> <span class="nf">static_conv3d_transpose</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;conv3d_transpose&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conv3d_transpose"><a class="viewcode-back" href="../../../functional/ivy/layers/conv3d_transpose/conv3d_transpose_container.html#ivy.container.container_methods.conv3d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv3d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_conv3d_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_lstm_update"><a class="viewcode-back" href="../../../functional/ivy/layers/lstm_update/static_lstm_update_container.html#ivy.container.container_methods.static_lstm_update">[docs]</a><span class="k">def</span> <span class="nf">static_lstm_update</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">init_h</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">init_c</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">recurrent_kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">recurrent_bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;lstm_update&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">init_h</span><span class="p">,</span>
        <span class="n">init_c</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">recurrent_kernel</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">recurrent_bias</span><span class="o">=</span><span class="n">recurrent_bias</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lstm_update"><a class="viewcode-back" href="../../../functional/ivy/layers/lstm_update/lstm_update_container.html#ivy.container.container_methods.lstm_update">[docs]</a><span class="k">def</span> <span class="nf">lstm_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">init_h</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">init_c</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">recurrent_kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">recurrent_bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_lstm_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">init_h</span><span class="p">,</span>
        <span class="n">init_c</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">recurrent_kernel</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">recurrent_bias</span><span class="o">=</span><span class="n">recurrent_bias</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.linear_algebra</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="n">inf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># noinspection PyMissingConstructor,PyMethodParameters</span>




<div class="viewcode-block" id="static_matmul"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matmul/static_matmul_container.html#ivy.container.container_methods.static_matmul">[docs]</a><span class="k">def</span> <span class="nf">static_matmul</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">transpose_a</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">transpose_b</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.matmul. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.matul also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array</span>
<span class="sd">    x2</span>
<span class="sd">        second input array</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the matrix multiplication result of x1 and x2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;matmul&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">transpose_a</span><span class="o">=</span><span class="n">transpose_a</span><span class="p">,</span>
        <span class="n">transpose_b</span><span class="o">=</span><span class="n">transpose_b</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="matmul"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matmul/matmul_container.html#ivy.container.container_methods.matmul">[docs]</a><span class="k">def</span> <span class="nf">matmul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">transpose_a</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">transpose_b</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.matmul. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.matmul also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array</span>
<span class="sd">    x2</span>
<span class="sd">        second input array</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the matrix multiplication result of self and x2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_matmul</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">transpose_a</span><span class="o">=</span><span class="n">transpose_a</span><span class="p">,</span>
        <span class="n">transpose_b</span><span class="o">=</span><span class="n">transpose_b</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_cholesky"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/cholesky/static_cholesky_container.html#ivy.container.container_methods.static_cholesky">[docs]</a><span class="k">def</span> <span class="nf">static_cholesky</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">upper</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cholesky. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.cholesky also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container having shape (..., M, M) and whose innermost two</span>
<span class="sd">        dimensions form square symmetric positive-definite matrices. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    upper</span>
<span class="sd">        If True, the result must be the upper-triangular Cholesky factor U. If</span>
<span class="sd">        False, the result must be the lower-triangular Cholesky factor L.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the Cholesky factors for each square matrix. If upper</span>
<span class="sd">        is False, the returned container must contain lower-triangular matrices;</span>
<span class="sd">        otherwise, the returned container must contain upper-triangular matrices.</span>
<span class="sd">        The returned container must have a floating-point data type determined by</span>
<span class="sd">        Type Promotion Rules and must have the same shape as self.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[3., -1.], [-1., 3.]]),</span>
<span class="sd">    ...                      b=ivy.array([[2., 1.], [1., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cholesky(x, upper=&#39;false&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1.73, -0.577],</span>
<span class="sd">                        [0., 1.63]]),</span>
<span class="sd">        b: ivy.array([[1.41, 0.707],</span>
<span class="sd">                        [0., 0.707]])</span>
<span class="sd">     }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[3., -1], [-1., 3.]]),</span>
<span class="sd">    ...                      b=ivy.array([[2., 1.], [1., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; upper = ivy.Container(a=1, b=-1)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_roll(x, upper=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[3., 3.],</span>
<span class="sd">                     [-1., -1.]]),</span>
<span class="sd">        b: ivy.array([[1., 1.],</span>
<span class="sd">                      [1., 2.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;cholesky&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">upper</span><span class="o">=</span><span class="n">upper</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cholesky"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/cholesky/cholesky_container.html#ivy.container.container_methods.cholesky">[docs]</a><span class="k">def</span> <span class="nf">cholesky</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">upper</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cholesky. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.cholesky also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container having shape (..., M, M) and whose innermost two dimensions</span>
<span class="sd">        form square symmetric positive-definite matrices. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    upper</span>
<span class="sd">        If True, the result must be the upper-triangular Cholesky factor U. If</span>
<span class="sd">        False, the result must be the lower-triangular Cholesky factor L.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the Cholesky factors for each square matrix. If upper</span>
<span class="sd">        is False, the returned container must contain lower-triangular matrices;</span>
<span class="sd">        otherwise, the returned container must contain upper-triangular matrices.</span>
<span class="sd">        The returned container must have a floating-point data type determined by</span>
<span class="sd">        Type Promotion Rules and must have the same shape as self.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[3., -1],[-1., 3.]]),</span>
<span class="sd">    ...                      b=ivy.array([[2., 1.],[1., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cholesky(upper=&#39;false&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1.73, -0.577],</span>
<span class="sd">                        [0., 1.63]]),</span>
<span class="sd">        b: ivy.array([[1.41, 0.707],</span>
<span class="sd">                        [0., 0.707]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_cholesky</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">upper</span><span class="o">=</span><span class="n">upper</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_cross"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/cross/static_cross_container.html#ivy.container.container_methods.static_cross">[docs]</a><span class="k">def</span> <span class="nf">static_cross</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cross.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.cross also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis (dimension) of x1 and x2 containing the vectors for which to</span>
<span class="sd">        compute the cross product.vIf set to -1, the function computes the</span>
<span class="sd">        cross product for vectors defined by the last axis (dimension).</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise products. The returned array must have</span>
<span class="sd">        a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.array([9., 0., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1., 1., 0.]), b=ivy.array([1., 0., 1.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_cross(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-3., 3., 9.]),</span>
<span class="sd">        b: ivy.array([0., -6., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = x = ivy.Container(a=ivy.array([5., 0., 0.]), b=ivy.array([0., 0., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 7., 0.]), b=ivy.array([3., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_cross(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 35.]),</span>
<span class="sd">        b: ivy.array([0., 6., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;cross&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cross"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/cross/cross_container.html#ivy.container.container_methods.cross">[docs]</a><span class="k">def</span> <span class="nf">cross</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cross.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.cross also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis (dimension) of x1 and x2 containing the vectors for which to</span>
<span class="sd">        compute (default: -1) the cross product.vIf set to -1, the function</span>
<span class="sd">        computes the cross product for vectors defined by the last axis (dimension).</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise products. The returned array must have</span>
<span class="sd">        a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5., 0., 0.]), b=ivy.array([0., 0., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 7., 0.]), b=ivy.array([3., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.cross(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 35.]),</span>
<span class="sd">        b: ivy.array([0., 6., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_cross</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_det"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/det/static_det_container.html#ivy.container.container_methods.static_det">[docs]</a><span class="k">def</span> <span class="nf">static_det</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;det&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="det"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/det/det_container.html#ivy.container.container_methods.det">[docs]</a><span class="k">def</span> <span class="nf">det</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([[3., -1.], [-1., 3.]]) ,</span>
<span class="sd">    ...                   b = ivy.array([[2., 1.], [1., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.det()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {a:ivy.array(8.),b:ivy.array(1.)}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_det</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_diagonal"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/diagonal/static_diagonal_container.html#ivy.container.container_methods.static_diagonal">[docs]</a><span class="k">def</span> <span class="nf">static_diagonal</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;diagonal&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span>
        <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="diagonal"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/diagonal/diagonal_container.html#ivy.container.container_methods.diagonal">[docs]</a><span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_diagonal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span>
        <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_diag"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/diag/static_diag_container.html#ivy.container.container_methods.static_diag">[docs]</a><span class="k">def</span> <span class="nf">static_diag</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;diag&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="diag"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/diag/diag_container.html#ivy.container.container_methods.diag">[docs]</a><span class="k">def</span> <span class="nf">diag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.diag.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.diag also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=[[0, 1, 2],</span>
<span class="sd">    &gt;&gt;&gt;                      [3, 4, 5],</span>
<span class="sd">    &gt;&gt;&gt;                      [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; ivy.diag(x, k=1)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 5])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_diag</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="eigh"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/eigh/eigh_container.html#ivy.container.container_methods.eigh">[docs]</a><span class="k">def</span> <span class="nf">eigh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_eigvalsh"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/eigvalsh/static_eigvalsh_container.html#ivy.container.container_methods.static_eigvalsh">[docs]</a><span class="k">def</span> <span class="nf">static_eigvalsh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">UPLO</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.eigvalsh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.eigvalsh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Ivy container having shape ``(..., M, M)`` and whose</span>
<span class="sd">        innermost two dimensions form square matrices.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the computed eigenvalues.</span>
<span class="sd">        The returned array must have shape</span>
<span class="sd">        (..., M) and have the same data type as x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1.,2.,3.],[2.,4.,5.],[3.,5.,6.]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[1.,1.,2.],[1.,2.,1.],[2.,1.,1.]]]),</span>
<span class="sd">    ...                   c=ivy.array([[[2.,2.,2.],[2.,3.,3.],[2.,3.,3.]]]))</span>
<span class="sd">    &gt;&gt;&gt; e = ivy.Container.static_eigvalsh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(e)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[-0.51572949, 0.17091519, 11.3448143]]),</span>
<span class="sd">        b: ivy.array([[-1., 1., 4.]]),</span>
<span class="sd">        c: ivy.array([[-8.88178420e-16, 5.35898387e-01, 7.46410179e+00]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;eigvalsh&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">UPLO</span><span class="o">=</span><span class="n">UPLO</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="eigvalsh"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/eigvalsh/eigvalsh_container.html#ivy.container.container_methods.eigvalsh">[docs]</a><span class="k">def</span> <span class="nf">eigvalsh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">UPLO</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.eigvalsh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.eigvalsh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Ivy container having shape ``(..., M, M)`` and whose</span>
<span class="sd">        innermost two dimensions form square matrices.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the computed eigenvalues.</span>
<span class="sd">        The returned array must have shape</span>
<span class="sd">        (..., M) and have the same data type as x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1.,2.],[2.,1.]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[2.,4.],[4.,2.]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.eigvalsh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[-1., 3.]]),</span>
<span class="sd">        b: ivy.array([[-2., 6.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_eigvalsh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">UPLO</span><span class="o">=</span><span class="n">UPLO</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_inner"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/inner/static_inner_container.html#ivy.container.container_methods.static_inner">[docs]</a><span class="k">def</span> <span class="nf">static_inner</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;inner&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="inner"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/inner/inner_container.html#ivy.container.container_methods.inner">[docs]</a><span class="k">def</span> <span class="nf">inner</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_inner</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_inv"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/inv/static_inv_container.html#ivy.container.container_methods.static_inv">[docs]</a><span class="k">def</span> <span class="nf">static_inv</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">adjoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;inv&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">adjoint</span><span class="o">=</span><span class="n">adjoint</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="inv"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/inv/inv_container.html#ivy.container.container_methods.inv">[docs]</a><span class="k">def</span> <span class="nf">inv</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">adjoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inv.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.inv also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Ivy container having shape ``(..., M, M)`` and whose</span>
<span class="sd">        innermost two dimensions form square matrices.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the multiplicative inverses.</span>
<span class="sd">        The returned array must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion` and must have the</span>
<span class="sd">        same shape as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1.], [4., 4.]]),</span>
<span class="sd">    ...                      b=ivy.array([[4., 4.], [2., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.inv(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[-1, 0.25], [1., 0.]]),</span>
<span class="sd">        b: ivy.array([-0.25, 1.], [0.5, -1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_inv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">adjoint</span><span class="o">=</span><span class="n">adjoint</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_pinv"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/pinv/static_pinv_container.html#ivy.container.container_methods.static_pinv">[docs]</a><span class="k">def</span> <span class="nf">static_pinv</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container special method variant of ivy.pinv.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.pinv also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">    input array having shape ``(..., M, N)`` and whose innermost two dimensions form</span>
<span class="sd">    ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    rtol</span>
<span class="sd">        relative tolerance for small singular values approximately less</span>
<span class="sd">        than or equal to ``rtol * largest_singular_value`` are set to zero.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the pseudo-inverses. The returned array must have a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` and</span>
<span class="sd">        must have shape ``(..., N, M)`` (i.e., must have the same shape as</span>
<span class="sd">        ``x``, except the innermost two dimensions must be transposed).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    x = ivy.Container(a= ivy.array([[1., 2.],</span>
<span class="sd">    ...                             [3., 4.]]))</span>
<span class="sd">    y = pinv(x, None, None)</span>
<span class="sd">    print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[-2., 1.],</span>
<span class="sd">    ...               [1.5, -0.5]])</span>
<span class="sd">    }</span>
<span class="sd">    x = ivy.Container(a=ivy.array([[1., 2.],</span>
<span class="sd">    ...                            [3., 4.]]))</span>
<span class="sd">    out = ivy.Container(a=ivy.array())</span>
<span class="sd">    pinv(x, 0, out)</span>
<span class="sd">    print(out)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0.0426, 0.0964],</span>
<span class="sd">    ...               [0.0605, 0.1368]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;pinv&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="pinv"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/pinv/pinv_container.html#ivy.container.container_methods.pinv">[docs]</a><span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.pinv.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.pinv also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">    input array having shape ``(..., M, N)`` and whose innermost two dimensions form</span>
<span class="sd">        ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    rtol</span>
<span class="sd">    relative tolerance for small singular values approximately less than or equal to</span>
<span class="sd">        ``rtol * largest_singular_value`` are set to zero.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the pseudo-inverses. The returned array must have a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` and</span>
<span class="sd">        must have shape ``(..., N, M)`` (i.e., must have the same shape as</span>
<span class="sd">        ``x``, except the innermost two dimensions must be transposed).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    x = ivy.Container(a= ivy.array([[1., 2.],</span>
<span class="sd">    ...                             [3., 4.]]))</span>
<span class="sd">    y = pinv(x, None, None)</span>
<span class="sd">    print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[-2., 1.],</span>
<span class="sd">    ...               [1.5, -0.5]])</span>
<span class="sd">    }</span>
<span class="sd">    x = ivy.Container(a=ivy.array([[1., 2.],</span>
<span class="sd">    ...                            [3., 4.]]))</span>
<span class="sd">    out = ivy.Container(a=ivy.array())</span>
<span class="sd">    pinv(x, 0, out)</span>
<span class="sd">    print(out)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0.0426, 0.0964],</span>
<span class="sd">    ...               [0.0605, 0.1368]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_pinv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_matrix_norm"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_norm/static_matrix_norm_container.html#ivy.container.container_methods.static_matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">static_matrix_norm</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span> <span class="s2">&quot;nuc&quot;</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.matrix_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.matrix_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array having shape (..., M, N) and whose innermost two deimensions </span>
<span class="sd">        form MxN matrices. Should have a floating-point data type.</span>
<span class="sd">    ord</span>
<span class="sd">        Order of the norm. Default is &quot;fro&quot;.</span>
<span class="sd">    axis</span>
<span class="sd">        specifies the axes that hold 2-D matrices. Default: (-2, -1).</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are normed over are left in the</span>
<span class="sd">        result as dimensions with size one. With this option the result will</span>
<span class="sd">        broadcast correctly against the original x. Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Matrix norm of the array at specified axes.</span>
<span class="sd">    </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1.1, 2.2], [1., 2.]]), \</span>
<span class="sd">                          b=ivy.array([[1., 2.], [3., 4.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_matrix_norm(x, ord=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(4.2),</span>
<span class="sd">        b: ivy.array(6.)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.arange(12, dtype=float).reshape((3, 2, 2)), \</span>
<span class="sd">                          b=ivy.arange(8, dtype=float).reshape((2, 2, 2)))</span>
<span class="sd">    &gt;&gt;&gt; ord = ivy.Container(a=1, b=float(&#39;inf&#39;))</span>
<span class="sd">    &gt;&gt;&gt; axis = ivy.Container(a=(1, 2), b=(2, 1))</span>
<span class="sd">    &gt;&gt;&gt; k = ivy.Container(a=False, b=True)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_matrix_norm(x, ord=ord, axis=axis, keepdims=k)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4.24, 11.4, 19.2]),</span>
<span class="sd">        b: ivy.array([[[3.7]], </span>
<span class="sd">                      [[11.2]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;matrix_norm&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="matrix_norm"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_norm/matrix_norm_container.html#ivy.container.container_methods.matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">matrix_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span> <span class="s2">&quot;nuc&quot;</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.matrix_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.matrix_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Container having shape (..., M, N) and whose innermost two dimensions </span>
<span class="sd">        form MxN matrices. Should have a floating-point data type.</span>
<span class="sd">    ord</span>
<span class="sd">        Order of the norm. Default is &quot;fro&quot;.</span>
<span class="sd">    axis</span>
<span class="sd">        specifies the axes that hold 2-D matrices. Default: (-2, -1).</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are normed over are left in the</span>
<span class="sd">        result as dimensions with size one. With this option the result will</span>
<span class="sd">        broadcast correctly against the original x. Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Matrix norm of the array at specified axes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1.1, 2.2], [1., 2.]]), \</span>
<span class="sd">                          b=ivy.array([[1., 2.], [3., 4.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_norm(ord=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(4.2),</span>
<span class="sd">        b: ivy.array(6.)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.arange(12, dtype=float).reshape((3, 2, 2)), \</span>
<span class="sd">                          b=ivy.arange(8, dtype=float).reshape((2, 2, 2)))</span>
<span class="sd">    &gt;&gt;&gt; ord = ivy.Container(a=&quot;nuc&quot;, b=ivy.inf)</span>
<span class="sd">    &gt;&gt;&gt; axis = ivy.Container(a=(1, 2), b=(2, 1))</span>
<span class="sd">    &gt;&gt;&gt; k = ivy.Container(a=True, b=False)</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_norm(ord=ord, axis=axis, keepdims=k)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[4.24]], </span>
<span class="sd">                     [[11.4]], </span>
<span class="sd">                     [[19.2]]]),</span>
<span class="sd">        b: ivy.array([4., 12.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_matrix_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_matrix_power"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_power/static_matrix_power_container.html#ivy.container.container_methods.static_matrix_power">[docs]</a><span class="k">def</span> <span class="nf">static_matrix_power</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;matrix_power&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">n</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="matrix_power"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_power/matrix_power_container.html#ivy.container.container_methods.matrix_power">[docs]</a><span class="k">def</span> <span class="nf">matrix_power</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_matrix_power</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_matrix_rank"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_rank/static_matrix_rank_container.html#ivy.container.container_methods.static_matrix_rank">[docs]</a><span class="k">def</span> <span class="nf">static_matrix_rank</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.matrix_rank.</span>
<span class="sd">    This method returns the rank (i.e., number of non-zero singular values)</span>
<span class="sd">    of a matrix (or a stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container having shape ``(..., M, N)`` and whose innermost</span>
<span class="sd">        two dimensions form ``MxN`` matrices. Should have a floating-point data</span>
<span class="sd">        type.</span>
<span class="sd">    atol</span>
<span class="sd">        absolute tolerance. When None it’s considered to be zero.</span>
<span class="sd">    rtol</span>
<span class="sd">        relative tolerance for small singular values. Singular values</span>
<span class="sd">        approximately less than or equal to ``rtol * largest_singular_value`` are</span>
<span class="sd">        set to zero. If a ``float``, the value is equivalent to a zero-dimensional</span>
<span class="sd">        array having a floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        (as applied to ``x``) and must be broadcast against each matrix. If an</span>
<span class="sd">        ``array``, must have a floating-point data type and must be compatible with</span>
<span class="sd">        ``shape(x)[:-2]`` (see:ref:`broadcasting`). If ``None``, the default value</span>
<span class="sd">        is ``max(M, N) * eps``, where ``eps`` must be the machine epsilon associated</span>
<span class="sd">        with the floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        (as applied to ``x``).</span>
<span class="sd">        Default: ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the ranks. The returned array must have a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` and must have</span>
<span class="sd">        shape ``(...)`` (i.e., must have a shape equal to ``shape(x)[:-2]``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1., 0.], [0., 1.]]),</span>
<span class="sd">    ...                   b=ivy.array([[1., 0.], [0., 0.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_matrix_rank(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(2.),</span>
<span class="sd">        b: ivy.array(1.)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;matrix_rank&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="matrix_rank"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_rank/matrix_rank_container.html#ivy.container.container_methods.matrix_rank">[docs]</a><span class="k">def</span> <span class="nf">matrix_rank</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.matrix_rank.</span>
<span class="sd">    This method returns the rank (i.e., number of non-zero singular values)</span>
<span class="sd">    of a matrix (or a stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    atol</span>
<span class="sd">        absolute tolerance. When None it’s considered to be zero.</span>
<span class="sd">    rtol</span>
<span class="sd">        relative tolerance for small singular values. Singular values approximately</span>
<span class="sd">        less than or equal to ``rtol * largest_singular_value`` are set to zero. If</span>
<span class="sd">        a ``float``, the value is equivalent to a zero-dimensional array having a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` (as applied to</span>
<span class="sd">        ``x``) and must be broadcast against each matrix. If an ``array``, must have</span>
<span class="sd">        a floating-point data type and must be compatible with ``shape(x)[:-2]``</span>
<span class="sd">        (see :ref:`broadcasting`). If ``None``, the default value is</span>
<span class="sd">        ``max(M, N) * eps``, where ``eps`` must be the machine epsilon associated</span>
<span class="sd">        with the floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        (as applied to ``x``). Default: ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the ranks. The returned array must have a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` and must have</span>
<span class="sd">        shape ``(...)`` (i.e., must have a shape equal to ``shape(x)[:-2]``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1., 0.], [0., 1.]]),</span>
<span class="sd">    ...                   b=ivy.array([[1., 0.], [0., 0.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_rank()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(2),</span>
<span class="sd">        b: ivy.array(1)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_matrix_rank</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_matrix_transpose"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_transpose/static_matrix_transpose_container.html#ivy.container.container_methods.static_matrix_transpose">[docs]</a><span class="k">def</span> <span class="nf">static_matrix_transpose</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transposes a matrix (or a stack of matrices) ``x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the transpose for each matrix and having shape</span>
<span class="sd">        ``(..., N, M)``. The returned array must have the same data</span>
<span class="sd">        type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1., 1.], [0., 3.]]), \</span>
<span class="sd">                    b=ivy.array([[0., 4.], [3., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_matrix_transpose(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1., 0.],</span>
<span class="sd">                      [1., 3.]]),</span>
<span class="sd">        b: ivy.array([[0., 3.],</span>
<span class="sd">                      [4., 1.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;matrix_transpose&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="matrix_transpose"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/matrix_transpose/matrix_transpose_container.html#ivy.container.container_methods.matrix_transpose">[docs]</a><span class="k">def</span> <span class="nf">matrix_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transposes a matrix (or a stack of matrices) ``x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the transpose for each matrix and having shape</span>
<span class="sd">        ``(..., N, M)``. The returned array must have the same data</span>
<span class="sd">        type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1., 1.], [0., 3.]]), \</span>
<span class="sd">                  b=ivy.array([[0., 4.], [3., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.matrix_transpose(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1., 0.],</span>
<span class="sd">                      [1., 3.]]),</span>
<span class="sd">        b: ivy.array([[0., 3.],</span>
<span class="sd">                      [4., 1.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_matrix_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_outer"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/outer/static_outer_container.html#ivy.container.container_methods.static_outer">[docs]</a><span class="k">def</span> <span class="nf">static_outer</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="outer"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/outer/outer_container.html#ivy.container.container_methods.outer">[docs]</a><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_outer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_qr"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/qr/static_qr_container.html#ivy.container.container_methods.static_qr">[docs]</a><span class="k">def</span> <span class="nf">static_qr</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reduced&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;qr&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="qr"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/qr/qr_container.html#ivy.container.container_methods.qr">[docs]</a><span class="k">def</span> <span class="nf">qr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reduced&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_qr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_slogdet"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/slogdet/static_slogdet_container.html#ivy.container.container_methods.static_slogdet">[docs]</a><span class="k">def</span> <span class="nf">static_slogdet</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.slogdet. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.slogdet also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container having shape (..., M, M) and whose innermost two</span>
<span class="sd">        dimensions form square matrices. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        This function returns a container containing NamedTuples.</span>
<span class="sd">        Each NamedTuple of output will have -</span>
<span class="sd">            sign:</span>
<span class="sd">            An array containing a number representing the sign of the determinant</span>
<span class="sd">            for each square matrix.</span>
<span class="sd">            logabsdet:</span>
<span class="sd">            An array containing natural log of the absolute determinant of each</span>
<span class="sd">            square matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1.0, 2.0],</span>
<span class="sd">    ...                                [3.0, 4.0]]),</span>
<span class="sd">    ...                   b=ivy.array([[1.0, 2.0],</span>
<span class="sd">    ...                                [2.0, 1.0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_slogdet(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: (list[2], &lt;class ivy.array.array.Array&gt; shape=[]),</span>
<span class="sd">        b: (list[2], &lt;class ivy.array.array.Array&gt; shape=[])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;slogdet&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="slogdet"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/slogdet/slogdet_container.html#ivy.container.container_methods.slogdet">[docs]</a><span class="k">def</span> <span class="nf">slogdet</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.slogdet. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.slogdet also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container having shape (..., M, M) and whose innermost two dimensions</span>
<span class="sd">        form square matrices. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        This function returns container containing NamedTuples.</span>
<span class="sd">        Each NamedTuple of output will have -</span>
<span class="sd">            sign:</span>
<span class="sd">            An array of a number representing the sign of the determinant of each</span>
<span class="sd">            square.</span>
<span class="sd">            logabsdet:</span>
<span class="sd">            An array of the natural log of the absolute value of the determinant of</span>
<span class="sd">            each square.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1.0, 2.0],</span>
<span class="sd">    ...                                [3.0, 4.0]]),</span>
<span class="sd">    ...                   b=ivy.array([[1.0, 2.0],</span>
<span class="sd">    ...                                [2.0, 1.0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.slogdet()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: (list[2], &lt;class ivy.array.array.Array&gt; shape=[]),</span>
<span class="sd">        b: (list[2], &lt;class ivy.array.array.Array&gt; shape=[])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_slogdet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_solve"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/solve/static_solve_container.html#ivy.container.container_methods.static_solve">[docs]</a><span class="k">def</span> <span class="nf">static_solve</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;solve&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/solve/solve_container.html#ivy.container.container_methods.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_solve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_svd"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/svd/static_svd_container.html#ivy.container.container_methods.static_svd">[docs]</a><span class="k">def</span> <span class="nf">static_svd</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">compute_uv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">full_matrices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;svd&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">compute_uv</span><span class="o">=</span><span class="n">compute_uv</span><span class="p">,</span>
        <span class="n">full_matrices</span><span class="o">=</span><span class="n">full_matrices</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="svd"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/svd/svd_container.html#ivy.container.container_methods.svd">[docs]</a><span class="k">def</span> <span class="nf">svd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">compute_uv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">full_matrices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_svd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">compute_uv</span><span class="o">=</span><span class="n">compute_uv</span><span class="p">,</span>
        <span class="n">full_matrices</span><span class="o">=</span><span class="n">full_matrices</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_svdvals"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/svdvals/static_svdvals_container.html#ivy.container.container_methods.static_svdvals">[docs]</a><span class="k">def</span> <span class="nf">static_svdvals</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;svdvals&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="svdvals"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/svdvals/svdvals_container.html#ivy.container.container_methods.svdvals">[docs]</a><span class="k">def</span> <span class="nf">svdvals</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_svdvals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_tensordot"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/tensordot/static_tensordot_container.html#ivy.container.container_methods.static_tensordot">[docs]</a><span class="k">def</span> <span class="nf">static_tensordot</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;tensordot&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="tensordot"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/tensordot/tensordot_container.html#ivy.container.container_methods.tensordot">[docs]</a><span class="k">def</span> <span class="nf">tensordot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_tensordot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_trace"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/trace/static_trace_container.html#ivy.container.container_methods.static_trace">[docs]</a><span class="k">def</span> <span class="nf">static_trace</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.trace.</span>
<span class="sd">    This method Returns the sum along the specified diagonals of a matrix (or a</span>
<span class="sd">    stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    offset</span>
<span class="sd">        Offset of the diagonal from the main diagonal. Can be both positive and</span>
<span class="sd">        negative. Defaults to 0.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the traces and whose shape is determined by removing</span>
<span class="sd">        the last two dimensions and storing the traces in the last array dimension.</span>
<span class="sd">        For example, if ``x`` has rank ``k`` and shape ``(I, J, K, ..., L, M, N)``,</span>
<span class="sd">        then an output array has rank ``k-2`` and shape ``(I, J, K, ..., L)`` where</span>
<span class="sd">        ::</span>
<span class="sd">        out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(</span>
<span class="sd">    ...    a = ivy.array([[7, 1, 2],</span>
<span class="sd">    ...                   [1, 3, 5],</span>
<span class="sd">    ...                   [0, 7, 4]]),</span>
<span class="sd">    ...    b = ivy.array([[4, 3, 2],</span>
<span class="sd">    ...                   [1, 9, 5],</span>
<span class="sd">    ...                   [7, 0, 6]])</span>
<span class="sd">    )</span>

<span class="sd">    &gt;&gt;&gt; y = x.Container.static_trace(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(14),</span>
<span class="sd">        b: ivy.array(19)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;trace&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span>
        <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="trace"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/trace/trace_container.html#ivy.container.container_methods.trace">[docs]</a><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.trace.</span>
<span class="sd">    This method Returns the sum along the specified diagonals of a matrix (or a</span>
<span class="sd">    stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    offset</span>
<span class="sd">        Offset of the diagonal from the main diagonal. Can be both positive and</span>
<span class="sd">        negative. Defaults to 0.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the traces and whose shape is determined by removing</span>
<span class="sd">        the last two dimensions and storing the traces in the last array dimension.</span>
<span class="sd">        For example, if ``x`` has rank ``k`` and shape ``(I, J, K, ..., L, M, N)``,</span>
<span class="sd">        then an output array has rank ``k-2`` and shape ``(I, J, K, ..., L)`` where</span>
<span class="sd">        ::</span>
<span class="sd">        out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(</span>
<span class="sd">    ...    a = ivy.array([[7, 1, 2],</span>
<span class="sd">    ...                   [1, 3, 5],</span>
<span class="sd">    ...                   [0, 7, 4]]),</span>
<span class="sd">    ...    b = ivy.array([[4, 3, 2],</span>
<span class="sd">    ...                   [1, 9, 5],</span>
<span class="sd">    ...                   [7, 0, 6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.trace()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(14),</span>
<span class="sd">        b: ivy.array(19)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_trace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span>
        <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_vecdot"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vecdot/static_vecdot_container.html#ivy.container.container_methods.static_vecdot">[docs]</a><span class="k">def</span> <span class="nf">static_vecdot</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;vecdot&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vecdot"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vecdot/vecdot_container.html#ivy.container.container_methods.vecdot">[docs]</a><span class="k">def</span> <span class="nf">vecdot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_vecdot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x2</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_vector_norm"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vector_norm/static_vector_norm_container.html#ivy.container.container_methods.static_vector_norm">[docs]</a><span class="k">def</span> <span class="nf">static_vector_norm</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.vector_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.vector_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        If an integer, ``axis`` specifies the axis (dimension)</span>
<span class="sd">        along which to compute vector norms. If an n-tuple,</span>
<span class="sd">        ``axis`` specifies the axes (dimensions) along</span>
<span class="sd">        which to compute batched vector norms. If ``None``, the</span>
<span class="sd">         vector norm must be computed over all array values</span>
<span class="sd">         (i.e., equivalent to computing the vector norm of</span>
<span class="sd">        a flattened array). Negative indices must be</span>
<span class="sd">        supported. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the axes (dimensions) specified by ``axis``</span>
<span class="sd">        must be included in the result as singleton dimensions,</span>
<span class="sd">        and, accordingly, the result must be compatible</span>
<span class="sd">        with the input array (see :ref:`broadcasting`). Otherwise,</span>
<span class="sd">        if ``False``, the axes (dimensions) specified by ``axis`` must</span>
<span class="sd">        not be included in the result. Default: ``False``.</span>
<span class="sd">    ord</span>
<span class="sd">        order of the norm. The following mathematical norms must be supported:</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | ord              | description                |</span>
<span class="sd">        +==================+============================+</span>
<span class="sd">        | 1                | L1-norm (Manhattan)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | 2                | L2-norm (Euclidean)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | inf              | infinity norm              |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | (int,float &gt;= 1) | p-norm                     |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        The following non-mathematical &quot;norms&quot; must be supported:</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | ord              | description                    |</span>
<span class="sd">        +==================+================================+</span>
<span class="sd">        | 0                | sum(a != 0)                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -1               | 1./sum(1./abs(a))              |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -2               | 1./sqrt(sum(1./abs(a)/*/*2))   | </span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -inf             | min(abs(a))                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | (int,float &lt; 1)  | sum(abs(a)/*/*ord)/*/*(1./ord) |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        Default: ``2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the vector norms. If ``axis`` is</span>
<span class="sd">        ``None``, the returned array must be a zero-dimensional</span>
<span class="sd">        array containing a vector norm. If ``axis`` is</span>
<span class="sd">        a scalar value (``int`` or ``float``), the returned array</span>
<span class="sd">        must have a rank which is one less than the rank of ``x``.</span>
<span class="sd">        If ``axis`` is a ``n``-tuple, the returned array must have</span>
<span class="sd">         a rank which is ``n`` less than the rank of ``x``. The returned</span>
<span class="sd">        array must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;vector_norm&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vector_norm"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vector_norm/vector_norm_container.html#ivy.container.container_methods.vector_norm">[docs]</a><span class="k">def</span> <span class="nf">vector_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.vector_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.vector_norm also applies to this method with minimal changes.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        If an integer, ``axis`` specifies the axis (dimension)</span>
<span class="sd">        along which to compute vector norms. If an n-tuple, ``axis``</span>
<span class="sd">        specifies the axes (dimensions) along which to compute</span>
<span class="sd">        batched vector norms. If ``None``, the vector norm must be</span>
<span class="sd">        computed over all array values (i.e., equivalent to computing</span>
<span class="sd">        the vector norm of a flattened array). Negative indices must</span>
<span class="sd">        be supported. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the axes (dimensions) specified by ``axis`` must</span>
<span class="sd">        be included in the result as singleton dimensions, and, accordingly,</span>
<span class="sd">        the result must be compatible with the input array</span>
<span class="sd">        (see :ref:`broadcasting`).Otherwise, if ``False``, the axes</span>
<span class="sd">        (dimensions) specified by ``axis`` must not be included in</span>
<span class="sd">        the result. Default: ``False``.</span>
<span class="sd">    ord</span>
<span class="sd">        order of the norm. The following mathematical norms must be supported:</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | ord              | description                |</span>
<span class="sd">        +==================+============================+</span>
<span class="sd">        | 1                | L1-norm (Manhattan)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | 2                | L2-norm (Euclidean)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | inf              | infinity norm              |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | (int,float &gt;= 1) | p-norm                     |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        The following non-mathematical &quot;norms&quot; must be supported:</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | ord              | description                    |</span>
<span class="sd">        +==================+================================+</span>
<span class="sd">        | 0                | sum(a != 0)                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -1               | 1./sum(1./abs(a))              |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -2               | 1./sqrt(sum(1./abs(a)/*/*2))   | </span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -inf             | min(abs(a))                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | (int,float &lt; 1)  | sum(abs(a)/*/*ord)/*/*(1./ord) |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        Default: ``2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the vector norms. If ``axis`` is ``None``,</span>
<span class="sd">        the returned array must be a zero-dimensional array containing</span>
<span class="sd">        a vector norm. If ``axis`` is a scalar value (``int`` or ``float``),</span>
<span class="sd">        the returned array must have a rank which is one less than the</span>
<span class="sd">        rank of ``x``. If ``axis`` is a ``n``-tuple, the returned</span>
<span class="sd">        array must have a rank which is ``n`` less than the rank of</span>
<span class="sd">        ``x``. The returned array must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_vector_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_vector_to_skew_symmetric_matrix"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vector_to_skew_symmetric_matrix/static_vector_to_skew_symmetric_matrix_container.html#ivy.container.container_methods.static_vector_to_skew_symmetric_matrix">[docs]</a><span class="k">def</span> <span class="nf">static_vector_to_skew_symmetric_matrix</span><span class="p">(</span>
    <span class="n">vector</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;vector_to_skew_symmetric_matrix&quot;</span><span class="p">,</span>
        <span class="n">vector</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vector_to_skew_symmetric_matrix"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vector_to_skew_symmetric_matrix/vector_to_skew_symmetric_matrix_container.html#ivy.container.container_methods.vector_to_skew_symmetric_matrix">[docs]</a><span class="k">def</span> <span class="nf">vector_to_skew_symmetric_matrix</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_vector_to_skew_symmetric_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_vander"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vander/static_vander_container.html#ivy.container.container_methods.static_vander">[docs]</a><span class="k">def</span> <span class="nf">static_vander</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">increasing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.vander.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.vander also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        ivy container that contains 1-D arrays.</span>
<span class="sd">    N</span>
<span class="sd">        Number of columns in the output. If N is not specified,</span>
<span class="sd">        a square array is returned (N = len(x))</span>
<span class="sd">    increasing</span>
<span class="sd">        Order of the powers of the columns. If True, the powers increase</span>
<span class="sd">        from left to right, if False (the default) they are reversed.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container that contains the Vandermonde matrix of the arrays included</span>
<span class="sd">        in the input container.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(</span>
<span class="sd">            a = ivy.array([1, 2, 3, 5])</span>
<span class="sd">            b = ivy.array([6, 7, 8, 9])</span>
<span class="sd">        )</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_vander(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(</span>
<span class="sd">                [[  1,   1,   1,   1],</span>
<span class="sd">                [  8,   4,   2,   1],</span>
<span class="sd">                [ 27,   9,   3,   1],</span>
<span class="sd">                [125,  25,   5,   1]]</span>
<span class="sd">                ),</span>
<span class="sd">        b: ivy.array(</span>
<span class="sd">                [[216,  36,   6,   1],</span>
<span class="sd">                [343,  49,   7,   1],</span>
<span class="sd">                [512,  64,   8,   1],</span>
<span class="sd">                [729,  81,   9,   1]]</span>
<span class="sd">                )</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;vander&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
        <span class="n">increasing</span><span class="o">=</span><span class="n">increasing</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vander"><a class="viewcode-back" href="../../../functional/ivy/linear_algebra/vander/vander_container.html#ivy.container.container_methods.vander">[docs]</a><span class="k">def</span> <span class="nf">vander</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">increasing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.vander.</span>
<span class="sd">    This method Returns the Vandermonde matrix of the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        1-D input array.</span>
<span class="sd">    N</span>
<span class="sd">        Number of columns in the output. If N is not specified,</span>
<span class="sd">        a square array is returned (N = len(x))</span>
<span class="sd">    increasing</span>
<span class="sd">        Order of the powers of the columns. If True, the powers increase</span>
<span class="sd">        from left to right, if False (the default) they are reversed.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the Vandermonde matrices of the arrays</span>
<span class="sd">        included in the input container.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(</span>
<span class="sd">            a = ivy.array([1, 2, 3, 5])</span>
<span class="sd">            b = ivy.array([6, 7, 8, 9])</span>
<span class="sd">        )</span>
<span class="sd">    &gt;&gt;&gt; x.vander()</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(</span>
<span class="sd">                [[  1,   1,   1,   1],</span>
<span class="sd">                [  8,   4,   2,   1],</span>
<span class="sd">                [ 27,   9,   3,   1],</span>
<span class="sd">                [125,  25,   5,   1]]</span>
<span class="sd">                ),</span>
<span class="sd">        b: ivy.array(</span>
<span class="sd">                [[216,  36,   6,   1],</span>
<span class="sd">                [343,  49,   7,   1],</span>
<span class="sd">                [512,  64,   8,   1],</span>
<span class="sd">                [729,  81,   9,   1]]</span>
<span class="sd">                )</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_vander</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
        <span class="n">increasing</span><span class="o">=</span><span class="n">increasing</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.losses</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>




<div class="viewcode-block" id="static_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/cross_entropy/static_cross_entropy_container.html#ivy.container.container_methods.static_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">static_cross_entropy</span><span class="p">(</span>
    <span class="n">true</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cross_entropy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.cross_entropy also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    true</span>
<span class="sd">        input array or container containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing the predicted labels.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``,</span>
<span class="sd">        the cross-entropy will be computed along the last dimension.</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 0, 1]), b=ivy.array([1, 1, 0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(1.20397282),</span>
<span class="sd">        b: ivy.array(1.83258148)</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Array` and :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(1.20397282),</span>
<span class="sd">        b: ivy.array(1.60943794)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;cross_entropy&quot;</span><span class="p">,</span>
        <span class="n">true</span><span class="p">,</span>
        <span class="n">pred</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/cross_entropy/cross_entropy_container.html#ivy.container.container_methods.cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cross_entropy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.cross_entropy also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing the predicted labels.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``,</span>
<span class="sd">        the cross-entropy will be computed along the last dimension.</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array(0.5108256),</span>
<span class="sd">        b:ivy.array(1.609438)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_cross_entropy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pred</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_binary_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/binary_cross_entropy/static_binary_cross_entropy_container.html#ivy.container.container_methods.static_binary_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">static_binary_cross_entropy</span><span class="p">(</span>
    <span class="n">true</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.binary_cross_entropy. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.binary_cross_entropy</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    true</span>
<span class="sd">        input array or container containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing Predicted labels.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The binary cross entropy between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_binary_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.511, 0.223, 0.357]),</span>
<span class="sd">        b: ivy.array([1.61, 0.223, 1.61])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Array` and :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.7, 0.8, 0.2]),b=ivy.array([0.2, 0.6, 0.7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_binary_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.357, 0.223, 0.223]),</span>
<span class="sd">        b: ivy.array([1.61, 0.511, 1.2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;binary_cross_entropy&quot;</span><span class="p">,</span>
        <span class="n">true</span><span class="p">,</span>
        <span class="n">pred</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="binary_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/binary_cross_entropy/binary_cross_entropy_container.html#ivy.container.container_methods.binary_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">binary_cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.binary_cross_entropy. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.binary_cross_entropy also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing Predicted labels.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is</span>
<span class="sd">        ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The binary cross entropy between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.binary_cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.511, 0.223, 0.357]),</span>
<span class="sd">        b: ivy.array([1.61, 0.223, 1.61])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_binary_cross_entropy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pred</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_sparse_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/sparse_cross_entropy/static_sparse_cross_entropy_container.html#ivy.container.container_methods.static_sparse_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">static_sparse_cross_entropy</span><span class="p">(</span>
    <span class="n">true</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sparse_cross_entropy. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.sparse_cross_entropy</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    true</span>
<span class="sd">        input array or container containing the true labels as logits.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing the predicted labels as logits.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``, the</span>
<span class="sd">        cross-entropy will be computed along the last dimension. Default: ``-1``.</span>
<span class="sd">        epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The sparse cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_sparse_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.61, 0.511, 0.511]),</span>
<span class="sd">        b: ivy.array([0.223, 0.223, 1.61])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Array` and :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.7, 0.8, 0.2]),b=ivy.array([0.2, 0.6, 0.7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_sparse_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.223, 0.223, 0.357]),</span>
<span class="sd">        b: ivy.array([0.511, 0.511, 1.61])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sparse_cross_entropy&quot;</span><span class="p">,</span>
        <span class="n">true</span><span class="p">,</span>
        <span class="n">pred</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sparse_cross_entropy"><a class="viewcode-back" href="../../../functional/ivy/losses/sparse_cross_entropy/sparse_cross_entropy_container.html#ivy.container.container_methods.sparse_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">sparse_cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sparse_cross_entropy. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.sparse_cross_entropy also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container containing the true labels as logits.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing the predicted labels as logits.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``, the</span>
<span class="sd">        cross-entropy will be computed along the last dimension. Default: ``-1``.</span>
<span class="sd">        epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The sparse cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.sparse_cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.61, 0.511, 0.511]),</span>
<span class="sd">        b: ivy.array([0.223, 0.223, 1.61])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sparse_cross_entropy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pred</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.manipulation</span>
<span class="c1"># For Review</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>




<div class="viewcode-block" id="static_concat"><a class="viewcode-back" href="../../../functional/ivy/manipulation/concat/static_concat_container.html#ivy.container.container_methods.static_concat">[docs]</a><span class="k">def</span> <span class="nf">static_concat</span><span class="p">(</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.concat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.concat also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;concat&quot;</span><span class="p">,</span>
        <span class="n">xs</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="concat"><a class="viewcode-back" href="../../../functional/ivy/manipulation/concat/concat_container.html#ivy.container.container_methods.concat">[docs]</a><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.concat. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.concat also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_xs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_xs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_concat</span><span class="p">(</span>
        <span class="n">new_xs</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_expand_dims"><a class="viewcode-back" href="../../../functional/ivy/manipulation/expand_dims/static_expand_dims_container.html#ivy.container.container_methods.static_expand_dims">[docs]</a><span class="k">def</span> <span class="nf">static_expand_dims</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.expand_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.expand_dims also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        position where a new axis (dimension) of size one will be added. If an</span>
<span class="sd">        element of the container has the rank of ``N``, then the ``axis`` needs</span>
<span class="sd">        to be between ``[-N-1, N]``. Default: ``0``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the elements of ``x``, but with the dimensions of</span>
<span class="sd">        its elements added by one in a given ``axis``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4.]),</span>
<span class="sd">    ...                   c=ivy.array([6., 7.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_expand_dims(x, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0.],</span>
<span class="sd">                      [1.]]),</span>
<span class="sd">        b: ivy.array([[3.],</span>
<span class="sd">                      [4.]]),</span>
<span class="sd">        c: ivy.array([[6.],</span>
<span class="sd">                      [7.]])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4., 5.]),</span>
<span class="sd">    ...                   c=ivy.array([6., 7., 8.]))</span>
<span class="sd">    &gt;&gt;&gt; container_axis = ivy.Container(a=0, b=-1, c=(0,1))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_expand_dims(x, axis=container_axis)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0., 1., 2.]]),</span>
<span class="sd">        b: ivy.array([[3.],</span>
<span class="sd">                      [4.],</span>
<span class="sd">                      [5.]]),</span>
<span class="sd">        c: ivy.array([[[6., 7., 8.]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;expand_dims&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="expand_dims"><a class="viewcode-back" href="../../../functional/ivy/manipulation/expand_dims/expand_dims_container.html#ivy.container.container_methods.expand_dims">[docs]</a><span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.expand_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.expand_dims also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        position where a new axis (dimension) of size one will be added. If an</span>
<span class="sd">        element of the container has the rank of ``N``, the ``axis`` needs to</span>
<span class="sd">        be between ``[-N-1, N]``. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the elements of ``self``, but with the dimensions of</span>
<span class="sd">        its elements added by one in a given ``axis``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1.],</span>
<span class="sd">    ...                                [2., 3.]]),</span>
<span class="sd">    ...                   b=ivy.array([[4., 5.],</span>
<span class="sd">    ...                                [6., 7.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.expand_dims(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[0., 1.]],</span>
<span class="sd">                      [[2., 3.]]]),</span>
<span class="sd">        b: ivy.array([[[4., 5.]],</span>
<span class="sd">                      [[6., 7.]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_expand_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_split"><a class="viewcode-back" href="../../../functional/ivy/manipulation/split/static_split_container.html#ivy.container.container_methods.static_split">[docs]</a><span class="k">def</span> <span class="nf">static_split</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_or_size_splits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">with_remainder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.split. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.split also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        array to be divided into sub-arrays.</span>
<span class="sd">    num_or_size_splits</span>
<span class="sd">        Number of equal arrays to divide the array into along the given axis if an</span>
<span class="sd">        integer. The size of each split element if a sequence of integers. Default</span>
<span class="sd">        is to divide into as many 1-dimensional arrays as the axis dimension.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to split, default is ``0``.</span>
<span class="sd">    with_remainder</span>
<span class="sd">        If the tensor does not split evenly, then store the last remainder entry.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        A container with list of sub-arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;split&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">num_or_size_splits</span><span class="o">=</span><span class="n">num_or_size_splits</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">with_remainder</span><span class="o">=</span><span class="n">with_remainder</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../../functional/ivy/manipulation/split/split_container.html#ivy.container.container_methods.split">[docs]</a><span class="k">def</span> <span class="nf">split</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_or_size_splits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">with_remainder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.split. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.split also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array to be divided into sub-arrays.</span>
<span class="sd">    num_or_size_splits</span>
<span class="sd">        Number of equal arrays to divide the array into along the given axis if an</span>
<span class="sd">        integer. The size of each split element if a sequence of integers. Default</span>
<span class="sd">        is to divide into as many 1-dimensional arrays as the axis dimension.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to split, default is ``0``.</span>
<span class="sd">    with_remainder</span>
<span class="sd">        If the tensor does not split evenly, then store the last remainder entry.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        A container with list of sub-arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2, 5, 9]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.split()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[2], [5], [9]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_split</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_or_size_splits</span><span class="o">=</span><span class="n">num_or_size_splits</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">with_remainder</span><span class="o">=</span><span class="n">with_remainder</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_permute_dims"><a class="viewcode-back" href="../../../functional/ivy/manipulation/permute_dims/static_permute_dims_container.html#ivy.container.container_methods.static_permute_dims">[docs]</a><span class="k">def</span> <span class="nf">static_permute_dims</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.permute_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.permute_dims also applies</span>
<span class="sd">    to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;permute_dims&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="permute_dims"><a class="viewcode-back" href="../../../functional/ivy/manipulation/permute_dims/permute_dims_container.html#ivy.container.container_methods.permute_dims">[docs]</a><span class="k">def</span> <span class="nf">permute_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.permute_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.permute_dims also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_permute_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_flip"><a class="viewcode-back" href="../../../functional/ivy/manipulation/flip/static_flip_container.html#ivy.container.container_methods.static_flip">[docs]</a><span class="k">def</span> <span class="nf">static_flip</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.flip. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flip also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which to flip. If axis is None,</span>
<span class="sd">        all input array axes are flipped. If axis is negative,</span>
<span class="sd">        axis is counted from the last dimension. If provided more</span>
<span class="sd">        than one axis, only the specified axes. Default: None.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type and</span>
<span class="sd">        shape as ``x`` and whose elements, relative to ``x``, are reordered.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0, 1]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_flip(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 0, -1]),</span>
<span class="sd">        b: ivy.array([4, 3, 2])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0, 1]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_flip(x, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 0, -1]),</span>
<span class="sd">        b: ivy.array([4, 3, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;flip&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="flip"><a class="viewcode-back" href="../../../functional/ivy/manipulation/flip/flip_container.html#ivy.container.container_methods.flip">[docs]</a><span class="k">def</span> <span class="nf">flip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.flip. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.flip also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which to flip. If axis is None,</span>
<span class="sd">        all input array axes are flipped. If axis is negative,</span>
<span class="sd">        axis is counted from the last dimension. If provided</span>
<span class="sd">        more than one axis, only the specified axes. Default: None.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type and</span>
<span class="sd">        shape as ``self`` and whose elements, relative to ``self``, are reordered.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0, 1]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.flip()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 0, -1]),</span>
<span class="sd">        b: ivy.array([4, 3, 2])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0, 1]),</span>
<span class="sd">    ...                   b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.flip(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 0, -1]),</span>
<span class="sd">        b: ivy.array([4, 3, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_flip</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_reshape"><a class="viewcode-back" href="../../../functional/ivy/manipulation/reshape/static_reshape_container.html#ivy.container.container_methods.static_reshape">[docs]</a><span class="k">def</span> <span class="nf">static_reshape</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.reshape. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.reshape also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    shape</span>
<span class="sd">        The new shape should be compatible with the original shape.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is</span>
<span class="sd">        inferred from the length of the array and remaining dimensions.</span>
<span class="sd">    copy</span>
<span class="sd">        boolean indicating whether or not to copy the input array.</span>
<span class="sd">        If True, the function must always copy.</span>
<span class="sd">        If False, the function must never copy and must</span>
<span class="sd">        raise a ValueError in case a copy would be necessary.</span>
<span class="sd">        If None, the function must reuse existing memory buffer if possible</span>
<span class="sd">        and copy otherwise. Default: ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>
<span class="sd">    order</span>
<span class="sd">        Read the elements of x using this index order, and place the elements into</span>
<span class="sd">        the reshaped array using this index order.</span>
<span class="sd">        ‘C’ means to read / write the elements using C-like index order,</span>
<span class="sd">        with the last axis index changing fastest, back to the first axis index</span>
<span class="sd">        changing slowest.</span>
<span class="sd">        ‘F’ means to read / write the elements using Fortran-like index order, with</span>
<span class="sd">        the first index changing fastest, and the last index changing slowest.</span>
<span class="sd">        Note that the ‘C’ and ‘F’ options take no account of the memory layout</span>
<span class="sd">        of the underlying array, and only refer to the order of indexing.</span>
<span class="sd">        Default order is &#39;C&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2, 3, 4, 5]),</span>
<span class="sd">    ...                   b=ivy.array([0, 1, 2, 3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_reshape(x, (3,2))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1],</span>
<span class="sd">                      [2, 3],</span>
<span class="sd">                      [4, 5]]),</span>
<span class="sd">        b: ivy.array([[0, 1],</span>
<span class="sd">                      [2, 3],</span>
<span class="sd">                      [4, 5]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2, 3, 4, 5]),</span>
<span class="sd">    ...                   b=ivy.array([0, 1, 2, 3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_reshape(x, (3,2), order=&#39;F&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 3],</span>
<span class="sd">                      [1, 4],</span>
<span class="sd">                      [2, 5]]),</span>
<span class="sd">        b: ivy.array([[0, 3],</span>
<span class="sd">                      [1, 4],</span>
<span class="sd">                      [2, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;reshape&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="reshape"><a class="viewcode-back" href="../../../functional/ivy/manipulation/reshape/reshape_container.html#ivy.container.container_methods.reshape">[docs]</a><span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.reshape. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.reshape also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    shape</span>
<span class="sd">        The new shape should be compatible with the original shape.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is</span>
<span class="sd">        inferred from the length of the array and remaining dimensions.</span>
<span class="sd">    copy</span>
<span class="sd">        boolean indicating whether or not to copy the input array.</span>
<span class="sd">        If True, the function must always copy.</span>
<span class="sd">        If False, the function must never copy and must</span>
<span class="sd">        raise a ValueError in case a copy would be necessary.</span>
<span class="sd">        If None, the function must reuse existing memory buffer if possible</span>
<span class="sd">        and copy otherwise. Default: ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>
<span class="sd">    order</span>
<span class="sd">        Read the elements of the input container using this index order,</span>
<span class="sd">        and place the elements into the reshaped array using this index order.</span>
<span class="sd">        ‘C’ means to read / write the elements using C-like index order,</span>
<span class="sd">        with the last axis index changing fastest, back to the first axis index</span>
<span class="sd">        changing slowest.</span>
<span class="sd">        ‘F’ means to read / write the elements using Fortran-like index order, with</span>
<span class="sd">        the first index changing fastest, and the last index changing slowest.</span>
<span class="sd">        Note that the ‘C’ and ‘F’ options take no account of the memory layout</span>
<span class="sd">        of the underlying array, and only refer to the order of indexing.</span>
<span class="sd">        Default order is &#39;C&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``self``</span>
<span class="sd">        and elements as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2, 3, 4, 5]),</span>
<span class="sd">    ...                   b=ivy.array([0, 1, 2, 3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.reshape((2,3))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1, 2],</span>
<span class="sd">                      [3, 4, 5]]),</span>
<span class="sd">        b: ivy.array([[0, 1, 2],</span>
<span class="sd">                      [3, 4, 5]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2, 3, 4, 5]),</span>
<span class="sd">    ...                   b=ivy.array([0, 1, 2, 3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.reshape((2,3), order=&#39;F&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 2, 4],</span>
<span class="sd">                      [1, 3, 5]]),</span>
<span class="sd">        b: ivy.array([[0, 2, 4],</span>
<span class="sd">                      [1, 3, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_reshape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_roll"><a class="viewcode-back" href="../../../functional/ivy/manipulation/roll/static_roll_container.html#ivy.container.container_methods.static_roll">[docs]</a><span class="k">def</span> <span class="nf">static_roll</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.roll. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.roll also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    shift</span>
<span class="sd">        number of places by which the elements are shifted. If ``shift`` is a tuple,</span>
<span class="sd">        then ``axis`` must be a tuple of the same size, and each of the given axes</span>
<span class="sd">        must be shifted by the corresponding element in ``shift``. If ``shift`` is</span>
<span class="sd">        an ``int`` and ``axis`` a tuple, then the same ``shift`` must be used for</span>
<span class="sd">        all specified axes. If a shift is positivclipe, then array elements must be</span>
<span class="sd">        shifted positively (toward larger indices) along the dimension of ``axis``.</span>
<span class="sd">        If a shift is negative, then array elements must be shifted negatively</span>
<span class="sd">        (toward smaller indices) along the dimension of ``axis``.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which elements to shift. If ``axis`` is ``None``, the</span>
<span class="sd">        array must be flattened, shifted, and then restored to its original shape.</span>
<span class="sd">        Default ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``x`` and whose elements,</span>
<span class="sd">        relative to ``x``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_roll(x, 1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0., 1.]),</span>
<span class="sd">        b: ivy.array([5., 3., 4.])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; shift = ivy.Container(a=1, b=-1)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_roll(x, shift)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0., 1.]),</span>
<span class="sd">        b: ivy.array([4., 5., 3.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;roll&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">shift</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../../functional/ivy/manipulation/roll/roll_container.html#ivy.container.container_methods.roll">[docs]</a><span class="k">def</span> <span class="nf">roll</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.roll. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.roll also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    shift</span>
<span class="sd">        number of places by which the elements are shifted. If ``shift`` is a tuple,</span>
<span class="sd">        then ``axis`` must be a tuple of the same size, and each of the given axes</span>
<span class="sd">        must be shifted by the corresponding element in ``shift``. If ``shift`` is</span>
<span class="sd">        an ``int`` and ``axis`` a tuple, then the same ``shift`` must be used for</span>
<span class="sd">        all specified axes. If a shift is positive, then array elements must be</span>
<span class="sd">        shifted positively (toward larger indices) along the dimension of ``axis``.</span>
<span class="sd">        If a shift is negative, then array elements must be shifted negatively</span>
<span class="sd">        (toward smaller indices) along the dimension of ``axis``.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which elements to shift. If ``axis`` is ``None``, the</span>
<span class="sd">        array must be flattened, shifted, and then restored to its original shape.</span>
<span class="sd">        Default ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``self`` and whose</span>
<span class="sd">        elements, relative to ``self``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.roll(1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0., 1.]),</span>
<span class="sd">        b: ivy.array([5., 3., 4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_roll</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shift</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_squeeze"><a class="viewcode-back" href="../../../functional/ivy/manipulation/squeeze/static_squeeze_container.html#ivy.container.container_methods.static_squeeze">[docs]</a><span class="k">def</span> <span class="nf">static_squeeze</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.squeeze. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.squeeze also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;squeeze&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../../functional/ivy/manipulation/squeeze/squeeze_container.html#ivy.container.container_methods.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.squeeze. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.squeeze also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[10.], [11.]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[11.], [12.]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.squeeze(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10., 11.]]),</span>
<span class="sd">        b: ivy.array([[11., 12.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[10.], [11.]]]),</span>
<span class="sd">    ...                   b=ivy.array([[[11.], [12.]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.squeeze(0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.], [11.]]),</span>
<span class="sd">        b: ivy.array([[11.], [12.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_squeeze</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_stack"><a class="viewcode-back" href="../../../functional/ivy/manipulation/stack/static_stack_container.html#ivy.container.container_methods.static_stack">[docs]</a><span class="k">def</span> <span class="nf">static_stack</span><span class="p">(</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stack. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.stack also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_stack(x,axis = 1)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 2],</span>
<span class="sd">                    [1, 3]]),</span>
<span class="sd">        b: ivy.array([[4],</span>
<span class="sd">                    [5]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[3, 2], [1,0]]), b=ivy.array([[1, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_stack([x,y])</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[0, 1],</span>
<span class="sd">                    [2, 3]],</span>
<span class="sd">                    [[3, 2],</span>
<span class="sd">                    [1, 0]]]),</span>
<span class="sd">        b: ivy.array([[[4, 5]],</span>
<span class="sd">                    [[1, 0]]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; ivy.Container.static_stack([x,y],axis=1)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[0, 1],</span>
<span class="sd">                    [3, 2]],</span>
<span class="sd">                    [[2, 3],</span>
<span class="sd">                    [1, 0]]]),</span>
<span class="sd">        b: ivy.array([[[4, 5],</span>
<span class="sd">                    [1, 0]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;stack&quot;</span><span class="p">,</span>
        <span class="n">xs</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="stack"><a class="viewcode-back" href="../../../functional/ivy/manipulation/stack/stack_container.html#ivy.container.container_methods.stack">[docs]</a><span class="k">def</span> <span class="nf">stack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stack</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[3, 2], [1,0]]), b=ivy.array([[1, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; x.stack([y])</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[0, 1],</span>
<span class="sd">                    [2, 3]],</span>
<span class="sd">                    [[3, 2],</span>
<span class="sd">                    [1, 0]]]),</span>
<span class="sd">        b: ivy.array([[[4, 5]],</span>
<span class="sd">                    [[1, 0]]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; ivy.Container.static_stack([x,y],axis=1)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[0, 1],</span>
<span class="sd">                    [3, 2]],</span>
<span class="sd">                    [[2, 3],</span>
<span class="sd">                    [1, 0]]]),</span>
<span class="sd">        b: ivy.array([[[4, 5],</span>
<span class="sd">                    [1, 0]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_xs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_xs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_stack</span><span class="p">(</span>
        <span class="n">new_xs</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_repeat"><a class="viewcode-back" href="../../../functional/ivy/manipulation/repeat/static_repeat_container.html#ivy.container.container_methods.static_repeat">[docs]</a><span class="k">def</span> <span class="nf">static_repeat</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">repeats</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.repeat. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.repeat also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_repeat(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 1., 1., 2., 2.]),</span>
<span class="sd">        b: ivy.array([3., 3., 4., 4., 5., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;repeat&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">repeats</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="repeat"><a class="viewcode-back" href="../../../functional/ivy/manipulation/repeat/repeat_container.html#ivy.container.container_methods.repeat">[docs]</a><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">repeats</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.repeat. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.repeat</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">        b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.repeat(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 1., 1., 2., 2.]),</span>
<span class="sd">        b: ivy.array([3., 3., 4., 4., 5., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_repeat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">repeats</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_tile"><a class="viewcode-back" href="../../../functional/ivy/manipulation/tile/static_tile_container.html#ivy.container.container_methods.static_tile">[docs]</a><span class="k">def</span> <span class="nf">static_tile</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">reps</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.tile. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.tile also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_tile((2,3))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0,1,0,1,0,1],</span>
<span class="sd">                      [2,3,2,3,2,3],</span>
<span class="sd">                      [0,1,0,1,0,1],</span>
<span class="sd">                      [2,3,2,3,2,3]]),</span>
<span class="sd">        b: ivy.array([[4,5,4,5,4,5],</span>
<span class="sd">                      [4,5,4,5,4,5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;tile&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">reps</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="tile"><a class="viewcode-back" href="../../../functional/ivy/manipulation/tile/tile_container.html#ivy.container.container_methods.tile">[docs]</a><span class="k">def</span> <span class="nf">tile</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">reps</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.tile. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.tile also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.tile((2,3))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: (&lt;classivy.array.array.Array&gt;shape=[4,6]),</span>
<span class="sd">        b: (&lt;classivy.array.array.Array&gt;shape=[2,6])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_tile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reps</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_constant_pad"><a class="viewcode-back" href="../../../functional/ivy/manipulation/constant_pad/static_constant_pad_container.html#ivy.container.container_methods.static_constant_pad">[docs]</a><span class="k">def</span> <span class="nf">static_constant_pad</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.constant_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.constant_pad also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([1, 2, 3]), b = ivy.array([4, 5, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_constant_pad(x, pad_width = [[2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 0, 1, 2, 3, 0, 0, 0]),</span>
<span class="sd">        b: ivy.array([0, 0, 4, 5, 6, 0, 0, 0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;constant_pad&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="constant_pad"><a class="viewcode-back" href="../../../functional/ivy/manipulation/constant_pad/constant_pad_container.html#ivy.container.container_methods.constant_pad">[docs]</a><span class="k">def</span> <span class="nf">constant_pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.constant_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.constant_pad also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([1, 2, 3]), b = ivy.array([4, 5, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.constant_pad(pad_width = [[2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 0, 1, 2, 3, 0, 0, 0]),</span>
<span class="sd">        b: ivy.array([0, 0, 4, 5, 6, 0, 0, 0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_constant_pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_zero_pad"><a class="viewcode-back" href="../../../functional/ivy/manipulation/zero_pad/static_zero_pad_container.html#ivy.container.container_methods.static_zero_pad">[docs]</a><span class="k">def</span> <span class="nf">static_zero_pad</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.zero_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zero_pad also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;zero_pad&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="zero_pad"><a class="viewcode-back" href="../../../functional/ivy/manipulation/zero_pad/zero_pad_container.html#ivy.container.container_methods.zero_pad">[docs]</a><span class="k">def</span> <span class="nf">zero_pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.zero_pad. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.zero_pad also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_zero_pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pad_width</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_swapaxes"><a class="viewcode-back" href="../../../functional/ivy/manipulation/swapaxes/static_swapaxes_container.html#ivy.container.container_methods.static_swapaxes">[docs]</a><span class="k">def</span> <span class="nf">static_swapaxes</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">axis0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.swapaxes. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.swapaxes also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;swapaxes&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis0</span><span class="p">,</span>
        <span class="n">axis1</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="swapaxes"><a class="viewcode-back" href="../../../functional/ivy/manipulation/swapaxes/swapaxes_container.html#ivy.container.container_methods.swapaxes">[docs]</a><span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">axis0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.swapaxes. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.swapaxes also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_swapaxes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis0</span><span class="p">,</span>
        <span class="n">axis1</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_unstack"><a class="viewcode-back" href="../../../functional/ivy/manipulation/unstack/static_unstack_container.html#ivy.container.container_methods.static_unstack">[docs]</a><span class="k">def</span> <span class="nf">static_unstack</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.unstack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.unstack</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container to unstack.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis for which to unpack the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        Whether to keep dimension 1 in the unstack dimensions. Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        List of arrays, unpacked along specified dimensions, or containers</span>
<span class="sd">        with arrays unpacked at leaves</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),</span>
<span class="sd">                        b=ivy.array([[[9, 10], [11, 12]], [[13, 14], [15, 16]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_unstack(x, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([[1, 2],</span>
<span class="sd">                     [3, 4]]),</span>
<span class="sd">        b: ivy.array([[9, 10],</span>
<span class="sd">                     [11, 12]])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([[5, 6],</span>
<span class="sd">                     [7, 8]]),</span>
<span class="sd">         b: ivy.array([[13, 14],</span>
<span class="sd">                      [15, 16]])</span>
<span class="sd">    }]</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),</span>
<span class="sd">                        b=ivy.array([[[9, 10], [11, 12]], [[13, 14], [15, 16]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_unstack(x, axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([[[1, 2]],</span>
<span class="sd">                     [[5, 6]]]),</span>
<span class="sd">        b: ivy.array([[[9, 10]],</span>
<span class="sd">                     [[13, 14]]])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([[[3, 4]],</span>
<span class="sd">                     [[7, 8]]]),</span>
<span class="sd">        b: ivy.array([[[11, 12]],</span>
<span class="sd">                     [[15, 16]]])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;unstack&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="unstack"><a class="viewcode-back" href="../../../functional/ivy/manipulation/unstack/unstack_container.html#ivy.container.container_methods.unstack">[docs]</a><span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.unstack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.unstack</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to unstack at leaves.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis for which to unpack the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        Whether to keep dimension 1 in the unstack dimensions. Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Containers with arrays unpacked at leaves</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` instances:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),</span>
<span class="sd">                        b=ivy.array([[[9, 10], [11, 12]], [[13, 14], [15, 16]]]))</span>
<span class="sd">    &gt;&gt;&gt; x.unstack(axis=0)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([[1, 2],</span>
<span class="sd">                     [3, 4]]),</span>
<span class="sd">        b: ivy.array([[9, 10],</span>
<span class="sd">                      [11, 12]])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([[5, 6],</span>
<span class="sd">                      [7, 8]]),</span>
<span class="sd">        b: ivy.array([[13, 14],</span>
<span class="sd">                      [15, 16]])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_unstack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_clip"><a class="viewcode-back" href="../../../functional/ivy/manipulation/clip/static_clip_container.html#ivy.container.container_methods.static_clip">[docs]</a><span class="k">def</span> <span class="nf">static_clip</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x_min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x_max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.clip. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.clip also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container containing elements to clip.</span>
<span class="sd">    x_min</span>
<span class="sd">        Minimum value.</span>
<span class="sd">    x_max</span>
<span class="sd">        Maximum value.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the elements of x, but where values &lt; x_min are replaced</span>
<span class="sd">        with x_min, and those &gt; x_max with x_max.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_clip(x, 1., 5.)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),</span>
<span class="sd">    ...                   b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; x_min = ivy.Container(a=0, b=0)</span>
<span class="sd">    &gt;&gt;&gt; x_max = ivy.Container(a=1, b=1)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_clip(x, x_min, x_max)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 1.]),</span>
<span class="sd">        b: ivy.array([1., 1., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;clip&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">x_min</span><span class="p">,</span>
        <span class="n">x_max</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="clip"><a class="viewcode-back" href="../../../functional/ivy/manipulation/clip/clip_container.html#ivy.container.container_methods.clip">[docs]</a><span class="k">def</span> <span class="nf">clip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x_min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x_max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.clip. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.clip also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container containing elements to clip.</span>
<span class="sd">    x_min</span>
<span class="sd">        Minimum value.</span>
<span class="sd">    x_max</span>
<span class="sd">        Maximum value.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the elements of x, but where values &lt; x_min are replaced</span>
<span class="sd">        with x_min, and those &gt; x_max with x_max.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip(1,2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 1., 2.]),</span>
<span class="sd">        b: ivy.array([2., 2., 2.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_clip</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x_min</span><span class="p">,</span>
        <span class="n">x_max</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.norms</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="layer_norm"><a class="viewcode-back" href="../../../functional/ivy/norms/layer_norm/layer_norm_container.html#ivy.container.container_methods.layer_norm">[docs]</a><span class="k">def</span> <span class="nf">layer_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">normalized_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">_MIN_BASE</span><span class="p">,</span>
    <span class="n">new_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.layer_norm. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.layer_norm also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container</span>
<span class="sd">    normalized_idxs</span>
<span class="sd">        Indices to apply the normalization to.</span>
<span class="sd">    weight</span>
<span class="sd">        Learnable gamma variables for elementwise post-multiplication,</span>
<span class="sd">        default is ``None``.</span>
<span class="sd">    bias</span>
<span class="sd">        Learnable beta variables for elementwise post-addition, default is ``None``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        small constant to add to the denominator, use global ivy._MIN_BASE by</span>
<span class="sd">        default.</span>
<span class="sd">    new_std</span>
<span class="sd">        The standard deviation of the new normalized values. Default is 1.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The layer after applying layer normalization.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: ivy.array([7., 10., 12.]),</span>
<span class="sd">    ...                    &#39;b&#39;: ivy.array([[1., 2., 3.], [4., 5., 6.]])})</span>
<span class="sd">    &gt;&gt;&gt; normalized_idxs = [0]</span>
<span class="sd">    &gt;&gt;&gt; norm = x.layer_norm(normalized_idxs, epsilon=1.25, weight=0.3)</span>
<span class="sd">    &gt;&gt;&gt; print(norm)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0.342, 0.0427, 0.299]),</span>
<span class="sd">        b: ivy.array([[-0.241, -0.241, -0.241,</span>
<span class="sd">                      [0.241, 0.241, 0.241]])</span>
<span class="sd">    }</span>
<span class="sd">    With multiple :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: ivy.array([7., 10., 12.]),</span>
<span class="sd">    ...                    &#39;b&#39;: ivy.array([[1., 2., 3.], [4., 5., 6.]])})</span>
<span class="sd">    &gt;&gt;&gt; normalized_idxs = ivy.Container({&#39;a&#39;: [0], &#39;b&#39;: [1]})</span>
<span class="sd">    &gt;&gt;&gt; new_std = ivy.Container({&#39;a&#39;: 1.25, &#39;b&#39;: 1.5})</span>
<span class="sd">    &gt;&gt;&gt; bias = ivy.Container({&#39;a&#39;: [0.2, 0.5, 0.7], &#39;b&#39;: 0.3})</span>
<span class="sd">    &gt;&gt;&gt; norm = x.layer_norm(normalized_idxs, new_std=new_std, bias=bias)</span>
<span class="sd">    &gt;&gt;&gt; print(norm)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.62, 0.203, 1.42]),</span>
<span class="sd">        b: ivy.array([[-1.84, 0., 1.84],</span>
<span class="sd">                      [-1.84, 0., 1.84]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">layer_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">normalized_idxs</span><span class="p">,</span>
        <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">new_std</span><span class="o">=</span><span class="n">new_std</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.random</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_random_uniform"><a class="viewcode-back" href="../../../functional/ivy/random/random_uniform/static_random_uniform_container.html#ivy.container.container_methods.static_random_uniform">[docs]</a><span class="k">def</span> <span class="nf">static_random_uniform</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">low</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.random_uniform. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.random_uniform also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    low</span>
<span class="sd">        Lower boundary of the output interval. All values generated will be</span>
<span class="sd">        greater than or equal to ``low``. If array, must have same shape as</span>
<span class="sd">        ``high``.</span>
<span class="sd">    high</span>
<span class="sd">        Upper boundary of the output interval. All the values generated will be</span>
<span class="sd">        less than ``high``. If array, must have same shape as ``low``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized uniform distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9.8,7.6],[6.5,2.3]]),</span>
<span class="sd">    ...                   b=ivy.array([[0.9,2.4],[7.6,5.4]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10.9,32.4],[18.7,19.6]]),</span>
<span class="sd">    ...                   b=ivy.array([[4.3,5.6],[23.4,54.3]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_random_uniform(low=x, high=y, device=&#39;cpu&#39;,</span>
<span class="sd">    ...                                     dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.8, 23.7],</span>
<span class="sd">                      [17., 16.6]]),</span>
<span class="sd">        b: ivy.array([[2.35, 3.69],</span>
<span class="sd">                      [17.4, 48.]])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Array` and :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.0,-9.0,-3.4])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_random_uniform(low=x, high=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.481, -8.03, -2.74]),</span>
<span class="sd">        b: ivy.array([0.0999, -7.38, -1.29])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;random_uniform&quot;</span><span class="p">,</span>
        <span class="n">low</span><span class="o">=</span><span class="n">low</span><span class="p">,</span>
        <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="random_uniform"><a class="viewcode-back" href="../../../functional/ivy/random/random_uniform/random_uniform_container.html#ivy.container.container_methods.random_uniform">[docs]</a><span class="k">def</span> <span class="nf">random_uniform</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.random_uniform. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.random_uniform also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Lower boundary of the output interval. All values generated will be</span>
<span class="sd">        greater than or equal to ``low``. If array, must have same shape as</span>
<span class="sd">        ``high``.</span>
<span class="sd">    high</span>
<span class="sd">        Upper boundary of the output interval. All the values generated will be</span>
<span class="sd">        less than ``high``. If array, must have same shape as ``low``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized uniform distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7.5,6.7,0.9]), b=ivy.array([8.7,9.8,4.5]))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=17.4)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([11.2, 10.5, 13.1]),</span>
<span class="sd">        b: ivy.array([11.2, 11.9, 6.01])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.2, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.55, 10.1, 4.08]),</span>
<span class="sd">        b: ivy.array([9.45, 9.9, 8.6])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=14.2, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12.4, 11.7, 7.25]),</span>
<span class="sd">        b: ivy.array([11.8, 11.8, 4.96])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.8, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.86, 9.24, 6.43]),</span>
<span class="sd">        b: ivy.array([8.95, 10.1, 8.51])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=11.2, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9.6, 8.24, 3.67]),</span>
<span class="sd">        b: ivy.array([9.29, 11.2, 9.84])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=10.4, b=17.4)</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.24, 9.22, 1.52]),</span>
<span class="sd">        b: ivy.array([16.5, 13.4, 17.3])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.55, 10.1, 4.08]),</span>
<span class="sd">        b: ivy.array([9.45, 9.9, 8.6])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12.4, 11.7, 7.25]),</span>
<span class="sd">        b: ivy.array([11.8, 11.8, 4.96])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.86, 9.24, 6.43]),</span>
<span class="sd">        b: ivy.array([8.95, 10.1, 8.51])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9.6, 8.24, 3.67]),</span>
<span class="sd">        b: ivy.array([9.29, 11.2, 9.84])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9.8,7.6],[6.5,2.3]]),</span>
<span class="sd">    ...                   b=ivy.array([[0.9,2.4],[7.6,5.4]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10.9,32.4],[18.7,19.6]]),</span>
<span class="sd">    ...                   b=ivy.array([[4.3,5.6],[23.4,54.3]]))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.4, 17.],</span>
<span class="sd">                      [9.81, 10.9]]),</span>
<span class="sd">        b: ivy.array([[3.6, 4.31],</span>
<span class="sd">                      [18.8, 54.2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.1, 7.93],</span>
<span class="sd">                      [7.98, 6.]]),</span>
<span class="sd">        b: ivy.array([[4.28, 4.65],</span>
<span class="sd">                      [13.9, 28.9]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.6, 28.],</span>
<span class="sd">                      [16.4, 4.92]]),</span>
<span class="sd">        b: ivy.array([[3.61, 4.82],</span>
<span class="sd">                      [12.6, 10.2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.7, 28.4],</span>
<span class="sd">                      [9.29, 17.4]]),</span>
<span class="sd">        b: ivy.array([[1.88, 4.94],</span>
<span class="sd">                      [17., 9.68]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((2,2)), b=ivy.ones((2,2)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.4, 29.8],</span>
<span class="sd">                      [12.1, 3.9]]),</span>
<span class="sd">        b: ivy.array([[3.79, 5.4],</span>
<span class="sd">                      [16.2, 31.7]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_random_uniform</span><span class="p">(</span>
        <span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_random_normal"><a class="viewcode-back" href="../../../functional/ivy/random/random_normal/static_random_normal_container.html#ivy.container.container_methods.static_random_normal">[docs]</a><span class="k">def</span> <span class="nf">static_random_normal</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mean</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">std</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.random_normal. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.random_normal</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mean</span>
<span class="sd">        The mean of the normal distribution to sample from. Default is ``0.0``.</span>
<span class="sd">    std</span>
<span class="sd">        The standard deviation of the normal distribution to sample from.</span>
<span class="sd">        Must be non-negative. Default is ``1.0``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``mean`` and ``std`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9.8,7.6],[6.5,2.3]]),</span>
<span class="sd">    ...                   b=ivy.array([[0.9,2.4],[7.6,5.4]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10.9,32.4],[18.7,19.6]]),</span>
<span class="sd">    ...                   b=ivy.array([[4.3,5.6],[23.4,54.3]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_random_normal(mean=x, std=y, device=&#39;cpu&#39;,</span>
<span class="sd">    ...                                       dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[-4.11, 0.651],</span>
<span class="sd">                      [19.3, -30.4]]),</span>
<span class="sd">        b: ivy.array([[1.15, 3.39],</span>
<span class="sd">                      [-9.35, -13.9]])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Array` and :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.0,-9.0,-3.4])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_random_normal(mean=x, std=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0.651, -9.25, -3.54]),</span>
<span class="sd">        b: ivy.array([0.464, -8.51, -3.75])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;random_normal&quot;</span><span class="p">,</span>
        <span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span>
        <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="random_normal"><a class="viewcode-back" href="../../../functional/ivy/random/random_normal/random_normal_container.html#ivy.container.container_methods.random_normal">[docs]</a><span class="k">def</span> <span class="nf">random_normal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">std</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.random_normal. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.random_normal also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The mean of the normal distribution to sample from. Default is ``0.0``.</span>
<span class="sd">    std</span>
<span class="sd">        The standard deviation of the normal distribution to sample from.</span>
<span class="sd">        Must be non-negative. Default is ``1.0``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``mean`` and ``std`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">        type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7.5,6.7,0.9]),</span>
<span class="sd">    ...                   b=ivy.array([8.7,9.8,4.5]))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=17.4)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([11.9, -22.9, -24.8]),</span>
<span class="sd">        b: ivy.array([44.3, -21.6, 2.03])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.2, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7.82, 6.21, -0.431]),</span>
<span class="sd">        b: ivy.array([13.8, 9.9, 7.64])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=14.2, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-18.3, -3.42, 9.55]),</span>
<span class="sd">        b: ivy.array([-1.31, 7.68, -6.93])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.8, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([13.4, -3.14, 10.7]),</span>
<span class="sd">        b: ivy.array([11.7, 4.85, 5.83])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=11.2, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-6.84, 0.274, 14.2]),</span>
<span class="sd">        b: ivy.array([29.1, 7.19, 3.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=10.4, b=17.4)</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-9.5, 8.54, -9.13]),</span>
<span class="sd">        b: ivy.array([-24.5, 18.9, 11.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.47, 8.23, 8.69]),</span>
<span class="sd">        b: ivy.array([10.7, 16.2, 16.1])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.22, -15.9, 10.4]),</span>
<span class="sd">        b: ivy.array([19.9, 11.5, -2.15])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([19.6, -4.08, 6.09]),</span>
<span class="sd">        b: ivy.array([-23.9, 6.86, 17.6])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([14.7, 8.99, 8.46]),</span>
<span class="sd">        b: ivy.array([22.9, -5.97, -1.28])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9.8,7.6],[6.5,2.3]]),</span>
<span class="sd">    ...                   b=ivy.array([[0.9,2.4],[7.6,5.4]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10.9,32.4],[18.7,19.6]]),</span>
<span class="sd">    ...                   b=ivy.array([[4.3,5.6],[23.4,54.3]]))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.6, 7.89],</span>
<span class="sd">                      [9.39, 19.4]]),</span>
<span class="sd">        b: ivy.array([[3.76, 4.68],</span>
<span class="sd">                      [17.7, 24.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[30.9, 24.6],</span>
<span class="sd">                      [29.9, -25.3]]),</span>
<span class="sd">        b: ivy.array([[8.02, 1.92],</span>
<span class="sd">                      [-5.34, -54.1]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[7.82, -35.],</span>
<span class="sd">                      [11.7, 0.696]]),</span>
<span class="sd">        b: ivy.array([[-4.07, -2.91],</span>
<span class="sd">                      [19.2, 46.8]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[25.4, 28.3],</span>
<span class="sd">                      [19.6, -9.83]]),</span>
<span class="sd">        b: ivy.array([[2.95, 2.48],</span>
<span class="sd">                      [-30.8, -40.1]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((2,2)), b=ivy.ones((2,2)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[2.8, -45.6],</span>
<span class="sd">                      [-10.4, 0.65]]),</span>
<span class="sd">        b: ivy.array([[3.8, 1.43],</span>
<span class="sd">                      [23., 29.4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_random_normal</span><span class="p">(</span>
        <span class="n">mean</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_multinomial"><a class="viewcode-back" href="../../../functional/ivy/random/multinomial/static_multinomial_container.html#ivy.container.container_methods.static_multinomial">[docs]</a><span class="k">def</span> <span class="nf">static_multinomial</span><span class="p">(</span>
    <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">probs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.multinomial. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.multinomial also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    population_size</span>
<span class="sd">        The size of the population from which to draw samples.</span>
<span class="sd">    num_samples</span>
<span class="sd">        Number of independent samples to draw from the population.</span>
<span class="sd">    batch_size</span>
<span class="sd">        Number of tensors to generate. Default is 1.</span>
<span class="sd">    probs</span>
<span class="sd">        The unnormalized probabilities for all elements in population,</span>
<span class="sd">        default is uniform *[batch_shape, population_size]*</span>
<span class="sd">    replace</span>
<span class="sd">        Whether to replace samples once they&#39;ve been drawn. Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None)</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;multinomial&quot;</span><span class="p">,</span>
        <span class="n">population_size</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="n">probs</span><span class="o">=</span><span class="n">probs</span><span class="p">,</span>
        <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="multinomial"><a class="viewcode-back" href="../../../functional/ivy/random/multinomial/multinomial_container.html#ivy.container.container_methods.multinomial">[docs]</a><span class="k">def</span> <span class="nf">multinomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.multinomial. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.multinomial also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The unnormalized probabilities for all elements in population,</span>
<span class="sd">        default is uniform *[batch_shape, population_size]*</span>
<span class="sd">    population_size</span>
<span class="sd">        The size of the population from which to draw samples.</span>
<span class="sd">    num_samples</span>
<span class="sd">        Number of independent samples to draw from the population.</span>
<span class="sd">    batch_size</span>
<span class="sd">        Number of tensors to generate. Default is 1.</span>
<span class="sd">    replace</span>
<span class="sd">        Whether to replace samples once they&#39;ve been drawn. Default is ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None)</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_multinomial</span><span class="p">(</span>
        <span class="n">population_size</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="n">probs</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_randint"><a class="viewcode-back" href="../../../functional/ivy/random/randint/static_randint_container.html#ivy.container.container_methods.static_randint">[docs]</a><span class="k">def</span> <span class="nf">static_randint</span><span class="p">(</span>
    <span class="n">low</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.randint. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.randint also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    low</span>
<span class="sd">        Lowest integer that can be drawn from the distribution.</span>
<span class="sd">    high</span>
<span class="sd">        One above the highest integer that can be drawn from the distribution.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default integer data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns an array with the given shape filled with integers from</span>
<span class="sd">        the uniform distribution in the “half-open” interval [low, high)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9,7],[6,2]]),</span>
<span class="sd">    ...                   b=ivy.array([[0,2],[10,6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10,32],[18,19]]),</span>
<span class="sd">    ...                   b=ivy.array([[44,5],[23,54]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_randint(x, y, device=&#39;cpu&#39;, dtype=&#39;int32&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 27],</span>
<span class="sd">                      [16, 17]]),</span>
<span class="sd">        b: ivy.array([[13, 3],</span>
<span class="sd">                      [16, 19]])</span>
<span class="sd">    }</span>
<span class="sd">    With a mix of :class:`ivy.Array` and :class:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1,-9,3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4,7,9]),b=ivy.array([14,17,34]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_randint(x, y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 6, 5]),</span>
<span class="sd">        b: ivy.array([0, 10, 17])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;randint&quot;</span><span class="p">,</span>
        <span class="n">low</span><span class="p">,</span>
        <span class="n">high</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="randint"><a class="viewcode-back" href="../../../functional/ivy/random/randint/randint_container.html#ivy.container.container_methods.randint">[docs]</a><span class="k">def</span> <span class="nf">randint</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.randint. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.randint also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Lowest integer that can be drawn from the distribution.</span>
<span class="sd">    high</span>
<span class="sd">        One above the highest integer that can be drawn from the distribution.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default integer data type. Default ``None``</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns an array with the given shape filled with integers from</span>
<span class="sd">        the uniform distribution in the “half-open” interval [low, high)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7,6,0]),</span>
<span class="sd">    ...                   b=ivy.array([8,9,4]))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(30)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([23, 15, 20]),</span>
<span class="sd">        b: ivy.array([28, 22, 18])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(10, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9, 7, 7]),</span>
<span class="sd">        b: ivy.array([8, 9, 9])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(102, dtype=&#39;int8&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9, 8, 2]),</span>
<span class="sd">        b: ivy.array([62, 62, 60])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(54, device=&#39;cpu&#39;, dtype=&#39;int64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([30, 29, 26]),</span>
<span class="sd">        b: ivy.array([24, 24, 21])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(21, device=&#39;cpu&#39;, dtype=&#39;int8&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=54, b=17)</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, dtype=&#39;int64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int32&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int16&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9,7],[6,2]]),</span>
<span class="sd">    ...                   b=ivy.array([[0,2],[10,6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10,32],[18,19]]),</span>
<span class="sd">    ...                   b=ivy.array([[44,5],[23,54]]))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, dtype=&#39;int64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int32&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((2,2)), b=ivy.ones((2,2)))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int16&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_randint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">high</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_shuffle"><a class="viewcode-back" href="../../../functional/ivy/random/shuffle/static_shuffle_container.html#ivy.container.container_methods.static_shuffle">[docs]</a><span class="k">def</span> <span class="nf">static_shuffle</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.shuffle. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.shuffle also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container. Should have a numeric data type.</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container object, shuffled along the first dimension.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7, 6, 0]),</span>
<span class="sd">    ...                   b=ivy.array([8, 9, 4]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_shuffle(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 0, 6]),</span>
<span class="sd">        b: ivy.array([8, 4, 9])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;shuffle&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="shuffle"><a class="viewcode-back" href="../../../functional/ivy/random/shuffle/shuffle_container.html#ivy.container.container_methods.shuffle">[docs]</a><span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.shuffle. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.shuffle also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container. Should have a numeric data type.</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container object, shuffled along the first dimension.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5, 2, 9]),</span>
<span class="sd">    ...                   b=ivy.array([7, 1, 6]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.shuffle(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9, 5, 2]),</span>
<span class="sd">        b: ivy.array([6, 7, 1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_shuffle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">static_beta</span><span class="p">(</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.beta. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.beta also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container. Should have a numeric data type.</span>
<span class="sd">    alpha</span>
<span class="sd">        The alpha parameter of the distribution.</span>
<span class="sd">    beta</span>
<span class="sd">        The beta parameter of the distribution.</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the output array. Default is ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        The device to place the output array on. Default is ``None``.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type of the output array. Default is ``None``.</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container object, with values drawn from the beta distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;beta&quot;</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">beta</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">beta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.beta. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.beta also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container. Should have a numeric data type.</span>
<span class="sd">    alpha</span>
<span class="sd">        The alpha parameter of the distribution.</span>
<span class="sd">    beta</span>
<span class="sd">        The beta parameter of the distribution.</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the output array. Default is ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    device</span>
<span class="sd">        The device to place the output array on. Default is ``None``.</span>
<span class="sd">    dtype</span>
<span class="sd">        The data type of the output array. Default is ``None``.</span>
<span class="sd">    seed</span>
<span class="sd">        A python integer. Used to create a random seed distribution</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container object, with values drawn from the beta distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_beta</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>


<span class="c1">#ivy.container.searching</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_argmax"><a class="viewcode-back" href="../../../functional/ivy/searching/argmax/static_argmax_container.html#ivy.container.container_methods.static_argmax">[docs]</a><span class="k">def</span> <span class="nf">static_argmax</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">output_dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.argmax. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmax also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the maximum value of the flattened array. Deafult: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">        dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the array.</span>
<span class="sd">    output_dtype</span>
<span class="sd">         Optional data type of the output array.</span>
<span class="sd">    out</span>
<span class="sd">        If provided, the result will be inserted into this array. It should be of</span>
<span class="sd">        the appropriate shape and dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the maximum values across the</span>
<span class="sd">        specified axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;argmax&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">output_dtype</span><span class="o">=</span><span class="n">output_dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../../functional/ivy/searching/argmax/argmax_container.html#ivy.container.container_methods.argmax">[docs]</a><span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">output_dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.argmax. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmax also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the maximum value of the flattened array. Deafult: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">        dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the array.</span>
<span class="sd">    output_dtype</span>
<span class="sd">        Optional output dtype of the container.</span>
<span class="sd">    out</span>
<span class="sd">        If provided, the result will be inserted into this array. It should be of</span>
<span class="sd">        the appropriate shape and dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the maximum values across the</span>
<span class="sd">        specified axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_argmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">output_dtype</span><span class="o">=</span><span class="n">output_dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_argmin"><a class="viewcode-back" href="../../../functional/ivy/searching/argmin/static_argmin_container.html#ivy.container.container_methods.static_argmin">[docs]</a><span class="k">def</span> <span class="nf">static_argmin</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">int64</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.argmin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmin also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the minimum value of the flattened array. Default = None.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see Broadcasting). Otherwise, if False, the reduced axes</span>
<span class="sd">        (dimensions) must not be included in the result. Default = False.</span>
<span class="sd">    dtype</span>
<span class="sd">        An optional output_dtype from: int32, int64. Defaults to int64.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the minimum values across the</span>
<span class="sd">        specified axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;argmin&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../../functional/ivy/searching/argmin/argmin_container.html#ivy.container.container_methods.argmin">[docs]</a><span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.argmin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmin also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the minimum value of the flattened array. Default = None.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see Broadcasting). Otherwise, if False, the reduced axes</span>
<span class="sd">        (dimensions) must not be included in the result. Default = False.</span>
<span class="sd">    dtype</span>
<span class="sd">        An optional output_dtype from: int32, int64. Defaults to int64.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the minimum values across the</span>
<span class="sd">        specified axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_argmin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_nonzero"><a class="viewcode-back" href="../../../functional/ivy/searching/nonzero/static_nonzero_container.html#ivy.container.container_methods.static_nonzero">[docs]</a><span class="k">def</span> <span class="nf">static_nonzero</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">as_tuple</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.nonzero. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nonzero also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    as_tuple</span>
<span class="sd">        if True, the output is returned as a tuple of indices, one for each</span>
<span class="sd">        dimension of the input, containing the indices of the true elements in that</span>
<span class="sd">        dimension. If False, the coordinates are returned in a (N, ndim) array,</span>
<span class="sd">        where N is the number of true elements. Default = True.</span>
<span class="sd">    size</span>
<span class="sd">        if specified, the function will return an array of shape (size, ndim).</span>
<span class="sd">        If the number of non-zero elements is fewer than size, the remaining</span>
<span class="sd">        elements will be filled with fill_value. Default = None.</span>
<span class="sd">    fill_value</span>
<span class="sd">        when size is specified and there are fewer than size number of elements,</span>
<span class="sd">        the remaining elements in the output array will be filled with fill_value.</span>
<span class="sd">        Default = 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the nonzero values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;nonzero&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="n">as_tuple</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="nonzero"><a class="viewcode-back" href="../../../functional/ivy/searching/nonzero/nonzero_container.html#ivy.container.container_methods.nonzero">[docs]</a><span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">as_tuple</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.nonzero. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nonzero also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    as_tuple</span>
<span class="sd">        if True, the output is returned as a tuple of indices, one for each</span>
<span class="sd">        dimension of the input, containing the indices of the true elements in that</span>
<span class="sd">        dimension. If False, the coordinates are returned in a (N, ndim) array,</span>
<span class="sd">        where N is the number of true elements. Default = True.</span>
<span class="sd">    size</span>
<span class="sd">        if specified, the function will return an array of shape (size, ndim).</span>
<span class="sd">        If the number of non-zero elements is fewer than size, the remaining</span>
<span class="sd">        elements will be filled with fill_value. Default = None.</span>
<span class="sd">    fill_value</span>
<span class="sd">        when size is specified and there are fewer than size number of elements,</span>
<span class="sd">        the remaining elements in the output array will be filled with fill_value.</span>
<span class="sd">        Default = 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the nonzero values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_nonzero</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="n">as_tuple</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_where"><a class="viewcode-back" href="../../../functional/ivy/searching/where/static_where_container.html#ivy.container.container_methods.static_where">[docs]</a><span class="k">def</span> <span class="nf">static_where</span><span class="p">(</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.where. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.where also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the values of x1 where condition is True, and x2</span>
<span class="sd">        where condition is False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;where&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="where"><a class="viewcode-back" href="../../../functional/ivy/searching/where/where_container.html#ivy.container.container_methods.where">[docs]</a><span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.where. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.where also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the values of x1 where condition is True, and x2</span>
<span class="sd">        where condition is False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="static_argwhere"><a class="viewcode-back" href="../../../functional/ivy/searching/argwhere/static_argwhere_container.html#ivy.container.container_methods.static_argwhere">[docs]</a><span class="k">def</span> <span class="nf">static_argwhere</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.argwhere. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.argwhere</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Boolean array, for which indices are desired.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Indices for where the boolean array is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;argwhere&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="argwhere"><a class="viewcode-back" href="../../../functional/ivy/searching/argwhere/argwhere_container.html#ivy.container.container_methods.argwhere">[docs]</a><span class="k">def</span> <span class="nf">argwhere</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.argwhere. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.argwhere</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Boolean array, for which indices are desired.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Indices for where the boolean array is True.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :class:`ivy.Container` instance method</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2]), b=ivy.array([3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; res = x.argwhere()</span>
<span class="sd">    &gt;&gt;&gt; print(res)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0], [1]]),</span>
<span class="sd">        b: ivy.array([[0], [1]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0]), b=ivy.array([3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; res = x.argwhere()</span>
<span class="sd">    &gt;&gt;&gt; print(res)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0]]),</span>
<span class="sd">        b: ivy.array([[0], [1]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_argwhere</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.set</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>




<div class="viewcode-block" id="static_unique_all"><a class="viewcode-back" href="../../../functional/ivy/set/unique_all/static_unique_all_container.html#ivy.container.container_methods.static_unique_all">[docs]</a><span class="k">def</span> <span class="nf">static_unique_all</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;unique_all&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="unique_all"><a class="viewcode-back" href="../../../functional/ivy/set/unique_all/unique_all_container.html#ivy.container.container_methods.unique_all">[docs]</a><span class="k">def</span> <span class="nf">unique_all</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_unique_all</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_unique_counts"><a class="viewcode-back" href="../../../functional/ivy/set/unique_counts/static_unique_counts_container.html#ivy.container.container_methods.static_unique_counts">[docs]</a><span class="k">def</span> <span class="nf">static_unique_counts</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.unique_counts. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_counts also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. If ``x`` has more than one dimension, the function must</span>
<span class="sd">        flatten ``x`` and return the unique elements of the flattened array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(values, counts)`` whose</span>
<span class="sd">        - first element must have the field name ``values`` and must be an</span>
<span class="sd">        array containing the unique elements of ``x``.</span>
<span class="sd">        The array must have the same data type as ``x``.</span>
<span class="sd">        - second element must have the field name ``counts`` and must be an array</span>
<span class="sd">        containing the number of times each unique element occurs in ``x``.</span>
<span class="sd">        The returned array must have same shape as ``values`` and must</span>
<span class="sd">        have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 3. , 2. , 1. , 0.]),</span>
<span class="sd">    ...                   b=ivy.array([1,2,1,3,4,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.static_unique_counts(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: (list[2],&lt;classivy.array.Array&gt;shape=[4]),</span>
<span class="sd">        b: (list[2],&lt;classivy.array.Array&gt;shape=[4])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;unique_counts&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="unique_counts"><a class="viewcode-back" href="../../../functional/ivy/set/unique_counts/unique_counts_container.html#ivy.container.container_methods.unique_counts">[docs]</a><span class="k">def</span> <span class="nf">unique_counts</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.unique_counts. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.unique_counts</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. If ``x`` has more than one dimension, the function must</span>
<span class="sd">        flatten ``x`` and return the unique elements of the flattened array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(values, counts)`` whose</span>
<span class="sd">        - first element must have the field name ``values`` and must be an</span>
<span class="sd">        array containing the unique elements of ``x``.</span>
<span class="sd">        The array must have the same data type as ``x``.</span>
<span class="sd">        - second element must have the field name ``counts`` and must be an array</span>
<span class="sd">        containing the number of times each unique element occurs in ``x``.</span>
<span class="sd">        The returned array must have same shape as ``values`` and must</span>
<span class="sd">        have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 3. , 2. , 1. , 0.]),</span>
<span class="sd">    ...                   b=ivy.array([1,2,1,3,4,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.unique_counts()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: (list[2],&lt;classivy.array.array.Array&gt;shape=[4]),</span>
<span class="sd">        b: (list[2],&lt;classivy.array.array.Array&gt;shape=[4])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_unique_counts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_unique_values"><a class="viewcode-back" href="../../../functional/ivy/set/unique_values/static_unique_values_container.html#ivy.container.container_methods.static_unique_values">[docs]</a><span class="k">def</span> <span class="nf">static_unique_values</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;unique_values&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="unique_values"><a class="viewcode-back" href="../../../functional/ivy/set/unique_values/unique_values_container.html#ivy.container.container_methods.unique_values">[docs]</a><span class="k">def</span> <span class="nf">unique_values</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_unique_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_unique_inverse"><a class="viewcode-back" href="../../../functional/ivy/set/unique_inverse/static_unique_inverse_container.html#ivy.container.container_methods.static_unique_inverse">[docs]</a><span class="k">def</span> <span class="nf">static_unique_inverse</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;unique_inverse&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="unique_inverse"><a class="viewcode-back" href="../../../functional/ivy/set/unique_inverse/unique_inverse_container.html#ivy.container.container_methods.unique_inverse">[docs]</a><span class="k">def</span> <span class="nf">unique_inverse</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.unique_inverse. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_inverse also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">         input container. If ``x`` has more than one dimension, the function must</span>
<span class="sd">         flatten ``x`` and return the unique elements of the flattened array.</span>
<span class="sd">    key_chains</span>
<span class="sd">         The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">         If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">         will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">         Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">         Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">         Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">         a namedtuple ``(values, inverse_indices)`` whose</span>
<span class="sd">         - first element must have the field name ``values`` and must be an array</span>
<span class="sd">         containing the unique elements of ``x``. The array must have the same data</span>
<span class="sd">         type as ``x``.</span>
<span class="sd">         - second element must have the field name ``inverse_indices`` and</span>
<span class="sd">          must be an array containing the indices of ``values`` that</span>
<span class="sd">          reconstruct ``x``. The array must have the same shape as ``x`` and</span>
<span class="sd">          must have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4.,8.,3.,5.,9.,4.]),</span>
<span class="sd">    ...                   b=ivy.array([7,6,4,5,6,3,2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.unique_inverse()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">         {</span>
<span class="sd">           a: (list[2], &lt;class ivy.array.array.Array&gt; shape=[5]),</span>
<span class="sd">           b: (list[2], &lt;class ivy.array.array.Array&gt; shape=[6])</span>
<span class="sd">         }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_unique_inverse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.sorting</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_argsort"><a class="viewcode-back" href="../../../functional/ivy/sorting/argsort/static_argsort_container.html#ivy.container.container_methods.static_argsort">[docs]</a><span class="k">def</span> <span class="nf">static_argsort</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.argsort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.argsort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to sort. If set to ``-1``, the function must sort</span>
<span class="sd">        along the last axis. Default: ``-1``.</span>
<span class="sd">    descending</span>
<span class="sd">        sort order. If ``True``, the returned indices sort</span>
<span class="sd">        ``x`` in descending order (by value). If ``False``,</span>
<span class="sd">        the returned indices sort ``x`` in ascending order</span>
<span class="sd">        (by value). Default: ``False``.</span>
<span class="sd">    stable</span>
<span class="sd">        sort stability. If ``True``, the returned indices must maintain</span>
<span class="sd">        the relative order of ``x`` values which compare as equal.</span>
<span class="sd">        If ``False``, the returned indices may or may not maintain</span>
<span class="sd">        the relative order of ``x`` values which compare as equal (i.e., the</span>
<span class="sd">        relative order of ``x`` values which compare as equal</span>
<span class="sd">        is implementation-dependent). Default: ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the index values of sorted</span>
<span class="sd">        array. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7, 2, 1]),</span>
<span class="sd">    ...                   b=ivy.array([3, 2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.static_argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 2]),</span>
<span class="sd">        b: ivy.array([0, 1])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7, 2, 1]),</span>
<span class="sd">    ...                   b=ivy.array([[3, 2], [7, 0.2]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.static_argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 2]),</span>
<span class="sd">        b: ivy.array([[0, 1]],[0, 1]])</span>
<span class="sd">    }</span>
<span class="sd">    With :class:`ivy.Container` input:</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2, 5, 1]),</span>
<span class="sd">    ...                   b=ivy.array([1, 5], [.2,.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.static_argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 0, 1]),</span>
<span class="sd">        b: ivy.array([[1, 0],[0,1]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.native_array([2, 5, 1]),</span>
<span class="sd">    ...                   b=ivy.array([1, 5], [.2,.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.static_argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 0, 1]),</span>
<span class="sd">        b: ivy.array([[1, 0],[0,1]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;argsort&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">descending</span><span class="o">=</span><span class="n">descending</span><span class="p">,</span>
        <span class="n">stable</span><span class="o">=</span><span class="n">stable</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="argsort"><a class="viewcode-back" href="../../../functional/ivy/sorting/argsort/argsort_container.html#ivy.container.container_methods.argsort">[docs]</a><span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.argsort.</span>
<span class="sd">    This method simply wraps the function, and</span>
<span class="sd">    so the docstring for ivy.argsort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to sort. If set to ``-1``, the function</span>
<span class="sd">        must sort along the last axis. Default: ``-1``.</span>
<span class="sd">    descending</span>
<span class="sd">        sort order. If ``True``, the returned indices sort ``x``</span>
<span class="sd">        in descending order (by value). If ``False``, the</span>
<span class="sd">        returned indices sort ``x`` in ascending order (by value).</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    stable</span>
<span class="sd">        sort stability. If ``True``, the returned indices must</span>
<span class="sd">        maintain the relative order of ``x`` values which compare</span>
<span class="sd">        as equal. If ``False``, the returned indices may or may not</span>
<span class="sd">        maintain the relative order of ``x`` values which compare</span>
<span class="sd">        as equal (i.e., the relative order of ``x`` values which</span>
<span class="sd">        compare as equal is implementation-dependent).</span>
<span class="sd">        Default: ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains,</span>
<span class="sd">        otherwise key_chains will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the index values of sorted array.</span>
<span class="sd">        The returned array must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7, 2, 1]),</span>
<span class="sd">    ...                   b=ivy.array([3, 2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 2]),</span>
<span class="sd">        b: ivy.array([0, 1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_argsort</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">descending</span><span class="o">=</span><span class="n">descending</span><span class="p">,</span>
        <span class="n">stable</span><span class="o">=</span><span class="n">stable</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_sort"><a class="viewcode-back" href="../../../functional/ivy/sorting/sort/static_sort_container.html#ivy.container.container_methods.static_sort">[docs]</a><span class="k">def</span> <span class="nf">static_sort</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5, 9, 0.2]),</span>
<span class="sd">    ...                   b=ivy.array([[8, 1], [5, 0.8]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sort(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.2, 5., 9.]),</span>
<span class="sd">        b: ivy.array([[1., 8.], [0.8, 5.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([8, 0.5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([[9, 0.7], [0.4, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sort(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.5, 6., 8.]),</span>
<span class="sd">        b: ivy.array([[0.7, 9.], [0., 0.4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sort&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">descending</span><span class="o">=</span><span class="n">descending</span><span class="p">,</span>
        <span class="n">stable</span><span class="o">=</span><span class="n">stable</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../functional/ivy/sorting/sort/sort_container.html#ivy.container.container_methods.sort">[docs]</a><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5, 9, 0.2]),</span>
<span class="sd">    ...                   b=ivy.array([8, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sort()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.2, 5., 9.]),</span>
<span class="sd">        b: ivy.array([1, 8])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5, 9, 0.2]),</span>
<span class="sd">    ...                   b=ivy.array([[8, 1], [5, 0.8]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sort()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.2, 5., 9.]),</span>
<span class="sd">        b: ivy.array([[1., 8.], [0.8, 5.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([8, 0.5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([[9, 0.7], [0.4, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.sort(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.5, 6., 8.]),</span>
<span class="sd">        b: ivy.array([[0.7, 9.],[0., 0.4]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.native_array([8, 0.5, 6]),</span>
<span class="sd">    ...                   b=ivy.array([[9, 0.7], [0.4, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.sort(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.5, 6., 8.]),</span>
<span class="sd">        b: ivy.array([[0.7, 9.],[0., 0.4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sort</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">descending</span><span class="o">=</span><span class="n">descending</span><span class="p">,</span>
        <span class="n">stable</span><span class="o">=</span><span class="n">stable</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_searchsorted"><a class="viewcode-back" href="../../../functional/ivy/sorting/searchsorted/static_searchsorted_container.html#ivy.container.container_methods.static_searchsorted">[docs]</a><span class="k">def</span> <span class="nf">static_searchsorted</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ret_dtype</span><span class="o">=</span><span class="n">ivy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.searchsorted.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.searchsorted</span>
<span class="sd">    also applies to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;searchsorted&quot;</span><span class="p">,</span>
        <span class="n">x1</span><span class="p">,</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span>
        <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">,</span>
        <span class="n">ret_dtype</span><span class="o">=</span><span class="n">ret_dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="searchsorted"><a class="viewcode-back" href="../../../functional/ivy/sorting/searchsorted/searchsorted_container.html#ivy.container.container_methods.searchsorted">[docs]</a><span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ret_dtype</span><span class="o">=</span><span class="n">ivy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.searchsorted.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.searchsorted</span>
<span class="sd">    also applies to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_searchsorted</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span>
        <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">,</span>
        <span class="n">ret_dtype</span><span class="o">=</span><span class="n">ret_dtype</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.statistical</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># ToDo: implement all methods here as public instance methods</span>




<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../../functional/ivy/statistical/min/min_container.html#ivy.container.container_methods.min">[docs]</a><span class="k">def</span> <span class="nf">min</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.min.</span>
<span class="sd">    This method simply wraps the function, and so</span>
<span class="sd">    the docstring for ivy.min also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input cotainer. Should have a real-valued data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which minimum values must be computed.</span>
<span class="sd">        By default, the minimum value must be computed over the</span>
<span class="sd">        entire array. If a tuple of integers, minimum values must</span>
<span class="sd">        be computed over multiple axes. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        optional boolean, if ``True``, the reduced axes</span>
<span class="sd">        (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result</span>
<span class="sd">        must be compatible with the input array</span>
<span class="sd">        (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes (dimensions) must not be included in the</span>
<span class="sd">        result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if the minimum value was computed over the entire array,</span>
<span class="sd">        a zero-dimensional array containing the minimum value;</span>
<span class="sd">        otherwise, a non-zero-dimensional array containing the</span>
<span class="sd">        minimum values. The returned array must have the same data type</span>
<span class="sd">        as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt; &gt; x = ivy.Container(a=ivy.array([1, 2, 3]), \</span>
<span class="sd">                           b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt; &gt; z = x.min()</span>
<span class="sd">    &gt;&gt; &gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(1),</span>
<span class="sd">        b: ivy.array(2)</span>
<span class="sd">    }</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 2, 3],[-1,0,2]]),</span>
<span class="sd">    ...                   b=ivy.array([[2, 3, 4], [0, 1, 2]]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.min(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 0]),</span>
<span class="sd">        b: ivy.array([2, 0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../../functional/ivy/statistical/max/max_container.html#ivy.container.container_methods.max">[docs]</a><span class="k">def</span> <span class="nf">max</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.max.</span>
<span class="sd">    This method simply wraps the function, and so</span>
<span class="sd">    the docstring for ivy.max also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input container. Should have a real-valued data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which max values must be computed.</span>
<span class="sd">        By default, the maximum value must be computed over</span>
<span class="sd">        the entire array. If a tuple of integers, maximum values</span>
<span class="sd">        must be computed over multiple axes. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        optional boolean, if ``True``, the reduced axes (dimensions)</span>
<span class="sd">        must be included in the result as singleton dimensions,</span>
<span class="sd">        and, accordingly, the result must be compatible with the</span>
<span class="sd">        input array (see :ref:`broadcasting`). Otherwise, if ``False``,</span>
<span class="sd">        the reduced axes (dimensions) must not be included in the</span>
<span class="sd">        result. Default: ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if the maximum value was computed over the entire array, a zero-dimensional</span>
<span class="sd">        array containing the maximum value; otherwise, a non-zero-dimensional array</span>
<span class="sd">        containing the maximum values. The returned array must have the same</span>
<span class="sd">        data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt; &gt; x = ivy.Container(a=ivy.array([1, 2, 3]), \</span>
<span class="sd">                           b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt; &gt; z = x.max()</span>
<span class="sd">    &gt;&gt; &gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(3),</span>
<span class="sd">        b: ivy.array(4)</span>
<span class="sd">    }</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 2, 3],[-1,0,2]]),</span>
<span class="sd">    ...                   b=ivy.array([[2, 3, 4], [0, 1, 2]]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.max(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3, 2]),</span>
<span class="sd">        b: ivy.array([4, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="mean"><a class="viewcode-back" href="../../../functional/ivy/statistical/mean/mean_container.html#ivy.container.container_methods.mean">[docs]</a><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.mean.</span>
<span class="sd">    This method simply wraps the function, and so</span>
<span class="sd">    the docstring for ivy.mean also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which arithmetic means must be computed. By default,</span>
<span class="sd">        the mean must be computed over the entire array. If a Sequence of</span>
<span class="sd">        integers, arithmetic means must be computed over multiple axes.</span>
<span class="sd">        Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        bool, if ``True``, the reduced axes (dimensions) must be included in the</span>
<span class="sd">        result as singleton dimensions, and, accordingly, the result must be</span>
<span class="sd">        compatible with the input array (see :ref:`broadcasting`). Otherwise,</span>
<span class="sd">        if ``False``, the reduced axes (dimensions) must not be included in</span>
<span class="sd">        the result. Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains,</span>
<span class="sd">        otherwise key_chains will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was</span>
<span class="sd">        not applied. Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">       container, if the arithmetic mean was computed over the entire array,</span>
<span class="sd">       a zero-dimensional array containing the arithmetic mean;</span>
<span class="sd">       otherwise, a non-zero-dimensional array containing the arithmetic</span>
<span class="sd">       means. The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.mean()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(1.),</span>
<span class="sd">        b: ivy.array(4.)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.1, 1.1]), b=ivy.array([0.1, 1.1, 2.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.mean(keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.60000002]),</span>
<span class="sd">        b: ivy.array([1.10000002])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0.1, 1.1]]), b=ivy.array([[2, 3]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.mean(axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0.60000002]]),</span>
<span class="sd">        b: ivy.array([[2.5]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0, 1]), b=ivy.array([1.1, 0.2, 1.4]))</span>
<span class="sd">    &gt;&gt;&gt; x.mean(out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(0.),</span>
<span class="sd">        b: ivy.array(0.9)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1., 1.]), b=ivy.array([1., 1., 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array(0.), b=ivy.array(0.))</span>
<span class="sd">    &gt;&gt;&gt; x.mean(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(0.),</span>
<span class="sd">        b: ivy.array(1.)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1., 2.], [3., 4., 5.]]),</span>
<span class="sd">    ...                   b=ivy.array([[3., 4., 5.], [6., 7., 8.]]))</span>
<span class="sd">    &gt;&gt;&gt; x.mean(axis=0, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.5, 2.5, 3.5]),</span>
<span class="sd">        b: ivy.array([4.5, 5.5, 6.5])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1., 1., 1.], [2., 2., 2.]]),</span>
<span class="sd">    ...                   b=ivy.array([[3., 3., 3.], [4., 4., 4.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.mean(x, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="var"><a class="viewcode-back" href="../../../functional/ivy/statistical/var/var_container.html#ivy.container.container_methods.var">[docs]</a><span class="k">def</span> <span class="nf">var</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.var.</span>
<span class="sd">    This method simply wraps the function, and so the</span>
<span class="sd">    docstring for ivy.var also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which variances must be computed. By default, the</span>
<span class="sd">        variance must be computed over the entire array for each array in the input</span>
<span class="sd">        container. If a tuple of integers, variances must be computed over</span>
<span class="sd">        multiple axes. Default: ``None``.</span>
<span class="sd">    correction</span>
<span class="sd">        degrees of freedom adjustment. Setting this parameter to a value other than</span>
<span class="sd">        0 has the effect of adjusting the divisor during the calculation of the</span>
<span class="sd">        variance according to N-c where N corresponds to the total number of</span>
<span class="sd">        elements over which the variance is computed and c corresponds to the</span>
<span class="sd">        provided degrees of freedom adjustment. When computing the variance of a</span>
<span class="sd">        population, setting this parameter to 0 is the standard choice (i.e.,</span>
<span class="sd">        the provided array contains data constituting an entire population).</span>
<span class="sd">        When computing the unbiased sample variance, setting this parameter to 1</span>
<span class="sd">        is the standard choice (i.e., the provided array contains data sampled from</span>
<span class="sd">        a larger population; this is commonly referred to as Bessel&#39;s correction).</span>
<span class="sd">        Default: ``0``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible</span>
<span class="sd">        with the input array (see Broadcasting). Otherwise, if False, the</span>
<span class="sd">        reduced axes (dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains,</span>
<span class="sd">        otherwise key_chains will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not</span>
<span class="sd">        applied. Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container contianing different arrays depends on parameters. see below</span>
<span class="sd">        for the types of arrays in the returned container if the variance was</span>
<span class="sd">        computed over the entire array, a zero-dimensional array containing the</span>
<span class="sd">        variance; otherwise, a non-zero-dimensional array containing the variances.</span>
<span class="sd">        The returned container must have the same data type as self.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, 1.0, 2.0]),</span>
<span class="sd">    ...                   b=ivy.array([3.0, 4.0, 5.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.var()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(0.6666667),</span>
<span class="sd">        b: ivy.array(0.6666667)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, 1.0, 2.0]),</span>
<span class="sd">    ...                   b=ivy.array([3.0, 4.0, 5.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array(0.), b=ivy.array(0.))</span>
<span class="sd">    &gt;&gt;&gt; x.var(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(0.6666667),</span>
<span class="sd">        b: ivy.array(0.6666667)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0]]),</span>
<span class="sd">    ...                   b=ivy.array([[6.0, 7.0, 8.0], [9.0, 10.0, 11.0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 0., 0.]), b=ivy.array([0., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; x.var(axis=0, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2.25, 2.25, 2.25]),</span>
<span class="sd">        b: ivy.array([2.25, 2.25, 2.25])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span>
                <span class="n">x_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_var"><a class="viewcode-back" href="../../../functional/ivy/statistical/var/static_var_container.html#ivy.container.container_methods.static_var">[docs]</a><span class="k">def</span> <span class="nf">static_var</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.var.</span>
<span class="sd">    This method simply wraps the function, and so</span>
<span class="sd">    the docstring for ivy.var also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains,</span>
<span class="sd">        otherwise key_chains will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was</span>
<span class="sd">        not applied. Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">       if the variance was computed over the entire array,</span>
<span class="sd">       a zero-dimensional array containing the variance;</span>
<span class="sd">       otherwise, a non-zero-dimensional array containing the</span>
<span class="sd">       variances. The returned array must have the same data</span>
<span class="sd">       type as x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.1, 0.2, 0.9]),</span>
<span class="sd">    ...                   b=ivy.array([0.7, 0.1, 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_var(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array(0.12666667),</span>
<span class="sd">        b:ivy.array(0.11555555)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;var&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="prod"><a class="viewcode-back" href="../../../functional/ivy/statistical/prod/prod_container.html#ivy.container.container_methods.prod">[docs]</a><span class="k">def</span> <span class="nf">prod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.prod.</span>
<span class="sd">    This method simply wraps the function, and so</span>
<span class="sd">    the docstring for ivy.prod also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which products must be computed. By</span>
<span class="sd">        default, the product must be computed over the entire</span>
<span class="sd">        array. If a tuple of integers, products must be</span>
<span class="sd">        computed over multiple axes. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        bool, if True, the reduced axes (dimensions) must be</span>
<span class="sd">        included in the result as singleton dimensions, and,</span>
<span class="sd">        accordingly, the result must be compatible with the</span>
<span class="sd">        input array (see Broadcasting). Otherwise, if False,</span>
<span class="sd">        the reduced axes (dimensions) must not be included</span>
<span class="sd">        in the result. Default: ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        data type of the returned array.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains,</span>
<span class="sd">        otherwise key_chains will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was</span>
<span class="sd">        not applied. Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container, if the product was computed over the entire</span>
<span class="sd">        array, a zero-dimensional array containing the product;</span>
<span class="sd">        otherwise, a non-zero-dimensional array containing the</span>
<span class="sd">        products. The returned array must have the same data type</span>
<span class="sd">        as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.prod()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(0.),</span>
<span class="sd">        b: ivy.array(60.)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.1, 1.1]), b=ivy.array([0.1, 1.1, 2.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.prod(keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.11000001]),</span>
<span class="sd">        b: ivy.array([0.23100001])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[2, 1]]), b=ivy.array([[2, 3]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.prod(axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[2]]),</span>
<span class="sd">        b: ivy.array([[6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0, 1]), b=ivy.array([1.1, 0.2, 1.4]))</span>
<span class="sd">    &gt;&gt;&gt; x.prod(out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(0),</span>
<span class="sd">        b: ivy.array(0.30800003)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1., 1.]), b=ivy.array([1., 1., 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array(0.), b=ivy.array(0.))</span>
<span class="sd">    &gt;&gt;&gt; x.prod(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(-0.),</span>
<span class="sd">        b: ivy.array(1.)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1., 2.], [3., 4., 5.]]),</span>
<span class="sd">    ...                   b=ivy.array([[3., 4., 5.], [6., 7., 8.]]))</span>
<span class="sd">    &gt;&gt;&gt; x.prod(axis=0, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 4., 10.]),</span>
<span class="sd">        b: ivy.array([18., 28., 40.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1., 1., 1.], [2., 2., 2.]]),</span>
<span class="sd">    ...                   b=ivy.array([[3., 3., 3.], [4., 4., 4.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.prod(x, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">    a: ivy.array([1., 8.]),</span>
<span class="sd">    b: ivy.array([27., 64.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_sum"><a class="viewcode-back" href="../../../functional/ivy/statistical/sum/static_sum_container.html#ivy.container.container_methods.static_sum">[docs]</a><span class="k">def</span> <span class="nf">static_sum</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../../functional/ivy/statistical/sum/sum_container.html#ivy.container.container_methods.sum">[docs]</a><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_sum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="std"><a class="viewcode-back" href="../../../functional/ivy/statistical/std/std_container.html#ivy.container.container_methods.std">[docs]</a><span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span>
                <span class="n">x_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_cumsum"><a class="viewcode-back" href="../../../functional/ivy/statistical/cumsum/static_cumsum_container.html#ivy.container.container_methods.static_cumsum">[docs]</a><span class="k">def</span> <span class="nf">static_cumsum</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cumsum. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.cumsum</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container to apply cumsum.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the cumulative sum is computed. Default is ``0``.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to perform cumsum exclusively. Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumsum from last to first element in the selected</span>
<span class="sd">        axis. Default is ``False`` (from first to last element)</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container whose leaves hold the result of applying cumsum</span>
<span class="sd">        at each original leaf arrays along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 2, 3], [2, 4, 5]]),</span>
<span class="sd">    ...                   b=ivy.array([[4, 5, 6], [2, 3, 1 ]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cumsum(x, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 2, 3],</span>
<span class="sd">                      [3, 6, 8]]),</span>
<span class="sd">        b: ivy.array([[4, 5, 6],</span>
<span class="sd">                      [6, 8, 7]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 5]]),</span>
<span class="sd">    ...                   b=ivy.array([[3, 5, 7]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cumsum(x, axis=0,</span>
<span class="sd">    ...                      exclusive=False, reverse=True, dtype=&#39;float32&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1., 3., 5.]]),</span>
<span class="sd">        b: ivy.array([[3., 5., 7.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 4]]),</span>
<span class="sd">    ...                   b=ivy.array([[3, 5, 8],</span>
<span class="sd">    ...                                [5, 6, 5]]),</span>
<span class="sd">    ...                   c=ivy.array([[2, 4, 1],</span>
<span class="sd">    ...                                [3, 6, 9],</span>
<span class="sd">    ...                                [0, 2, 3]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.zeros((1, 3)),</span>
<span class="sd">    ...                   b = ivy.zeros((2, 3)),</span>
<span class="sd">    ...                   c = ivy.zeros((3,3)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.cumsum(x,axis=1,exclusive=True, reverse=False, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1, 4]]),</span>
<span class="sd">        b: ivy.array([[0, 3, 8],</span>
<span class="sd">                      [0, 5, 11]]),</span>
<span class="sd">        c: ivy.array([[0, 2, 6],</span>
<span class="sd">                      [0, 3, 9],</span>
<span class="sd">                      [0, 0, 2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 4], [5, 7, 8], [9, 10, 11]]),</span>
<span class="sd">    ...                   b=ivy.array([[3, 4, 5], [4, 5, 6], [5, 6, 7]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a= ivy.zeros((3, 3)), b= ivy.zeros((3, 3)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_cumsum(x, axis=1, exclusive=True, reverse=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[7, 4, 0],</span>
<span class="sd">                      [15, 8, 0],</span>
<span class="sd">                      [21, 11, 0]]),</span>
<span class="sd">        b: ivy.array([[9, 5, 0],</span>
<span class="sd">                      [11, 6, 0],</span>
<span class="sd">                      [13, 7, 0]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1],</span>
<span class="sd">    ...                                [1]]),</span>
<span class="sd">    ...                   b=ivy.array([[6, 8, 7],</span>
<span class="sd">    ...                                [2, 0, 1]]),</span>
<span class="sd">    ...                   c=ivy.array([[1, 2],</span>
<span class="sd">    ...                                [3, 4],</span>
<span class="sd">    ...                                [6, 4]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_cumsum(x, axis=0, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1],</span>
<span class="sd">                      [2]]),</span>
<span class="sd">        b: ivy.array([[6, 8, 7],</span>
<span class="sd">                      [8, 8, 8]]),</span>
<span class="sd">        c: ivy.array([[1, 2],</span>
<span class="sd">                      [4, 6],</span>
<span class="sd">                      [10, 10]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;cumsum&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cumsum"><a class="viewcode-back" href="../../../functional/ivy/statistical/cumsum/cumsum_container.html#ivy.container.container_methods.cumsum">[docs]</a><span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cumsum. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.cumsum</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to apply cumsum at leaves.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the cumulative sum is computed. Default is ``0``.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to perform cumsum exclusively. Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumsum from last to first element in the selected</span>
<span class="sd">        axis. Default is ``False`` (from first to last element)</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container whose leaves hold the result of applying cumsum</span>
<span class="sd">        at each original leaf arrays along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :class:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 2, 3],</span>
<span class="sd">    ...                                [2, 4, 5]]),</span>
<span class="sd">    ...                   b=ivy.array([[4, 5, 6],</span>
<span class="sd">    ...                                [2, 3, 1 ]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum(axis=0, dtype=&#39;float64&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1., 2., 3.],</span>
<span class="sd">                      [3., 6., 8.]]),</span>
<span class="sd">        b: ivy.array([[4., 5., 6.],</span>
<span class="sd">                      [6., 8., 7.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 4],</span>
<span class="sd">    ...                                [5, 7, 8],</span>
<span class="sd">    ...                                [9, 10, 11]]),</span>
<span class="sd">    ...                   b=ivy.array([[3, 4, 5],</span>
<span class="sd">    ...                                [4, 5, 6],</span>
<span class="sd">    ...                                [5, 6, 7]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a= ivy.zeros((3, 3)), b= ivy.zeros((3, 3)))</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=1, exclusive=False, reverse=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[8, 7, 4],</span>
<span class="sd">                      [20, 15, 8],</span>
<span class="sd">                      [30, 21, 11]]),</span>
<span class="sd">        b: ivy.array([[12, 9, 5],</span>
<span class="sd">                      [15, 11, 6],</span>
<span class="sd">                      [18, 13, 7]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 4]]),</span>
<span class="sd">    ...                   b=ivy.array([[3, 5, 8],</span>
<span class="sd">    ...                                [5, 6, 5]]),</span>
<span class="sd">    ...                   c=ivy.array([[2, 4, 1],</span>
<span class="sd">    ...                                [3, 6, 9],</span>
<span class="sd">    ...                                [0, 2, 3]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.zeros((1, 3)),</span>
<span class="sd">    ...                   b = ivy.zeros((2, 3)),</span>
<span class="sd">    ...                   c = ivy.zeros((3,3)))</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=1,exclusive=True, reverse=False, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1, 4]]),</span>
<span class="sd">        b: ivy.array([[0, 3, 8],</span>
<span class="sd">                      [0, 5, 11]]),</span>
<span class="sd">        c: ivy.array([[0, 2, 6],</span>
<span class="sd">                      [0, 3, 9],</span>
<span class="sd">                      [0, 0, 2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 3, 2],</span>
<span class="sd">    ...                                [5, 10, 2],</span>
<span class="sd">    ...                                [1, 10, 1]]),</span>
<span class="sd">    ...                   b=ivy.array([[2, 4, 5],</span>
<span class="sd">    ...                                [4, 5, 5],</span>
<span class="sd">    ...                                [0, 1, 3]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum(axis=1,exclusive=True, reverse=True, dtype=&#39;int64&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[5, 2, 0],</span>
<span class="sd">                      [12, 2, 0],</span>
<span class="sd">                      [11, 1, 0]]),</span>
<span class="sd">        b: ivy.array([[9, 5, 0],</span>
<span class="sd">                      [10, 5, 0],</span>
<span class="sd">                      [4, 3, 0]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0],</span>
<span class="sd">    ...                                [5]]),</span>
<span class="sd">    ...                   b=ivy.array([[6, 8, 7],</span>
<span class="sd">    ...                                [4, 2, 3]]),</span>
<span class="sd">    ...                   c=ivy.array([[1, 2],</span>
<span class="sd">    ...                                [3, 4],</span>
<span class="sd">    ...                                [6, 4]]))</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=0, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0],</span>
<span class="sd">                     [5]]),</span>
<span class="sd">        b: ivy.array([[6, 8, 7],</span>
<span class="sd">                     [10, 10, 10]]),</span>
<span class="sd">        c: ivy.array([[1, 2],</span>
<span class="sd">                     [4, 6],</span>
<span class="sd">                     [10, 10]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_cumsum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_cumprod"><a class="viewcode-back" href="../../../functional/ivy/statistical/cumprod/static_cumprod_container.html#ivy.container.container_methods.static_cumprod">[docs]</a><span class="k">def</span> <span class="nf">static_cumprod</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cumprod. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.cumprod</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container to cumprod.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis to cumprod along. Default is ``0``.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to exclude the first element of the input array.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumprod from last to first element in the selected</span>
<span class="sd">        axis. Default is ``False`` (from first to last element)</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Containers with arrays cumprod at leaves along specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array([4, 5, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cumprod(x, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 6]),</span>
<span class="sd">        b: ivy.array([4, 20, 120])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[2, 3], [5, 7], [11, 13]]),</span>
<span class="sd">                          b=ivy.array([[3, 4], [4, 5], [5, 6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.zeros((3, 2)), b = ivy.zeros((3, 2)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_cumprod(x, axis=1, exclusive=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 2],</span>
<span class="sd">                      [1, 5],</span>
<span class="sd">                      [1, 11]]),</span>
<span class="sd">        b: ivy.array([[1, 3],</span>
<span class="sd">                      [1, 4],</span>
<span class="sd">                      [1, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;cumprod&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cumprod"><a class="viewcode-back" href="../../../functional/ivy/statistical/cumprod/cumprod_container.html#ivy.container.container_methods.cumprod">[docs]</a><span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cumprod. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.cumprod</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to cumprod at leaves.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the cumulative product is computed. Default is ``0``.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to exclude the first element of the input array.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Containers with arrays cumprod at leaves along specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :class:`ivy.Container` instances:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array([4, 5, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumprod(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 6]),</span>
<span class="sd">        b: ivy.array([4, 20, 120])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[2, 3], [5, 7], [11, 13]]),</span>
<span class="sd">                          b=ivy.array([[3, 4], [4, 5], [5, 6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.zeros((3, 2)), b = ivy.zeros((3, 2)))</span>
<span class="sd">    &gt;&gt;&gt; x.cumprod(axis=1, exclusive=True, out=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 2],</span>
<span class="sd">                      [1, 5],</span>
<span class="sd">                      [1, 11]]),</span>
<span class="sd">        b: ivy.array([[1, 3],</span>
<span class="sd">                      [1, 4],</span>
<span class="sd">                      [1, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_cumprod</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">exclusive</span><span class="o">=</span><span class="n">exclusive</span><span class="p">,</span>
        <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="einsum"><a class="viewcode-back" href="../../../functional/ivy/statistical/einsum/einsum_container.html#ivy.container.container_methods.einsum">[docs]</a><span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">equation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">x_</span><span class="p">)</span> <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.utility</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="c1"># noinspection PyMissingConstructor</span>




<div class="viewcode-block" id="static_all"><a class="viewcode-back" href="../../../functional/ivy/utility/all/static_all_container.html#ivy.container.container_methods.static_all">[docs]</a><span class="k">def</span> <span class="nf">static_all</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.all. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.all also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical AND reduction. By default, a</span>
<span class="sd">        logical AND reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical AND reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default  ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical AND reduction was performed over the entire array, the returned</span>
<span class="sd">        container must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned container must be a non-zero-dimensional array</span>
<span class="sd">        containing the test results. The returned container must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]), b=ivy.array([0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(False),</span>
<span class="sd">        b: ivy.array(False)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="all"><a class="viewcode-back" href="../../../functional/ivy/utility/all/all_container.html#ivy.container.container_methods.all">[docs]</a><span class="k">def</span> <span class="nf">all</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.all. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.all also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical AND reduction. By default, a</span>
<span class="sd">        logical AND reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical AND reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default  ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical AND reduction was performed over the entire array, the returned</span>
<span class="sd">        container must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned container must have non-zero-dimensional arrays</span>
<span class="sd">        containing the test results. The returned container must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]), b=ivy.array([0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.all()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(False),</span>
<span class="sd">        b: ivy.array(False)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_all</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="static_any"><a class="viewcode-back" href="../../../functional/ivy/utility/any/static_any_container.html#ivy.container.container_methods.static_any">[docs]</a><span class="k">def</span> <span class="nf">static_any</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.any. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.any also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical OR reduction. By default, a</span>
<span class="sd">        logical OR reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical OR reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical OR reduction was performed over the entire array, the returned</span>
<span class="sd">        container must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned container must have non-zero-dimensional arrays</span>
<span class="sd">        containing the test results. The returned container must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]), b=ivy.array([0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_any(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(True),</span>
<span class="sd">        b: ivy.array(True)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="any"><a class="viewcode-back" href="../../../functional/ivy/utility/any/any_container.html#ivy.container.container_methods.any">[docs]</a><span class="k">def</span> <span class="nf">any</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.any. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.any also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical OR reduction. By default, a</span>
<span class="sd">        logical OR reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical OR reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is ``None``.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is ``True``.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is ``False``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical OR reduction was performed over the entire array, the returned</span>
<span class="sd">        container must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned container must have non-zero-dimensional arrays</span>
<span class="sd">        containing the test results. The returned container must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]), b=ivy.array([0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.any()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(True),</span>
<span class="sd">        b: ivy.array(True)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="c1">#ivy.container.wrapping</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>
<span class="n">TO_IGNORE</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;is_ivy_array&quot;</span><span class="p">,</span> <span class="s2">&quot;is_native_array&quot;</span><span class="p">,</span> <span class="s2">&quot;is_array&quot;</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_wrap_function</span><span class="p">(</span><span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Wraps the function called `function_name`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    function_name</span>
<span class="sd">        the name of the function e.g. &quot;abs&quot;, &quot;mean&quot; etc.</span>
<span class="sd">    static</span>
<span class="sd">        whether the function being wrapped will be added as a static method.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_function</span>
<span class="sd">        the wrapped function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">new_function</span><span class="p">(</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">function_name</span><span class="p">]</span>
        <span class="n">data_idx</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">array_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="p">(</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">args</span>
            <span class="ow">and</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_container</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">static</span>
        <span class="p">):</span>
            <span class="c1"># if the method has been called as an instance method, and self should not</span>
            <span class="c1"># be the first positional arg, then we need to re-arrange and place self</span>
            <span class="c1"># in the correct location in the args or kwargs</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">data_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">]</span>
                <span class="n">ivy</span><span class="o">.</span><span class="n">insert_into_nest_at_index</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">data_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">]</span>
                <span class="n">ivy</span><span class="o">.</span><span class="n">insert_into_nest_at_index</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="c1"># return function multi-mapped across the corresponding leaves of the containers</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
            <span class="n">function_name</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">new_function</span>



<span class="k">def</span> <span class="nf">add_ivy_container_instance_methods</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">modules</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ModuleType</span><span class="p">],</span>
    <span class="n">static</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">to_ignore</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="p">(),</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loop over all ivy modules such as activations, general, etc. and add</span>
<span class="sd">    the module functions to ivy container as instance methods using _wrap_function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls</span>
<span class="sd">        the class we want to add the instance methods to.</span>
<span class="sd">    modules</span>
<span class="sd">        the modules to loop over: activations, general etc.</span>
<span class="sd">    static</span>
<span class="sd">        whether the function should be added as a static method.</span>
<span class="sd">    to_ignore</span>
<span class="sd">        any functions we don&#39;t want to add an instance method for.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    As shown, `add_ivy_container_instance_methods` adds all the appropriate functions</span>
<span class="sd">    from the statistical module as instance methods to our toy `ContainerExample` class:</span>
<span class="sd">    &gt;&gt;&gt; from ivy.functional.ivy import statistical</span>
<span class="sd">    &gt;&gt;&gt; class ContainerExample:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; ivy.add_ivy_container_instance_methods(ContainerExample, [statistical])</span>
<span class="sd">    &gt;&gt;&gt; print(hasattr(ContainerExample, &quot;mean&quot;), hasattr(ContainerExample, &quot;var&quot;))</span>
<span class="sd">    True True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, Ivy Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>